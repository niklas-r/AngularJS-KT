(function (window, document, undefined) {;// this will happen if a url from IE8-9 has been shared
if (location.hash && (/#\/.*?\/(\d+\/)?edit/i).test(location.hash)) {
  // redirect
  window.location = jsbin.root + location.hash.substring(1) + location.search;
};/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
  navigator = window.navigator,
  location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
    // The jQuery object is actually just the init constructor 'enhanced'
    return new jQuery.fn.init( selector, context, rootjQuery );
  },

  // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,

  // Map over the $ in case of overwrite
  _$ = window.$,

  // A central reference to the root jQuery(document)
  rootjQuery,

  // A simple way to check for HTML strings or ID strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

  // Check if a string has a non-whitespace character in it
  rnotwhite = /\S/,

  // Used for trimming whitespace
  trimLeft = /^\s+/,
  trimRight = /\s+$/,

  // Match a standalone tag
  rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

  // JSON RegExp
  rvalidchars = /^[\],:{}\s]*$/,
  rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
  rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
  rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

  // Useragent RegExp
  rwebkit = /(webkit)[ \/]([\w.]+)/,
  ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
  rmsie = /(msie) ([\w.]+)/,
  rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

  // Matches dashed string for camelizing
  rdashAlpha = /-([a-z]|[0-9])/ig,
  rmsPrefix = /^-ms-/,

  // Used by jQuery.camelCase as callback to replace()
  fcamelCase = function( all, letter ) {
    return ( letter + "" ).toUpperCase();
  },

  // Keep a UserAgent string for use with jQuery.browser
  userAgent = navigator.userAgent,

  // For matching the engine and version of the browser
  browserMatch,

  // The deferred used on DOM ready
  readyList,

  // The ready event handler
  DOMContentLoaded,

  // Save a reference to some core methods
  toString = Object.prototype.toString,
  hasOwn = Object.prototype.hasOwnProperty,
  push = Array.prototype.push,
  slice = Array.prototype.slice,
  trim = String.prototype.trim,
  indexOf = Array.prototype.indexOf,

  // [[Class]] -> type pairs
  class2type = {};

jQuery.fn = jQuery.prototype = {
  constructor: jQuery,
  init: function( selector, context, rootjQuery ) {
    var match, elem, ret, doc;

    // Handle $(""), $(null), or $(undefined)
    if ( !selector ) {
      return this;
    }

    // Handle $(DOMElement)
    if ( selector.nodeType ) {
      this.context = this[0] = selector;
      this.length = 1;
      return this;
    }

    // The body element only exists once, optimize finding it
    if ( selector === "body" && !context && document.body ) {
      this.context = document;
      this[0] = document.body;
      this.selector = selector;
      this.length = 1;
      return this;
    }

    // Handle HTML strings
    if ( typeof selector === "string" ) {
      // Are we dealing with HTML string or an ID?
      if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [ null, selector, null ];

      } else {
        match = quickExpr.exec( selector );
      }

      // Verify a match, and that no context was specified for #id
      if ( match && (match[1] || !context) ) {

        // HANDLE: $(html) -> $(array)
        if ( match[1] ) {
          context = context instanceof jQuery ? context[0] : context;
          doc = ( context ? context.ownerDocument || context : document );

          // If a single string is passed in and it's a single tag
          // just do a createElement and skip the rest
          ret = rsingleTag.exec( selector );

          if ( ret ) {
            if ( jQuery.isPlainObject( context ) ) {
              selector = [ document.createElement( ret[1] ) ];
              jQuery.fn.attr.call( selector, context, true );

            } else {
              selector = [ doc.createElement( ret[1] ) ];
            }

          } else {
            ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
            selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
          }

          return jQuery.merge( this, selector );

        // HANDLE: $("#id")
        } else {
          elem = document.getElementById( match[2] );

          // Check parentNode to catch when Blackberry 4.6 returns
          // nodes that are no longer in the document #6963
          if ( elem && elem.parentNode ) {
            // Handle the case where IE and Opera return items
            // by name instead of ID
            if ( elem.id !== match[2] ) {
              return rootjQuery.find( selector );
            }

            // Otherwise, we inject the element directly into the jQuery object
            this.length = 1;
            this[0] = elem;
          }

          this.context = document;
          this.selector = selector;
          return this;
        }

      // HANDLE: $(expr, $(...))
      } else if ( !context || context.jquery ) {
        return ( context || rootjQuery ).find( selector );

      // HANDLE: $(expr, context)
      // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor( context ).find( selector );
      }

    // HANDLE: $(function)
    // Shortcut for document ready
    } else if ( jQuery.isFunction( selector ) ) {
      return rootjQuery.ready( selector );
    }

    if ( selector.selector !== undefined ) {
      this.selector = selector.selector;
      this.context = selector.context;
    }

    return jQuery.makeArray( selector, this );
  },

  // Start with an empty selector
  selector: "",

  // The current version of jQuery being used
  jquery: "1.7.1",

  // The default length of a jQuery object is 0
  length: 0,

  // The number of elements contained in the matched element set
  size: function() {
    return this.length;
  },

  toArray: function() {
    return slice.call( this, 0 );
  },

  // Get the Nth element in the matched element set OR
  // Get the whole matched element set as a clean array
  get: function( num ) {
    return num == null ?

      // Return a 'clean' array
      this.toArray() :

      // Return just the object
      ( num < 0 ? this[ this.length + num ] : this[ num ] );
  },

  // Take an array of elements and push it onto the stack
  // (returning the new matched element set)
  pushStack: function( elems, name, selector ) {
    // Build a new jQuery matched element set
    var ret = this.constructor();

    if ( jQuery.isArray( elems ) ) {
      push.apply( ret, elems );

    } else {
      jQuery.merge( ret, elems );
    }

    // Add the old object onto the stack (as a reference)
    ret.prevObject = this;

    ret.context = this.context;

    if ( name === "find" ) {
      ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
    } else if ( name ) {
      ret.selector = this.selector + "." + name + "(" + selector + ")";
    }

    // Return the newly-formed element set
    return ret;
  },

  // Execute a callback for every element in the matched set.
  // (You can seed the arguments with an array of args, but this is
  // only used internally.)
  each: function( callback, args ) {
    return jQuery.each( this, callback, args );
  },

  ready: function( fn ) {
    // Attach the listeners
    jQuery.bindReady();

    // Add the callback
    readyList.add( fn );

    return this;
  },

  eq: function( i ) {
    i = +i;
    return i === -1 ?
      this.slice( i ) :
      this.slice( i, i + 1 );
  },

  first: function() {
    return this.eq( 0 );
  },

  last: function() {
    return this.eq( -1 );
  },

  slice: function() {
    return this.pushStack( slice.apply( this, arguments ),
      "slice", slice.call(arguments).join(",") );
  },

  map: function( callback ) {
    return this.pushStack( jQuery.map(this, function( elem, i ) {
      return callback.call( elem, i, elem );
    }));
  },

  end: function() {
    return this.prevObject || this.constructor(null);
  },

  // For internal use only.
  // Behaves like an Array's method, not like a jQuery method.
  push: push,
  sort: [].sort,
  splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
  var options, name, src, copy, copyIsArray, clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // Handle a deep copy situation
  if ( typeof target === "boolean" ) {
    deep = target;
    target = arguments[1] || {};
    // skip the boolean and the target
    i = 2;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
    target = {};
  }

  // extend jQuery itself if only one argument is passed
  if ( length === i ) {
    target = this;
    --i;
  }

  for ( ; i < length; i++ ) {
    // Only deal with non-null/undefined values
    if ( (options = arguments[ i ]) != null ) {
      // Extend the base object
      for ( name in options ) {
        src = target[ name ];
        copy = options[ name ];

        // Prevent never-ending loop
        if ( target === copy ) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
          if ( copyIsArray ) {
            copyIsArray = false;
            clone = src && jQuery.isArray(src) ? src : [];

          } else {
            clone = src && jQuery.isPlainObject(src) ? src : {};
          }

          // Never move original objects, clone them
          target[ name ] = jQuery.extend( deep, clone, copy );

        // Don't bring in undefined values
        } else if ( copy !== undefined ) {
          target[ name ] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
};

jQuery.extend({
  noConflict: function( deep ) {
    if ( window.$ === jQuery ) {
      window.$ = _$;
    }

    if ( deep && window.jQuery === jQuery ) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  },

  // Is the DOM ready to be used? Set to true once it occurs.
  isReady: false,

  // A counter to track how many items to wait for before
  // the ready event fires. See #6781
  readyWait: 1,

  // Hold (or release) the ready event
  holdReady: function( hold ) {
    if ( hold ) {
      jQuery.readyWait++;
    } else {
      jQuery.ready( true );
    }
  },

  // Handle when the DOM is ready
  ready: function( wait ) {
    // Either a released hold or an DOMready/load event and not yet ready
    if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
      // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
      if ( !document.body ) {
        return setTimeout( jQuery.ready, 1 );
      }

      // Remember that the DOM is ready
      jQuery.isReady = true;

      // If a normal DOM Ready event fired, decrement, and wait if need be
      if ( wait !== true && --jQuery.readyWait > 0 ) {
        return;
      }

      // If there are functions bound, to execute
      readyList.fireWith( document, [ jQuery ] );

      // Trigger any bound ready events
      if ( jQuery.fn.trigger ) {
        jQuery( document ).trigger( "ready" ).off( "ready" );
      }
    }
  },

  bindReady: function() {
    if ( readyList ) {
      return;
    }

    readyList = jQuery.Callbacks( "once memory" );

    // Catch cases where $(document).ready() is called after the
    // browser event has already occurred.
    if ( document.readyState === "complete" ) {
      // Handle it asynchronously to allow scripts the opportunity to delay ready
      return setTimeout( jQuery.ready, 1 );
    }

    // Mozilla, Opera and webkit nightlies currently support this event
    if ( document.addEventListener ) {
      // Use the handy event callback
      document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

      // A fallback to window.onload, that will always work
      window.addEventListener( "load", jQuery.ready, false );

    // If IE event model is used
    } else if ( document.attachEvent ) {
      // ensure firing before onload,
      // maybe late but safe also for iframes
      document.attachEvent( "onreadystatechange", DOMContentLoaded );

      // A fallback to window.onload, that will always work
      window.attachEvent( "onload", jQuery.ready );

      // If IE and not a frame
      // continually check to see if the document is ready
      var toplevel = false;

      try {
        toplevel = window.frameElement == null;
      } catch(e) {}

      if ( document.documentElement.doScroll && toplevel ) {
        doScrollCheck();
      }
    }
  },

  // See test/unit/core.js for details concerning isFunction.
  // Since version 1.3, DOM methods and functions like alert
  // aren't supported. They return false on IE (#2968).
  isFunction: function( obj ) {
    return jQuery.type(obj) === "function";
  },

  isArray: Array.isArray || function( obj ) {
    return jQuery.type(obj) === "array";
  },

  // A crude way of determining if an object is a window
  isWindow: function( obj ) {
    return obj && typeof obj === "object" && "setInterval" in obj;
  },

  isNumeric: function( obj ) {
    return !isNaN( parseFloat(obj) ) && isFinite( obj );
  },

  type: function( obj ) {
    return obj == null ?
      String( obj ) :
      class2type[ toString.call(obj) ] || "object";
  },

  isPlainObject: function( obj ) {
    // Must be an Object.
    // Because of IE, we also have to check the presence of the constructor property.
    // Make sure that DOM nodes and window objects don't pass through, as well
    if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
      return false;
    }

    try {
      // Not own constructor property must be Object
      if ( obj.constructor &&
        !hasOwn.call(obj, "constructor") &&
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
        return false;
      }
    } catch ( e ) {
      // IE8,9 Will throw exceptions on certain host objects #9897
      return false;
    }

    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.

    var key;
    for ( key in obj ) {}

    return key === undefined || hasOwn.call( obj, key );
  },

  isEmptyObject: function( obj ) {
    for ( var name in obj ) {
      return false;
    }
    return true;
  },

  error: function( msg ) {
    throw new Error( msg );
  },

  parseJSON: function( data ) {
    if ( typeof data !== "string" || !data ) {
      return null;
    }

    // Make sure leading/trailing whitespace is removed (IE can't handle it)
    data = jQuery.trim( data );

    // Attempt to parse using the native JSON parser first
    if ( window.JSON && window.JSON.parse ) {
      return window.JSON.parse( data );
    }

    // Make sure the incoming data is actual JSON
    // Logic borrowed from http://json.org/json2.js
    if ( rvalidchars.test( data.replace( rvalidescape, "@" )
      .replace( rvalidtokens, "]" )
      .replace( rvalidbraces, "")) ) {

      return ( new Function( "return " + data ) )();

    }
    jQuery.error( "Invalid JSON: " + data );
  },

  // Cross-browser xml parsing
  parseXML: function( data ) {
    var xml, tmp;
    try {
      if ( window.DOMParser ) { // Standard
        tmp = new DOMParser();
        xml = tmp.parseFromString( data , "text/xml" );
      } else { // IE
        xml = new ActiveXObject( "Microsoft.XMLDOM" );
        xml.async = "false";
        xml.loadXML( data );
      }
    } catch( e ) {
      xml = undefined;
    }
    if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
      jQuery.error( "Invalid XML: " + data );
    }
    return xml;
  },

  noop: function() {},

  // Evaluates a script in a global context
  // Workarounds based on findings by Jim Driscoll
  // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
  globalEval: function( data ) {
    if ( data && rnotwhite.test( data ) ) {
      // We use execScript on Internet Explorer
      // We use an anonymous function so that context is window
      // rather than jQuery in Firefox
      ( window.execScript || function( data ) {
        window[ "eval" ].call( window, data );
      } )( data );
    }
  },

  // Convert dashed to camelCase; used by the css and data modules
  // Microsoft forgot to hump their vendor prefix (#9572)
  camelCase: function( string ) {
    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  },

  nodeName: function( elem, name ) {
    return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
  },

  // args is for internal usage only
  each: function( object, callback, args ) {
    var name, i = 0,
      length = object.length,
      isObj = length === undefined || jQuery.isFunction( object );

    if ( args ) {
      if ( isObj ) {
        for ( name in object ) {
          if ( callback.apply( object[ name ], args ) === false ) {
            break;
          }
        }
      } else {
        for ( ; i < length; ) {
          if ( callback.apply( object[ i++ ], args ) === false ) {
            break;
          }
        }
      }

    // A special, fast, case for the most common use of each
    } else {
      if ( isObj ) {
        for ( name in object ) {
          if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
            break;
          }
        }
      } else {
        for ( ; i < length; ) {
          if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
            break;
          }
        }
      }
    }

    return object;
  },

  // Use native String.trim function wherever possible
  trim: trim ?
    function( text ) {
      return text == null ?
        "" :
        trim.call( text );
    } :

    // Otherwise use our own trimming functionality
    function( text ) {
      return text == null ?
        "" :
        text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
    },

  // results is for internal usage only
  makeArray: function( array, results ) {
    var ret = results || [];

    if ( array != null ) {
      // The window, strings (and functions) also have 'length'
      // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
      var type = jQuery.type( array );

      if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
        push.call( ret, array );
      } else {
        jQuery.merge( ret, array );
      }
    }

    return ret;
  },

  inArray: function( elem, array, i ) {
    var len;

    if ( array ) {
      if ( indexOf ) {
        return indexOf.call( array, elem, i );
      }

      len = array.length;
      i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

      for ( ; i < len; i++ ) {
        // Skip accessing in sparse arrays
        if ( i in array && array[ i ] === elem ) {
          return i;
        }
      }
    }

    return -1;
  },

  merge: function( first, second ) {
    var i = first.length,
      j = 0;

    if ( typeof second.length === "number" ) {
      for ( var l = second.length; j < l; j++ ) {
        first[ i++ ] = second[ j ];
      }

    } else {
      while ( second[j] !== undefined ) {
        first[ i++ ] = second[ j++ ];
      }
    }

    first.length = i;

    return first;
  },

  grep: function( elems, callback, inv ) {
    var ret = [], retVal;
    inv = !!inv;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( var i = 0, length = elems.length; i < length; i++ ) {
      retVal = !!callback( elems[ i ], i );
      if ( inv !== retVal ) {
        ret.push( elems[ i ] );
      }
    }

    return ret;
  },

  // arg is for internal usage only
  map: function( elems, callback, arg ) {
    var value, key, ret = [],
      i = 0,
      length = elems.length,
      // jquery objects are treated as arrays
      isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

    // Go through the array, translating each of the items to their
    if ( isArray ) {
      for ( ; i < length; i++ ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret[ ret.length ] = value;
        }
      }

    // Go through every key on the object,
    } else {
      for ( key in elems ) {
        value = callback( elems[ key ], key, arg );

        if ( value != null ) {
          ret[ ret.length ] = value;
        }
      }
    }

    // Flatten any nested arrays
    return ret.concat.apply( [], ret );
  },

  // A global GUID counter for objects
  guid: 1,

  // Bind a function to a context, optionally partially applying any
  // arguments.
  proxy: function( fn, context ) {
    if ( typeof context === "string" ) {
      var tmp = fn[ context ];
      context = fn;
      fn = tmp;
    }

    // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.
    if ( !jQuery.isFunction( fn ) ) {
      return undefined;
    }

    // Simulated bind
    var args = slice.call( arguments, 2 ),
      proxy = function() {
        return fn.apply( context, args.concat( slice.call( arguments ) ) );
      };

    // Set the guid of unique handler to the same of original handler, so it can be removed
    proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

    return proxy;
  },

  // Mutifunctional method to get and set values to a collection
  // The value/s can optionally be executed if it's a function
  access: function( elems, key, value, exec, fn, pass ) {
    var length = elems.length;

    // Setting many attributes
    if ( typeof key === "object" ) {
      for ( var k in key ) {
        jQuery.access( elems, k, key[k], exec, fn, value );
      }
      return elems;
    }

    // Setting one attribute
    if ( value !== undefined ) {
      // Optionally, function values get executed if exec is true
      exec = !pass && exec && jQuery.isFunction(value);

      for ( var i = 0; i < length; i++ ) {
        fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
      }

      return elems;
    }

    // Getting an attribute
    return length ? fn( elems[0], key ) : undefined;
  },

  now: function() {
    return ( new Date() ).getTime();
  },

  // Use of jQuery.browser is frowned upon.
  // More details: http://docs.jquery.com/Utilities/jQuery.browser
  uaMatch: function( ua ) {
    ua = ua.toLowerCase();

    var match = rwebkit.exec( ua ) ||
      ropera.exec( ua ) ||
      rmsie.exec( ua ) ||
      ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
      [];

    return { browser: match[1] || "", version: match[2] || "0" };
  },

  sub: function() {
    function jQuerySub( selector, context ) {
      return new jQuerySub.fn.init( selector, context );
    }
    jQuery.extend( true, jQuerySub, this );
    jQuerySub.superclass = this;
    jQuerySub.fn = jQuerySub.prototype = this();
    jQuerySub.fn.constructor = jQuerySub;
    jQuerySub.sub = this.sub;
    jQuerySub.fn.init = function init( selector, context ) {
      if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
        context = jQuerySub( context );
      }

      return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
    };
    jQuerySub.fn.init.prototype = jQuerySub.fn;
    var rootjQuerySub = jQuerySub(document);
    return jQuerySub;
  },

  browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
  class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
  jQuery.browser[ browserMatch.browser ] = true;
  jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
  jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
  trimLeft = /^[\s\xA0]+/;
  trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
  DOMContentLoaded = function() {
    document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
    jQuery.ready();
  };

} else if ( document.attachEvent ) {
  DOMContentLoaded = function() {
    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
    if ( document.readyState === "complete" ) {
      document.detachEvent( "onreadystatechange", DOMContentLoaded );
      jQuery.ready();
    }
  };
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
  if ( jQuery.isReady ) {
    return;
  }

  try {
    // If IE is used, use the trick by Diego Perini
    // http://javascript.nwbox.com/IEContentLoaded/
    document.documentElement.doScroll("left");
  } catch(e) {
    setTimeout( doScrollCheck, 1 );
    return;
  }

  // and execute any waiting functions
  jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
  var object = flagsCache[ flags ] = {},
    i, length;
  flags = flags.split( /\s+/ );
  for ( i = 0, length = flags.length; i < length; i++ ) {
    object[ flags[i] ] = true;
  }
  return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  flags:  an optional list of space-separated flags that will change how
 *      the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *  once:     will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:     will keep track of previous values and will call any callback added
 *          after the list has been fired right away with the latest "memorized"
 *          values (like a Deferred)
 *
 *  unique:     will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:  interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

  // Convert flags from String-formatted to Object-formatted
  // (we check in cache first)
  flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

  var // Actual callback list
    list = [],
    // Stack of fire calls for repeatable lists
    stack = [],
    // Last fire value (for non-forgettable lists)
    memory,
    // Flag to know if list is currently firing
    firing,
    // First callback to fire (used internally by add and fireWith)
    firingStart,
    // End of the loop when firing
    firingLength,
    // Index of currently firing callback (modified by remove if needed)
    firingIndex,
    // Add one or several callbacks to the list
    add = function( args ) {
      var i,
        length,
        elem,
        type,
        actual;
      for ( i = 0, length = args.length; i < length; i++ ) {
        elem = args[ i ];
        type = jQuery.type( elem );
        if ( type === "array" ) {
          // Inspect recursively
          add( elem );
        } else if ( type === "function" ) {
          // Add if not in unique mode and callback is not in
          if ( !flags.unique || !self.has( elem ) ) {
            list.push( elem );
          }
        }
      }
    },
    // Fire callbacks
    fire = function( context, args ) {
      args = args || [];
      memory = !flags.memory || [ context, args ];
      firing = true;
      firingIndex = firingStart || 0;
      firingStart = 0;
      firingLength = list.length;
      for ( ; list && firingIndex < firingLength; firingIndex++ ) {
        if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
          memory = true; // Mark as halted
          break;
        }
      }
      firing = false;
      if ( list ) {
        if ( !flags.once ) {
          if ( stack && stack.length ) {
            memory = stack.shift();
            self.fireWith( memory[ 0 ], memory[ 1 ] );
          }
        } else if ( memory === true ) {
          self.disable();
        } else {
          list = [];
        }
      }
    },
    // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function() {
        if ( list ) {
          var length = list.length;
          add( arguments );
          // Do we need to add the callbacks to the
          // current firing batch?
          if ( firing ) {
            firingLength = list.length;
          // With memory, if we're not firing then
          // we should call right away, unless previous
          // firing was halted (stopOnFalse)
          } else if ( memory && memory !== true ) {
            firingStart = length;
            fire( memory[ 0 ], memory[ 1 ] );
          }
        }
        return this;
      },
      // Remove a callback from the list
      remove: function() {
        if ( list ) {
          var args = arguments,
            argIndex = 0,
            argLength = args.length;
          for ( ; argIndex < argLength ; argIndex++ ) {
            for ( var i = 0; i < list.length; i++ ) {
              if ( args[ argIndex ] === list[ i ] ) {
                // Handle firingIndex and firingLength
                if ( firing ) {
                  if ( i <= firingLength ) {
                    firingLength--;
                    if ( i <= firingIndex ) {
                      firingIndex--;
                    }
                  }
                }
                // Remove the element
                list.splice( i--, 1 );
                // If we have some unicity property then
                // we only need to do this once
                if ( flags.unique ) {
                  break;
                }
              }
            }
          }
        }
        return this;
      },
      // Control if a given callback is in the list
      has: function( fn ) {
        if ( list ) {
          var i = 0,
            length = list.length;
          for ( ; i < length; i++ ) {
            if ( fn === list[ i ] ) {
              return true;
            }
          }
        }
        return false;
      },
      // Remove all callbacks from the list
      empty: function() {
        list = [];
        return this;
      },
      // Have the list do nothing anymore
      disable: function() {
        list = stack = memory = undefined;
        return this;
      },
      // Is it disabled?
      disabled: function() {
        return !list;
      },
      // Lock the list in its current state
      lock: function() {
        stack = undefined;
        if ( !memory || memory === true ) {
          self.disable();
        }
        return this;
      },
      // Is it locked?
      locked: function() {
        return !stack;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function( context, args ) {
        if ( stack ) {
          if ( firing ) {
            if ( !flags.once ) {
              stack.push( [ context, args ] );
            }
          } else if ( !( flags.once && memory ) ) {
            fire( context, args );
          }
        }
        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function() {
        self.fireWith( this, arguments );
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function() {
        return !!memory;
      }
    };

  return self;
};




var // Static reference to slice
  sliceDeferred = [].slice;

jQuery.extend({

  Deferred: function( func ) {
    var doneList = jQuery.Callbacks( "once memory" ),
      failList = jQuery.Callbacks( "once memory" ),
      progressList = jQuery.Callbacks( "memory" ),
      state = "pending",
      lists = {
        resolve: doneList,
        reject: failList,
        notify: progressList
      },
      promise = {
        done: doneList.add,
        fail: failList.add,
        progress: progressList.add,

        state: function() {
          return state;
        },

        // Deprecated
        isResolved: doneList.fired,
        isRejected: failList.fired,

        then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
          deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
          return this;
        },
        always: function() {
          deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
          return this;
        },
        pipe: function( fnDone, fnFail, fnProgress ) {
          return jQuery.Deferred(function( newDefer ) {
            jQuery.each( {
              done: [ fnDone, "resolve" ],
              fail: [ fnFail, "reject" ],
              progress: [ fnProgress, "notify" ]
            }, function( handler, data ) {
              var fn = data[ 0 ],
                action = data[ 1 ],
                returned;
              if ( jQuery.isFunction( fn ) ) {
                deferred[ handler ](function() {
                  returned = fn.apply( this, arguments );
                  if ( returned && jQuery.isFunction( returned.promise ) ) {
                    returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
                  } else {
                    newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
                  }
                });
              } else {
                deferred[ handler ]( newDefer[ action ] );
              }
            });
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function( obj ) {
          if ( obj == null ) {
            obj = promise;
          } else {
            for ( var key in promise ) {
              obj[ key ] = promise[ key ];
            }
          }
          return obj;
        }
      },
      deferred = promise.promise({}),
      key;

    for ( key in lists ) {
      deferred[ key ] = lists[ key ].fire;
      deferred[ key + "With" ] = lists[ key ].fireWith;
    }

    // Handle state
    deferred.done( function() {
      state = "resolved";
    }, failList.disable, progressList.lock ).fail( function() {
      state = "rejected";
    }, doneList.disable, progressList.lock );

    // Call given func if any
    if ( func ) {
      func.call( deferred, deferred );
    }

    // All done!
    return deferred;
  },

  // Deferred helper
  when: function( firstParam ) {
    var args = sliceDeferred.call( arguments, 0 ),
      i = 0,
      length = args.length,
      pValues = new Array( length ),
      count = length,
      pCount = length,
      deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
        firstParam :
        jQuery.Deferred(),
      promise = deferred.promise();
    function resolveFunc( i ) {
      return function( value ) {
        args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
        if ( !( --count ) ) {
          deferred.resolveWith( deferred, args );
        }
      };
    }
    function progressFunc( i ) {
      return function( value ) {
        pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
        deferred.notifyWith( promise, pValues );
      };
    }
    if ( length > 1 ) {
      for ( ; i < length; i++ ) {
        if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
          args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
        } else {
          --count;
        }
      }
      if ( !count ) {
        deferred.resolveWith( deferred, args );
      }
    } else if ( deferred !== firstParam ) {
      deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
    }
    return promise;
  }
});




jQuery.support = (function() {

  var support,
    all,
    a,
    select,
    opt,
    input,
    marginDiv,
    fragment,
    tds,
    events,
    eventName,
    i,
    isSupported,
    div = document.createElement( "div" ),
    documentElement = document.documentElement;

  // Preliminary tests
  div.setAttribute("className", "t");
  div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

  all = div.getElementsByTagName( "*" );
  a = div.getElementsByTagName( "a" )[ 0 ];

  // Can't get basic test support
  if ( !all || !all.length || !a ) {
    return {};
  }

  // First batch of supports tests
  select = document.createElement( "select" );
  opt = select.appendChild( document.createElement("option") );
  input = div.getElementsByTagName( "input" )[ 0 ];

  support = {
    // IE strips leading whitespace when .innerHTML is used
    leadingWhitespace: ( div.firstChild.nodeType === 3 ),

    // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables
    tbody: !div.getElementsByTagName("tbody").length,

    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    htmlSerialize: !!div.getElementsByTagName("link").length,

    // Get the style information from getAttribute
    // (IE uses .cssText instead)
    style: /top/.test( a.getAttribute("style") ),

    // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)
    hrefNormalized: ( a.getAttribute("href") === "/a" ),

    // Make sure that element opacity exists
    // (IE uses filter instead)
    // Use a regex to work around a WebKit issue. See #5145
    opacity: /^0.55/.test( a.style.opacity ),

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    cssFloat: !!a.style.cssFloat,

    // Make sure that if no value is specified for a checkbox
    // that it defaults to "on".
    // (WebKit defaults to "" instead)
    checkOn: ( input.value === "on" ),

    // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    optSelected: opt.selected,

    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    getSetAttribute: div.className !== "t",

    // Tests for enctype support on a form(#6743)
    enctype: !!document.createElement("form").enctype,

    // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works
    html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

    // Will be defined later
    submitBubbles: true,
    changeBubbles: true,
    focusinBubbles: false,
    deleteExpando: true,
    noCloneEvent: true,
    inlineBlockNeedsLayout: false,
    shrinkWrapBlocks: false,
    reliableMarginRight: true
  };

  // Make sure checked status is properly cloned
  input.checked = true;
  support.noCloneChecked = input.cloneNode( true ).checked;

  // Make sure that the options inside disabled selects aren't marked as disabled
  // (WebKit marks them as disabled)
  select.disabled = true;
  support.optDisabled = !opt.disabled;

  // Test to see if it's possible to delete an expando from an element
  // Fails in Internet Explorer
  try {
    delete div.test;
  } catch( e ) {
    support.deleteExpando = false;
  }

  if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
    div.attachEvent( "onclick", function() {
      // Cloning a node shouldn't copy over any
      // bound event handlers (IE does this)
      support.noCloneEvent = false;
    });
    div.cloneNode( true ).fireEvent( "onclick" );
  }

  // Check if a radio maintains its value
  // after being appended to the DOM
  input = document.createElement("input");
  input.value = "t";
  input.setAttribute("type", "radio");
  support.radioValue = input.value === "t";

  input.setAttribute("checked", "checked");
  div.appendChild( input );
  fragment = document.createDocumentFragment();
  fragment.appendChild( div.lastChild );

  // WebKit doesn't clone checked state correctly in fragments
  support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

  // Check if a disconnected checkbox will retain its checked
  // value of true after appended to the DOM (IE6/7)
  support.appendChecked = input.checked;

  fragment.removeChild( input );
  fragment.appendChild( div );

  div.innerHTML = "";

  // Check if div with explicit width and no margin-right incorrectly
  // gets computed margin-right based on width of container. For more
  // info see bug #3333
  // Fails in WebKit before Feb 2011 nightlies
  // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
  if ( window.getComputedStyle ) {
    marginDiv = document.createElement( "div" );
    marginDiv.style.width = "0";
    marginDiv.style.marginRight = "0";
    div.style.width = "2px";
    div.appendChild( marginDiv );
    support.reliableMarginRight =
      ( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
  }

  // Technique from Juriy Zaytsev
  // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
  // We only care about the case where non-standard event systems
  // are used, namely in IE. Short-circuiting here helps us to
  // avoid an eval call (in setAttribute) which can cause CSP
  // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
  if ( div.attachEvent ) {
    for( i in {
      submit: 1,
      change: 1,
      focusin: 1
    }) {
      eventName = "on" + i;
      isSupported = ( eventName in div );
      if ( !isSupported ) {
        div.setAttribute( eventName, "return;" );
        isSupported = ( typeof div[ eventName ] === "function" );
      }
      support[ i + "Bubbles" ] = isSupported;
    }
  }

  fragment.removeChild( div );

  // Null elements to avoid leaks in IE
  fragment = select = opt = marginDiv = div = input = null;

  // Run tests that need a body at doc ready
  jQuery(function() {
    var container, outer, inner, table, td, offsetSupport,
      conMarginTop, ptlm, vb, style, html,
      body = document.getElementsByTagName("body")[0];

    if ( !body ) {
      // Return for frameset docs that don't have a body
      return;
    }

    conMarginTop = 1;
    ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
    vb = "visibility:hidden;border:0;";
    style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
    html = "<div " + style + "><div></div></div>" +
      "<table " + style + " cellpadding='0' cellspacing='0'>" +
      "<tr><td></td></tr></table>";

    container = document.createElement("div");
    container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
    body.insertBefore( container, body.firstChild );

    // Construct the test element
    div = document.createElement("div");
    container.appendChild( div );

    // Check if table cells still have offsetWidth/Height when they are set
    // to display:none and there are still other visible table cells in a
    // table row; if so, offsetWidth/Height are not reliable for use when
    // determining if an element has been hidden directly using
    // display:none (it is still safe to use offsets if a parent element is
    // hidden; don safety goggles and see bug #4512 for more information).
    // (only IE 8 fails this test)
    div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
    tds = div.getElementsByTagName( "td" );
    isSupported = ( tds[ 0 ].offsetHeight === 0 );

    tds[ 0 ].style.display = "";
    tds[ 1 ].style.display = "none";

    // Check if empty table cells still have offsetWidth/Height
    // (IE <= 8 fail this test)
    support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

    // Figure out if the W3C box model works as expected
    div.innerHTML = "";
    div.style.width = div.style.paddingLeft = "1px";
    jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

    if ( typeof div.style.zoom !== "undefined" ) {
      // Check if natively block-level elements act like inline-block
      // elements when setting their display to 'inline' and giving
      // them layout
      // (IE < 8 does this)
      div.style.display = "inline";
      div.style.zoom = 1;
      support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

      // Check if elements with layout shrink-wrap their children
      // (IE 6 does this)
      div.style.display = "";
      div.innerHTML = "<div style='width:4px;'></div>";
      support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
    }

    div.style.cssText = ptlm + vb;
    div.innerHTML = html;

    outer = div.firstChild;
    inner = outer.firstChild;
    td = outer.nextSibling.firstChild.firstChild;

    offsetSupport = {
      doesNotAddBorder: ( inner.offsetTop !== 5 ),
      doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
    };

    inner.style.position = "fixed";
    inner.style.top = "20px";

    // safari subtracts parent border width here which is 5px
    offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
    inner.style.position = inner.style.top = "";

    outer.style.overflow = "hidden";
    outer.style.position = "relative";

    offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
    offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

    body.removeChild( container );
    div  = container = null;

    jQuery.extend( support, offsetSupport );
  });

  return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
  rmultiDash = /([A-Z])/g;

jQuery.extend({
  cache: {},

  // Please use with caution
  uuid: 0,

  // Unique for each copy of jQuery on the page
  // Non-digits removed to match rinlinejQuery
  expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

  // The following elements throw uncatchable exceptions if you
  // attempt to add expando properties to them.
  noData: {
    "embed": true,
    // Ban all objects except for Flash (which handle expandos)
    "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
    "applet": true
  },

  hasData: function( elem ) {
    elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
    return !!elem && !isEmptyDataObject( elem );
  },

  data: function( elem, name, data, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
      return;
    }

    var privateCache, thisCache, ret,
      internalKey = jQuery.expando,
      getByName = typeof name === "string",

      // We have to handle DOM nodes and JS objects differently because IE6-7
      // can't GC object references properly across the DOM-JS boundary
      isNode = elem.nodeType,

      // Only DOM nodes need the global jQuery cache; JS object data is
      // attached directly to the object so GC can occur automatically
      cache = isNode ? jQuery.cache : elem,

      // Only defining an ID for JS objects if its cache already exists allows
      // the code to shortcut on the same path as a DOM node with no cache
      id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
      isEvents = name === "events";

    // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all
    if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
      return;
    }

    if ( !id ) {
      // Only DOM nodes need a new unique ID for each element since their data
      // ends up in the global cache
      if ( isNode ) {
        elem[ internalKey ] = id = ++jQuery.uuid;
      } else {
        id = internalKey;
      }
    }

    if ( !cache[ id ] ) {
      cache[ id ] = {};

      // Avoids exposing jQuery metadata on plain JS objects when the object
      // is serialized using JSON.stringify
      if ( !isNode ) {
        cache[ id ].toJSON = jQuery.noop;
      }
    }

    // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache
    if ( typeof name === "object" || typeof name === "function" ) {
      if ( pvt ) {
        cache[ id ] = jQuery.extend( cache[ id ], name );
      } else {
        cache[ id ].data = jQuery.extend( cache[ id ].data, name );
      }
    }

    privateCache = thisCache = cache[ id ];

    // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.
    if ( !pvt ) {
      if ( !thisCache.data ) {
        thisCache.data = {};
      }

      thisCache = thisCache.data;
    }

    if ( data !== undefined ) {
      thisCache[ jQuery.camelCase( name ) ] = data;
    }

    // Users should not attempt to inspect the internal events object using jQuery.data,
    // it is undocumented and subject to change. But does anyone listen? No.
    if ( isEvents && !thisCache[ name ] ) {
      return privateCache.events;
    }

    // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified
    if ( getByName ) {

      // First Try to find as-is property data
      ret = thisCache[ name ];

      // Test for null|undefined property data
      if ( ret == null ) {

        // Try to find the camelCased property
        ret = thisCache[ jQuery.camelCase( name ) ];
      }
    } else {
      ret = thisCache;
    }

    return ret;
  },

  removeData: function( elem, name, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
      return;
    }

    var thisCache, i, l,

      // Reference to internal data cache key
      internalKey = jQuery.expando,

      isNode = elem.nodeType,

      // See jQuery.data for more information
      cache = isNode ? jQuery.cache : elem,

      // See jQuery.data for more information
      id = isNode ? elem[ internalKey ] : internalKey;

    // If there is already no cache entry for this object, there is no
    // purpose in continuing
    if ( !cache[ id ] ) {
      return;
    }

    if ( name ) {

      thisCache = pvt ? cache[ id ] : cache[ id ].data;

      if ( thisCache ) {

        // Support array or space separated string names for data keys
        if ( !jQuery.isArray( name ) ) {

          // try the string as a key before any manipulation
          if ( name in thisCache ) {
            name = [ name ];
          } else {

            // split the camel cased version by spaces unless a key with the spaces exists
            name = jQuery.camelCase( name );
            if ( name in thisCache ) {
              name = [ name ];
            } else {
              name = name.split( " " );
            }
          }
        }

        for ( i = 0, l = name.length; i < l; i++ ) {
          delete thisCache[ name[i] ];
        }

        // If there is no data left in the cache, we want to continue
        // and let the cache object itself get destroyed
        if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
          return;
        }
      }
    }

    // See jQuery.data for more information
    if ( !pvt ) {
      delete cache[ id ].data;

      // Don't destroy the parent cache unless the internal data object
      // had been the only thing left in it
      if ( !isEmptyDataObject(cache[ id ]) ) {
        return;
      }
    }

    // Browsers that fail expando deletion also refuse to delete expandos on
    // the window, but it will allow it on all other JS objects; other browsers
    // don't care
    // Ensure that `cache` is not a window object #10080
    if ( jQuery.support.deleteExpando || !cache.setInterval ) {
      delete cache[ id ];
    } else {
      cache[ id ] = null;
    }

    // We destroyed the cache and need to eliminate the expando on the node to avoid
    // false lookups in the cache for entries that no longer exist
    if ( isNode ) {
      // IE does not allow us to delete expando properties from nodes,
      // nor does it have a removeAttribute function on Document nodes;
      // we must handle all of these cases
      if ( jQuery.support.deleteExpando ) {
        delete elem[ internalKey ];
      } else if ( elem.removeAttribute ) {
        elem.removeAttribute( internalKey );
      } else {
        elem[ internalKey ] = null;
      }
    }
  },

  // For internal use only.
  _data: function( elem, name, data ) {
    return jQuery.data( elem, name, data, true );
  },

  // A method for determining if a DOM node can handle the data expando
  acceptData: function( elem ) {
    if ( elem.nodeName ) {
      var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

      if ( match ) {
        return !(match === true || elem.getAttribute("classid") !== match);
      }
    }

    return true;
  }
});

jQuery.fn.extend({
  data: function( key, value ) {
    var parts, attr, name,
      data = null;

    if ( typeof key === "undefined" ) {
      if ( this.length ) {
        data = jQuery.data( this[0] );

        if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
          attr = this[0].attributes;
          for ( var i = 0, l = attr.length; i < l; i++ ) {
            name = attr[i].name;

            if ( name.indexOf( "data-" ) === 0 ) {
              name = jQuery.camelCase( name.substring(5) );

              dataAttr( this[0], name, data[ name ] );
            }
          }
          jQuery._data( this[0], "parsedAttrs", true );
        }
      }

      return data;

    } else if ( typeof key === "object" ) {
      return this.each(function() {
        jQuery.data( this, key );
      });
    }

    parts = key.split(".");
    parts[1] = parts[1] ? "." + parts[1] : "";

    if ( value === undefined ) {
      data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

      // Try to fetch any internally stored data first
      if ( data === undefined && this.length ) {
        data = jQuery.data( this[0], key );
        data = dataAttr( this[0], key, data );
      }

      return data === undefined && parts[1] ?
        this.data( parts[0] ) :
        data;

    } else {
      return this.each(function() {
        var self = jQuery( this ),
          args = [ parts[0], value ];

        self.triggerHandler( "setData" + parts[1] + "!", args );
        jQuery.data( this, key, value );
        self.triggerHandler( "changeData" + parts[1] + "!", args );
      });
    }
  },

  removeData: function( key ) {
    return this.each(function() {
      jQuery.removeData( this, key );
    });
  }
});

function dataAttr( elem, key, data ) {
  // If nothing was found internally, try to fetch any
  // data from the HTML5 data-* attribute
  if ( data === undefined && elem.nodeType === 1 ) {

    var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

    data = elem.getAttribute( name );

    if ( typeof data === "string" ) {
      try {
        data = data === "true" ? true :
        data === "false" ? false :
        data === "null" ? null :
        jQuery.isNumeric( data ) ? parseFloat( data ) :
          rbrace.test( data ) ? jQuery.parseJSON( data ) :
          data;
      } catch( e ) {}

      // Make sure we set the data so it isn't changed later
      jQuery.data( elem, key, data );

    } else {
      data = undefined;
    }
  }

  return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
  for ( var name in obj ) {

    // if the public data object is empty, the private is still empty
    if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
      continue;
    }
    if ( name !== "toJSON" ) {
      return false;
    }
  }

  return true;
}




function handleQueueMarkDefer( elem, type, src ) {
  var deferDataKey = type + "defer",
    queueDataKey = type + "queue",
    markDataKey = type + "mark",
    defer = jQuery._data( elem, deferDataKey );
  if ( defer &&
    ( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
    ( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
    // Give room for hard-coded callbacks to fire first
    // and eventually mark/queue something else on the element
    setTimeout( function() {
      if ( !jQuery._data( elem, queueDataKey ) &&
        !jQuery._data( elem, markDataKey ) ) {
        jQuery.removeData( elem, deferDataKey, true );
        defer.fire();
      }
    }, 0 );
  }
}

jQuery.extend({

  _mark: function( elem, type ) {
    if ( elem ) {
      type = ( type || "fx" ) + "mark";
      jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
    }
  },

  _unmark: function( force, elem, type ) {
    if ( force !== true ) {
      type = elem;
      elem = force;
      force = false;
    }
    if ( elem ) {
      type = type || "fx";
      var key = type + "mark",
        count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
      if ( count ) {
        jQuery._data( elem, key, count );
      } else {
        jQuery.removeData( elem, key, true );
        handleQueueMarkDefer( elem, type, "mark" );
      }
    }
  },

  queue: function( elem, type, data ) {
    var q;
    if ( elem ) {
      type = ( type || "fx" ) + "queue";
      q = jQuery._data( elem, type );

      // Speed up dequeue by getting out quickly if this is just a lookup
      if ( data ) {
        if ( !q || jQuery.isArray(data) ) {
          q = jQuery._data( elem, type, jQuery.makeArray(data) );
        } else {
          q.push( data );
        }
      }
      return q || [];
    }
  },

  dequeue: function( elem, type ) {
    type = type || "fx";

    var queue = jQuery.queue( elem, type ),
      fn = queue.shift(),
      hooks = {};

    // If the fx queue is dequeued, always remove the progress sentinel
    if ( fn === "inprogress" ) {
      fn = queue.shift();
    }

    if ( fn ) {
      // Add a progress sentinel to prevent the fx queue from being
      // automatically dequeued
      if ( type === "fx" ) {
        queue.unshift( "inprogress" );
      }

      jQuery._data( elem, type + ".run", hooks );
      fn.call( elem, function() {
        jQuery.dequeue( elem, type );
      }, hooks );
    }

    if ( !queue.length ) {
      jQuery.removeData( elem, type + "queue " + type + ".run", true );
      handleQueueMarkDefer( elem, type, "queue" );
    }
  }
});

jQuery.fn.extend({
  queue: function( type, data ) {
    if ( typeof type !== "string" ) {
      data = type;
      type = "fx";
    }

    if ( data === undefined ) {
      return jQuery.queue( this[0], type );
    }
    return this.each(function() {
      var queue = jQuery.queue( this, type, data );

      if ( type === "fx" && queue[0] !== "inprogress" ) {
        jQuery.dequeue( this, type );
      }
    });
  },
  dequeue: function( type ) {
    return this.each(function() {
      jQuery.dequeue( this, type );
    });
  },
  // Based off of the plugin by Clint Helfers, with permission.
  // http://blindsignals.com/index.php/2009/07/jquery-delay/
  delay: function( time, type ) {
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    type = type || "fx";

    return this.queue( type, function( next, hooks ) {
      var timeout = setTimeout( next, time );
      hooks.stop = function() {
        clearTimeout( timeout );
      };
    });
  },
  clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
  },
  // Get a promise resolved when queues of a certain type
  // are emptied (fx is the type by default)
  promise: function( type, object ) {
    if ( typeof type !== "string" ) {
      object = type;
      type = undefined;
    }
    type = type || "fx";
    var defer = jQuery.Deferred(),
      elements = this,
      i = elements.length,
      count = 1,
      deferDataKey = type + "defer",
      queueDataKey = type + "queue",
      markDataKey = type + "mark",
      tmp;
    function resolve() {
      if ( !( --count ) ) {
        defer.resolveWith( elements, [ elements ] );
      }
    }
    while( i-- ) {
      if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
          ( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
            jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
          jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
        count++;
        tmp.add( resolve );
      }
    }
    resolve();
    return defer.promise();
  }
});




var rclass = /[\n\t\r]/g,
  rspace = /\s+/,
  rreturn = /\r/g,
  rtype = /^(?:button|input)$/i,
  rfocusable = /^(?:button|input|object|select|textarea)$/i,
  rclickable = /^a(?:rea)?$/i,
  rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
  getSetAttribute = jQuery.support.getSetAttribute,
  nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
  attr: function( name, value ) {
    return jQuery.access( this, name, value, true, jQuery.attr );
  },

  removeAttr: function( name ) {
    return this.each(function() {
      jQuery.removeAttr( this, name );
    });
  },

  prop: function( name, value ) {
    return jQuery.access( this, name, value, true, jQuery.prop );
  },

  removeProp: function( name ) {
    name = jQuery.propFix[ name ] || name;
    return this.each(function() {
      // try/catch handles cases where IE balks (such as removing a property on window)
      try {
        this[ name ] = undefined;
        delete this[ name ];
      } catch( e ) {}
    });
  },

  addClass: function( value ) {
    var classNames, i, l, elem,
      setClass, c, cl;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).addClass( value.call(this, j, this.className) );
      });
    }

    if ( value && typeof value === "string" ) {
      classNames = value.split( rspace );

      for ( i = 0, l = this.length; i < l; i++ ) {
        elem = this[ i ];

        if ( elem.nodeType === 1 ) {
          if ( !elem.className && classNames.length === 1 ) {
            elem.className = value;

          } else {
            setClass = " " + elem.className + " ";

            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
              if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
                setClass += classNames[ c ] + " ";
              }
            }
            elem.className = jQuery.trim( setClass );
          }
        }
      }
    }

    return this;
  },

  removeClass: function( value ) {
    var classNames, i, l, elem, className, c, cl;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).removeClass( value.call(this, j, this.className) );
      });
    }

    if ( (value && typeof value === "string") || value === undefined ) {
      classNames = ( value || "" ).split( rspace );

      for ( i = 0, l = this.length; i < l; i++ ) {
        elem = this[ i ];

        if ( elem.nodeType === 1 && elem.className ) {
          if ( value ) {
            className = (" " + elem.className + " ").replace( rclass, " " );
            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
              className = className.replace(" " + classNames[ c ] + " ", " ");
            }
            elem.className = jQuery.trim( className );

          } else {
            elem.className = "";
          }
        }
      }
    }

    return this;
  },

  toggleClass: function( value, stateVal ) {
    var type = typeof value,
      isBool = typeof stateVal === "boolean";

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( i ) {
        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
      });
    }

    return this.each(function() {
      if ( type === "string" ) {
        // toggle individual class names
        var className,
          i = 0,
          self = jQuery( this ),
          state = stateVal,
          classNames = value.split( rspace );

        while ( (className = classNames[ i++ ]) ) {
          // check each className given, space seperated list
          state = isBool ? state : !self.hasClass( className );
          self[ state ? "addClass" : "removeClass" ]( className );
        }

      } else if ( type === "undefined" || type === "boolean" ) {
        if ( this.className ) {
          // store className if set
          jQuery._data( this, "__className__", this.className );
        }

        // toggle whole className
        this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
      }
    });
  },

  hasClass: function( selector ) {
    var className = " " + selector + " ",
      i = 0,
      l = this.length;
    for ( ; i < l; i++ ) {
      if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
        return true;
      }
    }

    return false;
  },

  val: function( value ) {
    var hooks, ret, isFunction,
      elem = this[0];

    if ( !arguments.length ) {
      if ( elem ) {
        hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

        if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
          return ret;
        }

        ret = elem.value;

        return typeof ret === "string" ?
          // handle most common string cases
          ret.replace(rreturn, "") :
          // handle cases where value is null/undef or number
          ret == null ? "" : ret;
      }

      return;
    }

    isFunction = jQuery.isFunction( value );

    return this.each(function( i ) {
      var self = jQuery(this), val;

      if ( this.nodeType !== 1 ) {
        return;
      }

      if ( isFunction ) {
        val = value.call( this, i, self.val() );
      } else {
        val = value;
      }

      // Treat null/undefined as ""; convert numbers to string
      if ( val == null ) {
        val = "";
      } else if ( typeof val === "number" ) {
        val += "";
      } else if ( jQuery.isArray( val ) ) {
        val = jQuery.map(val, function ( value ) {
          return value == null ? "" : value + "";
        });
      }

      hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

      // If set returns undefined, fall back to normal setting
      if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
        this.value = val;
      }
    });
  }
});

jQuery.extend({
  valHooks: {
    option: {
      get: function( elem ) {
        // attributes.value is undefined in Blackberry 4.7 but
        // uses .value. See #6932
        var val = elem.attributes.value;
        return !val || val.specified ? elem.value : elem.text;
      }
    },
    select: {
      get: function( elem ) {
        var value, i, max, option,
          index = elem.selectedIndex,
          values = [],
          options = elem.options,
          one = elem.type === "select-one";

        // Nothing was selected
        if ( index < 0 ) {
          return null;
        }

        // Loop through all the selected options
        i = one ? index : 0;
        max = one ? index + 1 : options.length;
        for ( ; i < max; i++ ) {
          option = options[ i ];

          // Don't return options that are disabled or in a disabled optgroup
          if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
              (!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

            // Get the specific value for the option
            value = jQuery( option ).val();

            // We don't need an array for one selects
            if ( one ) {
              return value;
            }

            // Multi-Selects return an array
            values.push( value );
          }
        }

        // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
        if ( one && !values.length && options.length ) {
          return jQuery( options[ index ] ).val();
        }

        return values;
      },

      set: function( elem, value ) {
        var values = jQuery.makeArray( value );

        jQuery(elem).find("option").each(function() {
          this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
        });

        if ( !values.length ) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  },

  attrFn: {
    val: true,
    css: true,
    html: true,
    text: true,
    data: true,
    width: true,
    height: true,
    offset: true
  },

  attr: function( elem, name, value, pass ) {
    var ret, hooks, notxml,
      nType = elem.nodeType;

    // don't get/set attributes on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    if ( pass && name in jQuery.attrFn ) {
      return jQuery( elem )[ name ]( value );
    }

    // Fallback to prop when attributes are not supported
    if ( typeof elem.getAttribute === "undefined" ) {
      return jQuery.prop( elem, name, value );
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    // All attributes are lowercase
    // Grab necessary hook if one is defined
    if ( notxml ) {
      name = name.toLowerCase();
      hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
    }

    if ( value !== undefined ) {

      if ( value === null ) {
        jQuery.removeAttr( elem, name );
        return;

      } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
        return ret;

      } else {
        elem.setAttribute( name, "" + value );
        return value;
      }

    } else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
      return ret;

    } else {

      ret = elem.getAttribute( name );

      // Non-existent attributes return null, we normalize to undefined
      return ret === null ?
        undefined :
        ret;
    }
  },

  removeAttr: function( elem, value ) {
    var propName, attrNames, name, l,
      i = 0;

    if ( value && elem.nodeType === 1 ) {
      attrNames = value.toLowerCase().split( rspace );
      l = attrNames.length;

      for ( ; i < l; i++ ) {
        name = attrNames[ i ];

        if ( name ) {
          propName = jQuery.propFix[ name ] || name;

          // See #9699 for explanation of this approach (setting first, then removal)
          jQuery.attr( elem, name, "" );
          elem.removeAttribute( getSetAttribute ? name : propName );

          // Set corresponding property to false for boolean attributes
          if ( rboolean.test( name ) && propName in elem ) {
            elem[ propName ] = false;
          }
        }
      }
    }
  },

  attrHooks: {
    type: {
      set: function( elem, value ) {
        // We can't allow the type property to be changed (since it causes problems in IE)
        if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
          jQuery.error( "type property can't be changed" );
        } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
          // Setting the type on a radio button after the value resets the value in IE6-9
          // Reset value to it's default in case type is set after value
          // This is for element creation
          var val = elem.value;
          elem.setAttribute( "type", value );
          if ( val ) {
            elem.value = val;
          }
          return value;
        }
      }
    },
    // Use the value property for back compat
    // Use the nodeHook for button elements in IE6/7 (#1954)
    value: {
      get: function( elem, name ) {
        if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
          return nodeHook.get( elem, name );
        }
        return name in elem ?
          elem.value :
          null;
      },
      set: function( elem, value, name ) {
        if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
          return nodeHook.set( elem, value, name );
        }
        // Does not return so that setAttribute is also used
        elem.value = value;
      }
    }
  },

  propFix: {
    tabindex: "tabIndex",
    readonly: "readOnly",
    "for": "htmlFor",
    "class": "className",
    maxlength: "maxLength",
    cellspacing: "cellSpacing",
    cellpadding: "cellPadding",
    rowspan: "rowSpan",
    colspan: "colSpan",
    usemap: "useMap",
    frameborder: "frameBorder",
    contenteditable: "contentEditable"
  },

  prop: function( elem, name, value ) {
    var ret, hooks, notxml,
      nType = elem.nodeType;

    // don't get/set properties on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    if ( notxml ) {
      // Fix name and attach hooks
      name = jQuery.propFix[ name ] || name;
      hooks = jQuery.propHooks[ name ];
    }

    if ( value !== undefined ) {
      if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
        return ret;

      } else {
        return ( elem[ name ] = value );
      }

    } else {
      if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
        return ret;

      } else {
        return elem[ name ];
      }
    }
  },

  propHooks: {
    tabIndex: {
      get: function( elem ) {
        // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
        // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
        var attributeNode = elem.getAttributeNode("tabindex");

        return attributeNode && attributeNode.specified ?
          parseInt( attributeNode.value, 10 ) :
          rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
            0 :
            undefined;
      }
    }
  }
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
  get: function( elem, name ) {
    // Align boolean attributes with corresponding properties
    // Fall back to attribute presence where some booleans are not supported
    var attrNode,
      property = jQuery.prop( elem, name );
    return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
      name.toLowerCase() :
      undefined;
  },
  set: function( elem, value, name ) {
    var propName;
    if ( value === false ) {
      // Remove boolean attributes when set to false
      jQuery.removeAttr( elem, name );
    } else {
      // value is true since we know at this point it's type boolean and not false
      // Set boolean attributes to the same name and set the DOM property
      propName = jQuery.propFix[ name ] || name;
      if ( propName in elem ) {
        // Only set the IDL specifically if it already exists on the element
        elem[ propName ] = true;
      }

      elem.setAttribute( name, name.toLowerCase() );
    }
    return name;
  }
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

  fixSpecified = {
    name: true,
    id: true
  };

  // Use this for any attribute in IE6/7
  // This fixes almost every IE6/7 issue
  nodeHook = jQuery.valHooks.button = {
    get: function( elem, name ) {
      var ret;
      ret = elem.getAttributeNode( name );
      return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
        ret.nodeValue :
        undefined;
    },
    set: function( elem, value, name ) {
      // Set the existing or create a new attribute node
      var ret = elem.getAttributeNode( name );
      if ( !ret ) {
        ret = document.createAttribute( name );
        elem.setAttributeNode( ret );
      }
      return ( ret.nodeValue = value + "" );
    }
  };

  // Apply the nodeHook to tabindex
  jQuery.attrHooks.tabindex.set = nodeHook.set;

  // Set width and height to auto instead of 0 on empty string( Bug #8150 )
  // This is for removals
  jQuery.each([ "width", "height" ], function( i, name ) {
    jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
      set: function( elem, value ) {
        if ( value === "" ) {
          elem.setAttribute( name, "auto" );
          return value;
        }
      }
    });
  });

  // Set contenteditable to false on removals(#10429)
  // Setting to empty string throws an error as an invalid value
  jQuery.attrHooks.contenteditable = {
    get: nodeHook.get,
    set: function( elem, value, name ) {
      if ( value === "" ) {
        value = "false";
      }
      nodeHook.set( elem, value, name );
    }
  };
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
  jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
    jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
      get: function( elem ) {
        var ret = elem.getAttribute( name, 2 );
        return ret === null ? undefined : ret;
      }
    });
  });
}

if ( !jQuery.support.style ) {
  jQuery.attrHooks.style = {
    get: function( elem ) {
      // Return undefined in the case of empty string
      // Normalize to lowercase since IE uppercases css property names
      return elem.style.cssText.toLowerCase() || undefined;
    },
    set: function( elem, value ) {
      return ( elem.style.cssText = "" + value );
    }
  };
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
  jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
    get: function( elem ) {
      var parent = elem.parentNode;

      if ( parent ) {
        parent.selectedIndex;

        // Make sure that it also works with optgroups, see #5701
        if ( parent.parentNode ) {
          parent.parentNode.selectedIndex;
        }
      }
      return null;
    }
  });
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
  jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
  jQuery.each([ "radio", "checkbox" ], function() {
    jQuery.valHooks[ this ] = {
      get: function( elem ) {
        // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
        return elem.getAttribute("value") === null ? "on" : elem.value;
      }
    };
  });
}
jQuery.each([ "radio", "checkbox" ], function() {
  jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
    set: function( elem, value ) {
      if ( jQuery.isArray( value ) ) {
        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
      }
    }
  });
});




var rformElems = /^(?:textarea|input|select)$/i,
  rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
  rhoverHack = /\bhover(\.\S+)?\b/,
  rkeyEvent = /^key/,
  rmouseEvent = /^(?:mouse|contextmenu)|click/,
  rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
  quickParse = function( selector ) {
    var quick = rquickIs.exec( selector );
    if ( quick ) {
      //   0  1    2   3
      // [ _, tag, id, class ]
      quick[1] = ( quick[1] || "" ).toLowerCase();
      quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
    }
    return quick;
  },
  quickIs = function( elem, m ) {
    var attrs = elem.attributes || {};
    return (
      (!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
      (!m[2] || (attrs.id || {}).value === m[2]) &&
      (!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
    );
  },
  hoverHack = function( events ) {
    return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
  };

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

  add: function( elem, types, handler, data, selector ) {

    var elemData, eventHandle, events,
      t, tns, type, namespaces, handleObj,
      handleObjIn, quick, handlers, special;

    // Don't attach events to noData or text/comment nodes (allow plain objects tho)
    if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
      return;
    }

    // Caller can pass in an object of custom data in lieu of the handler
    if ( handler.handler ) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
    }

    // Make sure that the handler has a unique ID, used to find/remove it later
    if ( !handler.guid ) {
      handler.guid = jQuery.guid++;
    }

    // Init the element's event structure and main handler, if this is the first
    events = elemData.events;
    if ( !events ) {
      elemData.events = events = {};
    }
    eventHandle = elemData.handle;
    if ( !eventHandle ) {
      elemData.handle = eventHandle = function( e ) {
        // Discard the second event of a jQuery.event.trigger() and
        // when an event is called after a page has unloaded
        return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
          jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
          undefined;
      };
      // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
      eventHandle.elem = elem;
    }

    // Handle multiple events separated by a space
    // jQuery(...).bind("mouseover mouseout", fn);
    types = jQuery.trim( hoverHack(types) ).split( " " );
    for ( t = 0; t < types.length; t++ ) {

      tns = rtypenamespace.exec( types[t] ) || [];
      type = tns[1];
      namespaces = ( tns[2] || "" ).split( "." ).sort();

      // If event changes its type, use the special event handlers for the changed type
      special = jQuery.event.special[ type ] || {};

      // If selector defined, determine special event api type, otherwise given type
      type = ( selector ? special.delegateType : special.bindType ) || type;

      // Update special based on newly reset type
      special = jQuery.event.special[ type ] || {};

      // handleObj is passed to all event handlers
      handleObj = jQuery.extend({
        type: type,
        origType: tns[1],
        data: data,
        handler: handler,
        guid: handler.guid,
        selector: selector,
        quick: quickParse( selector ),
        namespace: namespaces.join(".")
      }, handleObjIn );

      // Init the event handler queue if we're the first
      handlers = events[ type ];
      if ( !handlers ) {
        handlers = events[ type ] = [];
        handlers.delegateCount = 0;

        // Only use addEventListener/attachEvent if the special events handler returns false
        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
          // Bind the global event handler to the element
          if ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, false );

          } else if ( elem.attachEvent ) {
            elem.attachEvent( "on" + type, eventHandle );
          }
        }
      }

      if ( special.add ) {
        special.add.call( elem, handleObj );

        if ( !handleObj.handler.guid ) {
          handleObj.handler.guid = handler.guid;
        }
      }

      // Add to the element's handler list, delegates in front
      if ( selector ) {
        handlers.splice( handlers.delegateCount++, 0, handleObj );
      } else {
        handlers.push( handleObj );
      }

      // Keep track of which events have ever been used, for event optimization
      jQuery.event.global[ type ] = true;
    }

    // Nullify elem to prevent memory leaks in IE
    elem = null;
  },

  global: {},

  // Detach an event or set of events from an element
  remove: function( elem, types, handler, selector, mappedTypes ) {

    var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
      t, tns, type, origType, namespaces, origCount,
      j, events, special, handle, eventType, handleObj;

    if ( !elemData || !(events = elemData.events) ) {
      return;
    }

    // Once for each type.namespace in types; type may be omitted
    types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
    for ( t = 0; t < types.length; t++ ) {
      tns = rtypenamespace.exec( types[t] ) || [];
      type = origType = tns[1];
      namespaces = tns[2];

      // Unbind all events (on this namespace, if provided) for the element
      if ( !type ) {
        for ( type in events ) {
          jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
        }
        continue;
      }

      special = jQuery.event.special[ type ] || {};
      type = ( selector? special.delegateType : special.bindType ) || type;
      eventType = events[ type ] || [];
      origCount = eventType.length;
      namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

      // Remove matching events
      for ( j = 0; j < eventType.length; j++ ) {
        handleObj = eventType[ j ];

        if ( ( mappedTypes || origType === handleObj.origType ) &&
           ( !handler || handler.guid === handleObj.guid ) &&
           ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
           ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
          eventType.splice( j--, 1 );

          if ( handleObj.selector ) {
            eventType.delegateCount--;
          }
          if ( special.remove ) {
            special.remove.call( elem, handleObj );
          }
        }
      }

      // Remove generic event handler if we removed something and no more handlers exist
      // (avoids potential for endless recursion during removal of special event handlers)
      if ( eventType.length === 0 && origCount !== eventType.length ) {
        if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
          jQuery.removeEvent( elem, type, elemData.handle );
        }

        delete events[ type ];
      }
    }

    // Remove the expando if it's no longer used
    if ( jQuery.isEmptyObject( events ) ) {
      handle = elemData.handle;
      if ( handle ) {
        handle.elem = null;
      }

      // removeData also checks for emptiness and clears the expando if empty
      // so use it instead of delete
      jQuery.removeData( elem, [ "events", "handle" ], true );
    }
  },

  // Events that are safe to short-circuit if no handlers are attached.
  // Native DOM events should not be added, they may have inline handlers.
  customEvent: {
    "getData": true,
    "setData": true,
    "changeData": true
  },

  trigger: function( event, data, elem, onlyHandlers ) {
    // Don't do events on text and comment nodes
    if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
      return;
    }

    // Event object or event type
    var type = event.type || event,
      namespaces = [],
      cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

    // focus/blur morphs to focusin/out; ensure we're not firing them right now
    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
      return;
    }

    if ( type.indexOf( "!" ) >= 0 ) {
      // Exclusive events trigger only for the exact event (no namespaces)
      type = type.slice(0, -1);
      exclusive = true;
    }

    if ( type.indexOf( "." ) >= 0 ) {
      // Namespaced trigger; create a regexp to match event type in handle()
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }

    if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
      // No jQuery handlers for this event type, and it can't have inline handlers
      return;
    }

    // Caller can pass in an Event, Object, or just an event type string
    event = typeof event === "object" ?
      // jQuery.Event object
      event[ jQuery.expando ] ? event :
      // Object literal
      new jQuery.Event( type, event ) :
      // Just the event type (string)
      new jQuery.Event( type );

    event.type = type;
    event.isTrigger = true;
    event.exclusive = exclusive;
    event.namespace = namespaces.join( "." );
    event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
    ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

    // Handle a global trigger
    if ( !elem ) {

      // TODO: Stop taunting the data cache; remove global events and always attach to document
      cache = jQuery.cache;
      for ( i in cache ) {
        if ( cache[ i ].events && cache[ i ].events[ type ] ) {
          jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
        }
      }
      return;
    }

    // Clean up the event in case it is being reused
    event.result = undefined;
    if ( !event.target ) {
      event.target = elem;
    }

    // Clone any incoming data and prepend the event, creating the handler arg list
    data = data != null ? jQuery.makeArray( data ) : [];
    data.unshift( event );

    // Allow special events to draw outside the lines
    special = jQuery.event.special[ type ] || {};
    if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
      return;
    }

    // Determine event propagation path in advance, per W3C events spec (#9951)
    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    eventPath = [[ elem, special.bindType || type ]];
    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

      bubbleType = special.delegateType || type;
      cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
      old = null;
      for ( ; cur; cur = cur.parentNode ) {
        eventPath.push([ cur, bubbleType ]);
        old = cur;
      }

      // Only add window if we got to document (e.g., not plain obj or detached DOM)
      if ( old && old === elem.ownerDocument ) {
        eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
      }
    }

    // Fire handlers on the event path
    for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

      cur = eventPath[i][0];
      event.type = eventPath[i][1];

      handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
      if ( handle ) {
        handle.apply( cur, data );
      }
      // Note that this is a bare JS function and not a jQuery handler
      handle = ontype && cur[ ontype ];
      if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
        event.preventDefault();
      }
    }
    event.type = type;

    // If nobody prevented the default action, do it now
    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

      if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
        !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

        // Call a native DOM method on the target with the same name name as the event.
        // Can't use an .isFunction() check here because IE6/7 fails that test.
        // Don't do default actions on window, that's where global variables be (#6170)
        // IE<9 dies on focus/blur to hidden element (#1486)
        if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

          // Don't re-trigger an onFOO event when we call its FOO() method
          old = elem[ ontype ];

          if ( old ) {
            elem[ ontype ] = null;
          }

          // Prevent re-triggering of the same event, since we already bubbled it above
          jQuery.event.triggered = type;
          elem[ type ]();
          jQuery.event.triggered = undefined;

          if ( old ) {
            elem[ ontype ] = old;
          }
        }
      }
    }

    return event.result;
  },

  dispatch: function( event ) {

    // Make a writable jQuery.Event from the native event object
    event = jQuery.event.fix( event || window.event );

    var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
      delegateCount = handlers.delegateCount,
      args = [].slice.call( arguments, 0 ),
      run_all = !event.exclusive && !event.namespace,
      handlerQueue = [],
      i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

    // Use the fix-ed jQuery.Event rather than the (read-only) native event
    args[0] = event;
    event.delegateTarget = this;

    // Determine handlers that should run if there are delegated events
    // Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
    if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {

      // Pregenerate a single jQuery object for reuse with .is()
      jqcur = jQuery(this);
      jqcur.context = this.ownerDocument || this;

      for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
        selMatch = {};
        matches = [];
        jqcur[0] = cur;
        for ( i = 0; i < delegateCount; i++ ) {
          handleObj = handlers[ i ];
          sel = handleObj.selector;

          if ( selMatch[ sel ] === undefined ) {
            selMatch[ sel ] = (
              handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
            );
          }
          if ( selMatch[ sel ] ) {
            matches.push( handleObj );
          }
        }
        if ( matches.length ) {
          handlerQueue.push({ elem: cur, matches: matches });
        }
      }
    }

    // Add the remaining (directly-bound) handlers
    if ( handlers.length > delegateCount ) {
      handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
    }

    // Run delegates first; they may want to stop propagation beneath us
    for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
      matched = handlerQueue[ i ];
      event.currentTarget = matched.elem;

      for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
        handleObj = matched.matches[ j ];

        // Triggered event must either 1) be non-exclusive and have no namespace, or
        // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
        if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

          event.data = handleObj.data;
          event.handleObj = handleObj;

          ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
              .apply( matched.elem, args );

          if ( ret !== undefined ) {
            event.result = ret;
            if ( ret === false ) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }

    return event.result;
  },

  // Includes some event props shared by KeyEvent and MouseEvent
  // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
  props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

  fixHooks: {},

  keyHooks: {
    props: "char charCode key keyCode".split(" "),
    filter: function( event, original ) {

      // Add which for key events
      if ( event.which == null ) {
        event.which = original.charCode != null ? original.charCode : original.keyCode;
      }

      return event;
    }
  },

  mouseHooks: {
    props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    filter: function( event, original ) {
      var eventDoc, doc, body,
        button = original.button,
        fromElement = original.fromElement;

      // Calculate pageX/Y if missing and clientX/Y available
      if ( event.pageX == null && original.clientX != null ) {
        eventDoc = event.target.ownerDocument || document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;

        event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
        event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
      }

      // Add relatedTarget, if necessary
      if ( !event.relatedTarget && fromElement ) {
        event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
      }

      // Add which for click: 1 === left; 2 === middle; 3 === right
      // Note: button is not normalized, so don't use it
      if ( !event.which && button !== undefined ) {
        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
      }

      return event;
    }
  },

  fix: function( event ) {
    if ( event[ jQuery.expando ] ) {
      return event;
    }

    // Create a writable copy of the event object and normalize some properties
    var i, prop,
      originalEvent = event,
      fixHook = jQuery.event.fixHooks[ event.type ] || {},
      copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

    event = jQuery.Event( originalEvent );

    for ( i = copy.length; i; ) {
      prop = copy[ --i ];
      event[ prop ] = originalEvent[ prop ];
    }

    // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
    if ( !event.target ) {
      event.target = originalEvent.srcElement || document;
    }

    // Target should not be a text node (#504, Safari)
    if ( event.target.nodeType === 3 ) {
      event.target = event.target.parentNode;
    }

    // For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
    if ( event.metaKey === undefined ) {
      event.metaKey = event.ctrlKey;
    }

    return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
  },

  special: {
    ready: {
      // Make sure the ready event is setup
      setup: jQuery.bindReady
    },

    load: {
      // Prevent triggered image.load events from bubbling to window.load
      noBubble: true
    },

    focus: {
      delegateType: "focusin"
    },
    blur: {
      delegateType: "focusout"
    },

    beforeunload: {
      setup: function( data, namespaces, eventHandle ) {
        // We only want to do this special case on windows
        if ( jQuery.isWindow( this ) ) {
          this.onbeforeunload = eventHandle;
        }
      },

      teardown: function( namespaces, eventHandle ) {
        if ( this.onbeforeunload === eventHandle ) {
          this.onbeforeunload = null;
        }
      }
    }
  },

  simulate: function( type, elem, event, bubble ) {
    // Piggyback on a donor event to simulate a different one.
    // Fake originalEvent to avoid donor's stopPropagation, but if the
    // simulated event prevents default then we do the same on the donor.
    var e = jQuery.extend(
      new jQuery.Event(),
      event,
      { type: type,
        isSimulated: true,
        originalEvent: {}
      }
    );
    if ( bubble ) {
      jQuery.event.trigger( e, null, elem );
    } else {
      jQuery.event.dispatch.call( elem, e );
    }
    if ( e.isDefaultPrevented() ) {
      event.preventDefault();
    }
  }
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
  function( elem, type, handle ) {
    if ( elem.removeEventListener ) {
      elem.removeEventListener( type, handle, false );
    }
  } :
  function( elem, type, handle ) {
    if ( elem.detachEvent ) {
      elem.detachEvent( "on" + type, handle );
    }
  };

jQuery.Event = function( src, props ) {
  // Allow instantiation without the 'new' keyword
  if ( !(this instanceof jQuery.Event) ) {
    return new jQuery.Event( src, props );
  }

  // Event object
  if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
      src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if ( props ) {
    jQuery.extend( this, props );
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || jQuery.now();

  // Mark it as fixed
  this[ jQuery.expando ] = true;
};

function returnFalse() {
  return false;
}
function returnTrue() {
  return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
  preventDefault: function() {
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }

    // if preventDefault exists run it on the original event
    if ( e.preventDefault ) {
      e.preventDefault();

    // otherwise set the returnValue property of the original event to false (IE)
    } else {
      e.returnValue = false;
    }
  },
  stopPropagation: function() {
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }
    // if stopPropagation exists run it on the original event
    if ( e.stopPropagation ) {
      e.stopPropagation();
    }
    // otherwise set the cancelBubble property of the original event to true (IE)
    e.cancelBubble = true;
  },
  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, function( orig, fix ) {
  jQuery.event.special[ orig ] = {
    delegateType: fix,
    bindType: fix,

    handle: function( event ) {
      var target = this,
        related = event.relatedTarget,
        handleObj = event.handleObj,
        selector = handleObj.selector,
        ret;

      // For mousenter/leave call the handler if related is outside the target.
      // NB: No relatedTarget if the mouse left/entered the browser window
      if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply( this, arguments );
        event.type = fix;
      }
      return ret;
    }
  };
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

  jQuery.event.special.submit = {
    setup: function() {
      // Only need this for delegated form submit events
      if ( jQuery.nodeName( this, "form" ) ) {
        return false;
      }

      // Lazy-add a submit handler when a descendant form may potentially be submitted
      jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
        // Node name check avoids a VML-related crash in IE (#9807)
        var elem = e.target,
          form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
        if ( form && !form._submit_attached ) {
          jQuery.event.add( form, "submit._submit", function( event ) {
            // If form was submitted by the user, bubble the event up the tree
            if ( this.parentNode && !event.isTrigger ) {
              jQuery.event.simulate( "submit", this.parentNode, event, true );
            }
          });
          form._submit_attached = true;
        }
      });
      // return undefined since we don't need an event listener
    },

    teardown: function() {
      // Only need this for delegated form submit events
      if ( jQuery.nodeName( this, "form" ) ) {
        return false;
      }

      // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
      jQuery.event.remove( this, "._submit" );
    }
  };
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

  jQuery.event.special.change = {

    setup: function() {

      if ( rformElems.test( this.nodeName ) ) {
        // IE doesn't fire change on a check/radio until blur; trigger it on click
        // after a propertychange. Eat the blur-change in special.change.handle.
        // This still fires onchange a second time for check/radio after blur.
        if ( this.type === "checkbox" || this.type === "radio" ) {
          jQuery.event.add( this, "propertychange._change", function( event ) {
            if ( event.originalEvent.propertyName === "checked" ) {
              this._just_changed = true;
            }
          });
          jQuery.event.add( this, "click._change", function( event ) {
            if ( this._just_changed && !event.isTrigger ) {
              this._just_changed = false;
              jQuery.event.simulate( "change", this, event, true );
            }
          });
        }
        return false;
      }
      // Delegated event; lazy-add a change handler on descendant inputs
      jQuery.event.add( this, "beforeactivate._change", function( e ) {
        var elem = e.target;

        if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
          jQuery.event.add( elem, "change._change", function( event ) {
            if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
              jQuery.event.simulate( "change", this.parentNode, event, true );
            }
          });
          elem._change_attached = true;
        }
      });
    },

    handle: function( event ) {
      var elem = event.target;

      // Swallow native change events from checkbox/radio, we already triggered them above
      if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
        return event.handleObj.handler.apply( this, arguments );
      }
    },

    teardown: function() {
      jQuery.event.remove( this, "._change" );

      return rformElems.test( this.nodeName );
    }
  };
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
  jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

    // Attach a single capturing handler while someone wants focusin/focusout
    var attaches = 0,
      handler = function( event ) {
        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
      };

    jQuery.event.special[ fix ] = {
      setup: function() {
        if ( attaches++ === 0 ) {
          document.addEventListener( orig, handler, true );
        }
      },
      teardown: function() {
        if ( --attaches === 0 ) {
          document.removeEventListener( orig, handler, true );
        }
      }
    };
  });
}

jQuery.fn.extend({

  on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
    var origFn, type;

    // Types can be a map of types/handlers
    if ( typeof types === "object" ) {
      // ( types-Object, selector, data )
      if ( typeof selector !== "string" ) {
        // ( types-Object, data )
        data = selector;
        selector = undefined;
      }
      for ( type in types ) {
        this.on( type, selector, data, types[ type ], one );
      }
      return this;
    }

    if ( data == null && fn == null ) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if ( fn == null ) {
      if ( typeof selector === "string" ) {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if ( fn === false ) {
      fn = returnFalse;
    } else if ( !fn ) {
      return this;
    }

    if ( one === 1 ) {
      origFn = fn;
      fn = function( event ) {
        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
      };
      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    }
    return this.each( function() {
      jQuery.event.add( this, types, fn, data, selector );
    });
  },
  one: function( types, selector, data, fn ) {
    return this.on.call( this, types, selector, data, fn, 1 );
  },
  off: function( types, selector, fn ) {
    if ( types && types.preventDefault && types.handleObj ) {
      // ( event )  dispatched jQuery.Event
      var handleObj = types.handleObj;
      jQuery( types.delegateTarget ).off(
        handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
        handleObj.selector,
        handleObj.handler
      );
      return this;
    }
    if ( typeof types === "object" ) {
      // ( types-object [, selector] )
      for ( var type in types ) {
        this.off( type, selector, types[ type ] );
      }
      return this;
    }
    if ( selector === false || typeof selector === "function" ) {
      // ( types [, fn] )
      fn = selector;
      selector = undefined;
    }
    if ( fn === false ) {
      fn = returnFalse;
    }
    return this.each(function() {
      jQuery.event.remove( this, types, fn, selector );
    });
  },

  bind: function( types, data, fn ) {
    return this.on( types, null, data, fn );
  },
  unbind: function( types, fn ) {
    return this.off( types, null, fn );
  },

  live: function( types, data, fn ) {
    jQuery( this.context ).on( types, this.selector, data, fn );
    return this;
  },
  die: function( types, fn ) {
    jQuery( this.context ).off( types, this.selector || "**", fn );
    return this;
  },

  delegate: function( selector, types, data, fn ) {
    return this.on( types, selector, data, fn );
  },
  undelegate: function( selector, types, fn ) {
    // ( namespace ) or ( selector, types [, fn] )
    return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
  },

  trigger: function( type, data ) {
    return this.each(function() {
      jQuery.event.trigger( type, data, this );
    });
  },
  triggerHandler: function( type, data ) {
    if ( this[0] ) {
      return jQuery.event.trigger( type, data, this[0], true );
    }
  },

  toggle: function( fn ) {
    // Save reference to arguments for access in closure
    var args = arguments,
      guid = fn.guid || jQuery.guid++,
      i = 0,
      toggler = function( event ) {
        // Figure out which function to execute
        var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
        jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

        // Make sure that clicks stop
        event.preventDefault();

        // and execute the function
        return args[ lastToggle ].apply( this, arguments ) || false;
      };

    // link all the functions, so any of them can unbind this click handler
    toggler.guid = guid;
    while ( i < args.length ) {
      args[ i++ ].guid = guid;
    }

    return this.click( toggler );
  },

  hover: function( fnOver, fnOut ) {
    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  }
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

  // Handle event binding
  jQuery.fn[ name ] = function( data, fn ) {
    if ( fn == null ) {
      fn = data;
      data = null;
    }

    return arguments.length > 0 ?
      this.on( name, null, data, fn ) :
      this.trigger( name );
  };

  if ( jQuery.attrFn ) {
    jQuery.attrFn[ name ] = true;
  }

  if ( rkeyEvent.test( name ) ) {
    jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
  }

  if ( rmouseEvent.test( name ) ) {
    jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
  }
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
  expando = "sizcache" + (Math.random() + '').replace('.', ''),
  done = 0,
  toString = Object.prototype.toString,
  hasDuplicate = false,
  baseHasDuplicate = true,
  rBackslash = /\\/g,
  rReturn = /\r\n/g,
  rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
  baseHasDuplicate = false;
  return 0;
});

var Sizzle = function( selector, context, results, seed ) {
  results = results || [];
  context = context || document;

  var origContext = context;

  if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
    return [];
  }

  if ( !selector || typeof selector !== "string" ) {
    return results;
  }

  var m, set, checkSet, extra, ret, cur, pop, i,
    prune = true,
    contextXML = Sizzle.isXML( context ),
    parts = [],
    soFar = selector;

  // Reset the position of the chunker regexp (start from head)
  do {
    chunker.exec( "" );
    m = chunker.exec( soFar );

    if ( m ) {
      soFar = m[3];

      parts.push( m[1] );

      if ( m[2] ) {
        extra = m[3];
        break;
      }
    }
  } while ( m );

  if ( parts.length > 1 && origPOS.exec( selector ) ) {

    if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
      set = posProcess( parts[0] + parts[1], context, seed );

    } else {
      set = Expr.relative[ parts[0] ] ?
        [ context ] :
        Sizzle( parts.shift(), context );

      while ( parts.length ) {
        selector = parts.shift();

        if ( Expr.relative[ selector ] ) {
          selector += parts.shift();
        }

        set = posProcess( selector, set, seed );
      }
    }

  } else {
    // Take a shortcut and set the context if the root selector is an ID
    // (but not if it'll be faster if the inner selector is an ID)
    if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
        Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

      ret = Sizzle.find( parts.shift(), context, contextXML );
      context = ret.expr ?
        Sizzle.filter( ret.expr, ret.set )[0] :
        ret.set[0];
    }

    if ( context ) {
      ret = seed ?
        { expr: parts.pop(), set: makeArray(seed) } :
        Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

      set = ret.expr ?
        Sizzle.filter( ret.expr, ret.set ) :
        ret.set;

      if ( parts.length > 0 ) {
        checkSet = makeArray( set );

      } else {
        prune = false;
      }

      while ( parts.length ) {
        cur = parts.pop();
        pop = cur;

        if ( !Expr.relative[ cur ] ) {
          cur = "";
        } else {
          pop = parts.pop();
        }

        if ( pop == null ) {
          pop = context;
        }

        Expr.relative[ cur ]( checkSet, pop, contextXML );
      }

    } else {
      checkSet = parts = [];
    }
  }

  if ( !checkSet ) {
    checkSet = set;
  }

  if ( !checkSet ) {
    Sizzle.error( cur || selector );
  }

  if ( toString.call(checkSet) === "[object Array]" ) {
    if ( !prune ) {
      results.push.apply( results, checkSet );

    } else if ( context && context.nodeType === 1 ) {
      for ( i = 0; checkSet[i] != null; i++ ) {
        if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
          results.push( set[i] );
        }
      }

    } else {
      for ( i = 0; checkSet[i] != null; i++ ) {
        if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
          results.push( set[i] );
        }
      }
    }

  } else {
    makeArray( checkSet, results );
  }

  if ( extra ) {
    Sizzle( extra, origContext, results, seed );
    Sizzle.uniqueSort( results );
  }

  return results;
};

Sizzle.uniqueSort = function( results ) {
  if ( sortOrder ) {
    hasDuplicate = baseHasDuplicate;
    results.sort( sortOrder );

    if ( hasDuplicate ) {
      for ( var i = 1; i < results.length; i++ ) {
        if ( results[i] === results[ i - 1 ] ) {
          results.splice( i--, 1 );
        }
      }
    }
  }

  return results;
};

Sizzle.matches = function( expr, set ) {
  return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
  return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
  var set, i, len, match, type, left;

  if ( !expr ) {
    return [];
  }

  for ( i = 0, len = Expr.order.length; i < len; i++ ) {
    type = Expr.order[i];

    if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
      left = match[1];
      match.splice( 1, 1 );

      if ( left.substr( left.length - 1 ) !== "\\" ) {
        match[1] = (match[1] || "").replace( rBackslash, "" );
        set = Expr.find[ type ]( match, context, isXML );

        if ( set != null ) {
          expr = expr.replace( Expr.match[ type ], "" );
          break;
        }
      }
    }
  }

  if ( !set ) {
    set = typeof context.getElementsByTagName !== "undefined" ?
      context.getElementsByTagName( "*" ) :
      [];
  }

  return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
  var match, anyFound,
    type, found, item, filter, left,
    i, pass,
    old = expr,
    result = [],
    curLoop = set,
    isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

  while ( expr && set.length ) {
    for ( type in Expr.filter ) {
      if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
        filter = Expr.filter[ type ];
        left = match[1];

        anyFound = false;

        match.splice(1,1);

        if ( left.substr( left.length - 1 ) === "\\" ) {
          continue;
        }

        if ( curLoop === result ) {
          result = [];
        }

        if ( Expr.preFilter[ type ] ) {
          match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

          if ( !match ) {
            anyFound = found = true;

          } else if ( match === true ) {
            continue;
          }
        }

        if ( match ) {
          for ( i = 0; (item = curLoop[i]) != null; i++ ) {
            if ( item ) {
              found = filter( item, match, i, curLoop );
              pass = not ^ found;

              if ( inplace && found != null ) {
                if ( pass ) {
                  anyFound = true;

                } else {
                  curLoop[i] = false;
                }

              } else if ( pass ) {
                result.push( item );
                anyFound = true;
              }
            }
          }
        }

        if ( found !== undefined ) {
          if ( !inplace ) {
            curLoop = result;
          }

          expr = expr.replace( Expr.match[ type ], "" );

          if ( !anyFound ) {
            return [];
          }

          break;
        }
      }
    }

    // Improper expression
    if ( expr === old ) {
      if ( anyFound == null ) {
        Sizzle.error( expr );

      } else {
        break;
      }
    }

    old = expr;
  }

  return curLoop;
};

Sizzle.error = function( msg ) {
  throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
    nodeType = elem.nodeType,
    ret = "";

  if ( nodeType ) {
    if ( nodeType === 1 || nodeType === 9 ) {
      // Use textContent || innerText for elements
      if ( typeof elem.textContent === 'string' ) {
        return elem.textContent;
      } else if ( typeof elem.innerText === 'string' ) {
        // Replace IE's carriage returns
        return elem.innerText.replace( rReturn, '' );
      } else {
        // Traverse it's children
        for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
          ret += getText( elem );
        }
      }
    } else if ( nodeType === 3 || nodeType === 4 ) {
      return elem.nodeValue;
    }
  } else {

    // If no nodeType, this is expected to be an array
    for ( i = 0; (node = elem[i]); i++ ) {
      // Do not traverse comment nodes
      if ( node.nodeType !== 8 ) {
        ret += getText( node );
      }
    }
  }
  return ret;
};

var Expr = Sizzle.selectors = {
  order: [ "ID", "NAME", "TAG" ],

  match: {
    ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
    CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
    NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
    ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
    TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
    CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
    POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
    PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
  },

  leftMatch: {},

  attrMap: {
    "class": "className",
    "for": "htmlFor"
  },

  attrHandle: {
    href: function( elem ) {
      return elem.getAttribute( "href" );
    },
    type: function( elem ) {
      return elem.getAttribute( "type" );
    }
  },

  relative: {
    "+": function(checkSet, part){
      var isPartStr = typeof part === "string",
        isTag = isPartStr && !rNonWord.test( part ),
        isPartStrNotTag = isPartStr && !isTag;

      if ( isTag ) {
        part = part.toLowerCase();
      }

      for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
        if ( (elem = checkSet[i]) ) {
          while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

          checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
            elem || false :
            elem === part;
        }
      }

      if ( isPartStrNotTag ) {
        Sizzle.filter( part, checkSet, true );
      }
    },

    ">": function( checkSet, part ) {
      var elem,
        isPartStr = typeof part === "string",
        i = 0,
        l = checkSet.length;

      if ( isPartStr && !rNonWord.test( part ) ) {
        part = part.toLowerCase();

        for ( ; i < l; i++ ) {
          elem = checkSet[i];

          if ( elem ) {
            var parent = elem.parentNode;
            checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
          }
        }

      } else {
        for ( ; i < l; i++ ) {
          elem = checkSet[i];

          if ( elem ) {
            checkSet[i] = isPartStr ?
              elem.parentNode :
              elem.parentNode === part;
          }
        }

        if ( isPartStr ) {
          Sizzle.filter( part, checkSet, true );
        }
      }
    },

    "": function(checkSet, part, isXML){
      var nodeCheck,
        doneName = done++,
        checkFn = dirCheck;

      if ( typeof part === "string" && !rNonWord.test( part ) ) {
        part = part.toLowerCase();
        nodeCheck = part;
        checkFn = dirNodeCheck;
      }

      checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
    },

    "~": function( checkSet, part, isXML ) {
      var nodeCheck,
        doneName = done++,
        checkFn = dirCheck;

      if ( typeof part === "string" && !rNonWord.test( part ) ) {
        part = part.toLowerCase();
        nodeCheck = part;
        checkFn = dirNodeCheck;
      }

      checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
    }
  },

  find: {
    ID: function( match, context, isXML ) {
      if ( typeof context.getElementById !== "undefined" && !isXML ) {
        var m = context.getElementById(match[1]);
        // Check parentNode to catch when Blackberry 4.6 returns
        // nodes that are no longer in the document #6963
        return m && m.parentNode ? [m] : [];
      }
    },

    NAME: function( match, context ) {
      if ( typeof context.getElementsByName !== "undefined" ) {
        var ret = [],
          results = context.getElementsByName( match[1] );

        for ( var i = 0, l = results.length; i < l; i++ ) {
          if ( results[i].getAttribute("name") === match[1] ) {
            ret.push( results[i] );
          }
        }

        return ret.length === 0 ? null : ret;
      }
    },

    TAG: function( match, context ) {
      if ( typeof context.getElementsByTagName !== "undefined" ) {
        return context.getElementsByTagName( match[1] );
      }
    }
  },
  preFilter: {
    CLASS: function( match, curLoop, inplace, result, not, isXML ) {
      match = " " + match[1].replace( rBackslash, "" ) + " ";

      if ( isXML ) {
        return match;
      }

      for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
        if ( elem ) {
          if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
            if ( !inplace ) {
              result.push( elem );
            }

          } else if ( inplace ) {
            curLoop[i] = false;
          }
        }
      }

      return false;
    },

    ID: function( match ) {
      return match[1].replace( rBackslash, "" );
    },

    TAG: function( match, curLoop ) {
      return match[1].replace( rBackslash, "" ).toLowerCase();
    },

    CHILD: function( match ) {
      if ( match[1] === "nth" ) {
        if ( !match[2] ) {
          Sizzle.error( match[0] );
        }

        match[2] = match[2].replace(/^\+|\s*/g, '');

        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
        var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
          match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
          !/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

        // calculate the numbers (first)n+(last) including if they are negative
        match[2] = (test[1] + (test[2] || 1)) - 0;
        match[3] = test[3] - 0;
      }
      else if ( match[2] ) {
        Sizzle.error( match[0] );
      }

      // TODO: Move to normal caching system
      match[0] = done++;

      return match;
    },

    ATTR: function( match, curLoop, inplace, result, not, isXML ) {
      var name = match[1] = match[1].replace( rBackslash, "" );

      if ( !isXML && Expr.attrMap[name] ) {
        match[1] = Expr.attrMap[name];
      }

      // Handle if an un-quoted value was used
      match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

      if ( match[2] === "~=" ) {
        match[4] = " " + match[4] + " ";
      }

      return match;
    },

    PSEUDO: function( match, curLoop, inplace, result, not ) {
      if ( match[1] === "not" ) {
        // If we're dealing with a complex expression, or a simple one
        if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
          match[3] = Sizzle(match[3], null, null, curLoop);

        } else {
          var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

          if ( !inplace ) {
            result.push.apply( result, ret );
          }

          return false;
        }

      } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
        return true;
      }

      return match;
    },

    POS: function( match ) {
      match.unshift( true );

      return match;
    }
  },

  filters: {
    enabled: function( elem ) {
      return elem.disabled === false && elem.type !== "hidden";
    },

    disabled: function( elem ) {
      return elem.disabled === true;
    },

    checked: function( elem ) {
      return elem.checked === true;
    },

    selected: function( elem ) {
      // Accessing this property makes selected-by-default
      // options in Safari work properly
      if ( elem.parentNode ) {
        elem.parentNode.selectedIndex;
      }

      return elem.selected === true;
    },

    parent: function( elem ) {
      return !!elem.firstChild;
    },

    empty: function( elem ) {
      return !elem.firstChild;
    },

    has: function( elem, i, match ) {
      return !!Sizzle( match[3], elem ).length;
    },

    header: function( elem ) {
      return (/h\d/i).test( elem.nodeName );
    },

    text: function( elem ) {
      var attr = elem.getAttribute( "type" ), type = elem.type;
      // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
      // use getAttribute instead to test this case
      return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
    },

    radio: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
    },

    checkbox: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
    },

    file: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
    },

    password: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
    },

    submit: function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && "submit" === elem.type;
    },

    image: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
    },

    reset: function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && "reset" === elem.type;
    },

    button: function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && "button" === elem.type || name === "button";
    },

    input: function( elem ) {
      return (/input|select|textarea|button/i).test( elem.nodeName );
    },

    focus: function( elem ) {
      return elem === elem.ownerDocument.activeElement;
    }
  },
  setFilters: {
    first: function( elem, i ) {
      return i === 0;
    },

    last: function( elem, i, match, array ) {
      return i === array.length - 1;
    },

    even: function( elem, i ) {
      return i % 2 === 0;
    },

    odd: function( elem, i ) {
      return i % 2 === 1;
    },

    lt: function( elem, i, match ) {
      return i < match[3] - 0;
    },

    gt: function( elem, i, match ) {
      return i > match[3] - 0;
    },

    nth: function( elem, i, match ) {
      return match[3] - 0 === i;
    },

    eq: function( elem, i, match ) {
      return match[3] - 0 === i;
    }
  },
  filter: {
    PSEUDO: function( elem, match, i, array ) {
      var name = match[1],
        filter = Expr.filters[ name ];

      if ( filter ) {
        return filter( elem, i, match, array );

      } else if ( name === "contains" ) {
        return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

      } else if ( name === "not" ) {
        var not = match[3];

        for ( var j = 0, l = not.length; j < l; j++ ) {
          if ( not[j] === elem ) {
            return false;
          }
        }

        return true;

      } else {
        Sizzle.error( name );
      }
    },

    CHILD: function( elem, match ) {
      var first, last,
        doneName, parent, cache,
        count, diff,
        type = match[1],
        node = elem;

      switch ( type ) {
        case "only":
        case "first":
          while ( (node = node.previousSibling) )  {
            if ( node.nodeType === 1 ) {
              return false;
            }
          }

          if ( type === "first" ) {
            return true;
          }

          node = elem;

        case "last":
          while ( (node = node.nextSibling) )  {
            if ( node.nodeType === 1 ) {
              return false;
            }
          }

          return true;

        case "nth":
          first = match[2];
          last = match[3];

          if ( first === 1 && last === 0 ) {
            return true;
          }

          doneName = match[0];
          parent = elem.parentNode;

          if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
            count = 0;

            for ( node = parent.firstChild; node; node = node.nextSibling ) {
              if ( node.nodeType === 1 ) {
                node.nodeIndex = ++count;
              }
            }

            parent[ expando ] = doneName;
          }

          diff = elem.nodeIndex - last;

          if ( first === 0 ) {
            return diff === 0;

          } else {
            return ( diff % first === 0 && diff / first >= 0 );
          }
      }
    },

    ID: function( elem, match ) {
      return elem.nodeType === 1 && elem.getAttribute("id") === match;
    },

    TAG: function( elem, match ) {
      return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
    },

    CLASS: function( elem, match ) {
      return (" " + (elem.className || elem.getAttribute("class")) + " ")
        .indexOf( match ) > -1;
    },

    ATTR: function( elem, match ) {
      var name = match[1],
        result = Sizzle.attr ?
          Sizzle.attr( elem, name ) :
          Expr.attrHandle[ name ] ?
          Expr.attrHandle[ name ]( elem ) :
          elem[ name ] != null ?
            elem[ name ] :
            elem.getAttribute( name ),
        value = result + "",
        type = match[2],
        check = match[4];

      return result == null ?
        type === "!=" :
        !type && Sizzle.attr ?
        result != null :
        type === "=" ?
        value === check :
        type === "*=" ?
        value.indexOf(check) >= 0 :
        type === "~=" ?
        (" " + value + " ").indexOf(check) >= 0 :
        !check ?
        value && result !== false :
        type === "!=" ?
        value !== check :
        type === "^=" ?
        value.indexOf(check) === 0 :
        type === "$=" ?
        value.substr(value.length - check.length) === check :
        type === "|=" ?
        value === check || value.substr(0, check.length + 1) === check + "-" :
        false;
    },

    POS: function( elem, match, i, array ) {
      var name = match[2],
        filter = Expr.setFilters[ name ];

      if ( filter ) {
        return filter( elem, i, match, array );
      }
    }
  }
};

var origPOS = Expr.match.POS,
  fescape = function(all, num){
    return "\\" + (num - 0 + 1);
  };

for ( var type in Expr.match ) {
  Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
  Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
  array = Array.prototype.slice.call( array, 0 );

  if ( results ) {
    results.push.apply( results, array );
    return results;
  }

  return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
  Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
  makeArray = function( array, results ) {
    var i = 0,
      ret = results || [];

    if ( toString.call(array) === "[object Array]" ) {
      Array.prototype.push.apply( ret, array );

    } else {
      if ( typeof array.length === "number" ) {
        for ( var l = array.length; i < l; i++ ) {
          ret.push( array[i] );
        }

      } else {
        for ( ; array[i]; i++ ) {
          ret.push( array[i] );
        }
      }
    }

    return ret;
  };
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
  sortOrder = function( a, b ) {
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
      return a.compareDocumentPosition ? -1 : 1;
    }

    return a.compareDocumentPosition(b) & 4 ? -1 : 1;
  };

} else {
  sortOrder = function( a, b ) {
    // The nodes are identical, we can exit early
    if ( a === b ) {
      hasDuplicate = true;
      return 0;

    // Fallback to using sourceIndex (in IE) if it's available on both nodes
    } else if ( a.sourceIndex && b.sourceIndex ) {
      return a.sourceIndex - b.sourceIndex;
    }

    var al, bl,
      ap = [],
      bp = [],
      aup = a.parentNode,
      bup = b.parentNode,
      cur = aup;

    // If the nodes are siblings (or identical) we can do a quick check
    if ( aup === bup ) {
      return siblingCheck( a, b );

    // If no parents were found then the nodes are disconnected
    } else if ( !aup ) {
      return -1;

    } else if ( !bup ) {
      return 1;
    }

    // Otherwise they're somewhere else in the tree so we need
    // to build up a full list of the parentNodes for comparison
    while ( cur ) {
      ap.unshift( cur );
      cur = cur.parentNode;
    }

    cur = bup;

    while ( cur ) {
      bp.unshift( cur );
      cur = cur.parentNode;
    }

    al = ap.length;
    bl = bp.length;

    // Start walking down the tree looking for a discrepancy
    for ( var i = 0; i < al && i < bl; i++ ) {
      if ( ap[i] !== bp[i] ) {
        return siblingCheck( ap[i], bp[i] );
      }
    }

    // We ended someplace up the tree so do a sibling check
    return i === al ?
      siblingCheck( a, bp[i], -1 ) :
      siblingCheck( ap[i], b, 1 );
  };

  siblingCheck = function( a, b, ret ) {
    if ( a === b ) {
      return ret;
    }

    var cur = a.nextSibling;

    while ( cur ) {
      if ( cur === b ) {
        return -1;
      }

      cur = cur.nextSibling;
    }

    return 1;
  };
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
  // We're going to inject a fake input element with a specified name
  var form = document.createElement("div"),
    id = "script" + (new Date()).getTime(),
    root = document.documentElement;

  form.innerHTML = "<a name='" + id + "'/>";

  // Inject it into the root element, check its status, and remove it quickly
  root.insertBefore( form, root.firstChild );

  // The workaround has to do additional checks after a getElementById
  // Which slows things down for other browsers (hence the branching)
  if ( document.getElementById( id ) ) {
    Expr.find.ID = function( match, context, isXML ) {
      if ( typeof context.getElementById !== "undefined" && !isXML ) {
        var m = context.getElementById(match[1]);

        return m ?
          m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
            [m] :
            undefined :
          [];
      }
    };

    Expr.filter.ID = function( elem, match ) {
      var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

      return elem.nodeType === 1 && node && node.nodeValue === match;
    };
  }

  root.removeChild( form );

  // release memory in IE
  root = form = null;
})();

(function(){
  // Check to see if the browser returns only elements
  // when doing getElementsByTagName("*")

  // Create a fake element
  var div = document.createElement("div");
  div.appendChild( document.createComment("") );

  // Make sure no comments are found
  if ( div.getElementsByTagName("*").length > 0 ) {
    Expr.find.TAG = function( match, context ) {
      var results = context.getElementsByTagName( match[1] );

      // Filter out possible comments
      if ( match[1] === "*" ) {
        var tmp = [];

        for ( var i = 0; results[i]; i++ ) {
          if ( results[i].nodeType === 1 ) {
            tmp.push( results[i] );
          }
        }

        results = tmp;
      }

      return results;
    };
  }

  // Check to see if an attribute returns normalized href attributes
  div.innerHTML = "<a href='#'></a>";

  if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
      div.firstChild.getAttribute("href") !== "#" ) {

    Expr.attrHandle.href = function( elem ) {
      return elem.getAttribute( "href", 2 );
    };
  }

  // release memory in IE
  div = null;
})();

if ( document.querySelectorAll ) {
  (function(){
    var oldSizzle = Sizzle,
      div = document.createElement("div"),
      id = "__sizzle__";

    div.innerHTML = "<p class='TEST'></p>";

    // Safari can't handle uppercase or unicode characters when
    // in quirks mode.
    if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
      return;
    }

    Sizzle = function( query, context, extra, seed ) {
      context = context || document;

      // Only use querySelectorAll on non-XML documents
      // (ID selectors don't work in non-HTML documents)
      if ( !seed && !Sizzle.isXML(context) ) {
        // See if we find a selector to speed up
        var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

        if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
          // Speed-up: Sizzle("TAG")
          if ( match[1] ) {
            return makeArray( context.getElementsByTagName( query ), extra );

          // Speed-up: Sizzle(".CLASS")
          } else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
            return makeArray( context.getElementsByClassName( match[2] ), extra );
          }
        }

        if ( context.nodeType === 9 ) {
          // Speed-up: Sizzle("body")
          // The body element only exists once, optimize finding it
          if ( query === "body" && context.body ) {
            return makeArray( [ context.body ], extra );

          // Speed-up: Sizzle("#ID")
          } else if ( match && match[3] ) {
            var elem = context.getElementById( match[3] );

            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            if ( elem && elem.parentNode ) {
              // Handle the case where IE and Opera return items
              // by name instead of ID
              if ( elem.id === match[3] ) {
                return makeArray( [ elem ], extra );
              }

            } else {
              return makeArray( [], extra );
            }
          }

          try {
            return makeArray( context.querySelectorAll(query), extra );
          } catch(qsaError) {}

        // qSA works strangely on Element-rooted queries
        // We can work around this by specifying an extra ID on the root
        // and working up from there (Thanks to Andrew Dupont for the technique)
        // IE 8 doesn't work on object elements
        } else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
          var oldContext = context,
            old = context.getAttribute( "id" ),
            nid = old || id,
            hasParent = context.parentNode,
            relativeHierarchySelector = /^\s*[+~]/.test( query );

          if ( !old ) {
            context.setAttribute( "id", nid );
          } else {
            nid = nid.replace( /'/g, "\\$&" );
          }
          if ( relativeHierarchySelector && hasParent ) {
            context = context.parentNode;
          }

          try {
            if ( !relativeHierarchySelector || hasParent ) {
              return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
            }

          } catch(pseudoError) {
          } finally {
            if ( !old ) {
              oldContext.removeAttribute( "id" );
            }
          }
        }
      }

      return oldSizzle(query, context, extra, seed);
    };

    for ( var prop in oldSizzle ) {
      Sizzle[ prop ] = oldSizzle[ prop ];
    }

    // release memory in IE
    div = null;
  })();
}

(function(){
  var html = document.documentElement,
    matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

  if ( matches ) {
    // Check to see if it's possible to do matchesSelector
    // on a disconnected node (IE 9 fails this)
    var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
      pseudoWorks = false;

    try {
      // This should fail with an exception
      // Gecko does not error, returns false instead
      matches.call( document.documentElement, "[test!='']:sizzle" );

    } catch( pseudoError ) {
      pseudoWorks = true;
    }

    Sizzle.matchesSelector = function( node, expr ) {
      // Make sure that attribute selectors are quoted
      expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

      if ( !Sizzle.isXML( node ) ) {
        try {
          if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
            var ret = matches.call( node, expr );

            // IE 9's matchesSelector returns false on disconnected nodes
            if ( ret || !disconnectedMatch ||
                // As well, disconnected nodes are said to be in a document
                // fragment in IE 9, so check for that
                node.document && node.document.nodeType !== 11 ) {
              return ret;
            }
          }
        } catch(e) {}
      }

      return Sizzle(expr, null, null, [node]).length > 0;
    };
  }
})();

(function(){
  var div = document.createElement("div");

  div.innerHTML = "<div class='test e'></div><div class='test'></div>";

  // Opera can't find a second classname (in 9.6)
  // Also, make sure that getElementsByClassName actually exists
  if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
    return;
  }

  // Safari caches class attributes, doesn't catch changes (in 3.2)
  div.lastChild.className = "e";

  if ( div.getElementsByClassName("e").length === 1 ) {
    return;
  }

  Expr.order.splice(1, 0, "CLASS");
  Expr.find.CLASS = function( match, context, isXML ) {
    if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
      return context.getElementsByClassName(match[1]);
    }
  };

  // release memory in IE
  div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
  for ( var i = 0, l = checkSet.length; i < l; i++ ) {
    var elem = checkSet[i];

    if ( elem ) {
      var match = false;

      elem = elem[dir];

      while ( elem ) {
        if ( elem[ expando ] === doneName ) {
          match = checkSet[elem.sizset];
          break;
        }

        if ( elem.nodeType === 1 && !isXML ){
          elem[ expando ] = doneName;
          elem.sizset = i;
        }

        if ( elem.nodeName.toLowerCase() === cur ) {
          match = elem;
          break;
        }

        elem = elem[dir];
      }

      checkSet[i] = match;
    }
  }
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
  for ( var i = 0, l = checkSet.length; i < l; i++ ) {
    var elem = checkSet[i];

    if ( elem ) {
      var match = false;

      elem = elem[dir];

      while ( elem ) {
        if ( elem[ expando ] === doneName ) {
          match = checkSet[elem.sizset];
          break;
        }

        if ( elem.nodeType === 1 ) {
          if ( !isXML ) {
            elem[ expando ] = doneName;
            elem.sizset = i;
          }

          if ( typeof cur !== "string" ) {
            if ( elem === cur ) {
              match = true;
              break;
            }

          } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
            match = elem;
            break;
          }
        }

        elem = elem[dir];
      }

      checkSet[i] = match;
    }
  }
}

if ( document.documentElement.contains ) {
  Sizzle.contains = function( a, b ) {
    return a !== b && (a.contains ? a.contains(b) : true);
  };

} else if ( document.documentElement.compareDocumentPosition ) {
  Sizzle.contains = function( a, b ) {
    return !!(a.compareDocumentPosition(b) & 16);
  };

} else {
  Sizzle.contains = function() {
    return false;
  };
}

Sizzle.isXML = function( elem ) {
  // documentElement is verified for cases where it doesn't yet exist
  // (such as loading iframes in IE - #4833)
  var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

  return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
  var match,
    tmpSet = [],
    later = "",
    root = context.nodeType ? [context] : context;

  // Position selectors must be done after the filter
  // And so must :not(positional) so we move all PSEUDOs to the end
  while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
    later += match[0];
    selector = selector.replace( Expr.match.PSEUDO, "" );
  }

  selector = Expr.relative[selector] ? selector + "*" : selector;

  for ( var i = 0, l = root.length; i < l; i++ ) {
    Sizzle( selector, root[i], tmpSet, seed );
  }

  return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
  rparentsprev = /^(?:parents|prevUntil|prevAll)/,
  // Note: This RegExp should be improved, or likely pulled from Sizzle
  rmultiselector = /,/,
  isSimple = /^.[^:#\[\.,]*$/,
  slice = Array.prototype.slice,
  POS = jQuery.expr.match.POS,
  // methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };

jQuery.fn.extend({
  find: function( selector ) {
    var self = this,
      i, l;

    if ( typeof selector !== "string" ) {
      return jQuery( selector ).filter(function() {
        for ( i = 0, l = self.length; i < l; i++ ) {
          if ( jQuery.contains( self[ i ], this ) ) {
            return true;
          }
        }
      });
    }

    var ret = this.pushStack( "", "find", selector ),
      length, n, r;

    for ( i = 0, l = this.length; i < l; i++ ) {
      length = ret.length;
      jQuery.find( selector, this[i], ret );

      if ( i > 0 ) {
        // Make sure that the results are unique
        for ( n = length; n < ret.length; n++ ) {
          for ( r = 0; r < length; r++ ) {
            if ( ret[r] === ret[n] ) {
              ret.splice(n--, 1);
              break;
            }
          }
        }
      }
    }

    return ret;
  },

  has: function( target ) {
    var targets = jQuery( target );
    return this.filter(function() {
      for ( var i = 0, l = targets.length; i < l; i++ ) {
        if ( jQuery.contains( this, targets[i] ) ) {
          return true;
        }
      }
    });
  },

  not: function( selector ) {
    return this.pushStack( winnow(this, selector, false), "not", selector);
  },

  filter: function( selector ) {
    return this.pushStack( winnow(this, selector, true), "filter", selector );
  },

  is: function( selector ) {
    return !!selector && (
      typeof selector === "string" ?
        // If this is a positional selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        POS.test( selector ) ?
          jQuery( selector, this.context ).index( this[0] ) >= 0 :
          jQuery.filter( selector, this ).length > 0 :
        this.filter( selector ).length > 0 );
  },

  closest: function( selectors, context ) {
    var ret = [], i, l, cur = this[0];

    // Array (deprecated as of jQuery 1.7)
    if ( jQuery.isArray( selectors ) ) {
      var level = 1;

      while ( cur && cur.ownerDocument && cur !== context ) {
        for ( i = 0; i < selectors.length; i++ ) {

          if ( jQuery( cur ).is( selectors[ i ] ) ) {
            ret.push({ selector: selectors[ i ], elem: cur, level: level });
          }
        }

        cur = cur.parentNode;
        level++;
      }

      return ret;
    }

    // String
    var pos = POS.test( selectors ) || typeof selectors !== "string" ?
        jQuery( selectors, context || this.context ) :
        0;

    for ( i = 0, l = this.length; i < l; i++ ) {
      cur = this[i];

      while ( cur ) {
        if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
          ret.push( cur );
          break;

        } else {
          cur = cur.parentNode;
          if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
            break;
          }
        }
      }
    }

    ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

    return this.pushStack( ret, "closest", selectors );
  },

  // Determine the position of an element within
  // the matched set of elements
  index: function( elem ) {

    // No argument, return index in parent
    if ( !elem ) {
      return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
    }

    // index in selector
    if ( typeof elem === "string" ) {
      return jQuery.inArray( this[0], jQuery( elem ) );
    }

    // Locate the position of the desired element
    return jQuery.inArray(
      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem, this );
  },

  add: function( selector, context ) {
    var set = typeof selector === "string" ?
        jQuery( selector, context ) :
        jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
      all = jQuery.merge( this.get(), set );

    return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
      all :
      jQuery.unique( all ) );
  },

  andSelf: function() {
    return this.add( this.prevObject );
  }
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
  return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
  parent: function( elem ) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },
  parents: function( elem ) {
    return jQuery.dir( elem, "parentNode" );
  },
  parentsUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "parentNode", until );
  },
  next: function( elem ) {
    return jQuery.nth( elem, 2, "nextSibling" );
  },
  prev: function( elem ) {
    return jQuery.nth( elem, 2, "previousSibling" );
  },
  nextAll: function( elem ) {
    return jQuery.dir( elem, "nextSibling" );
  },
  prevAll: function( elem ) {
    return jQuery.dir( elem, "previousSibling" );
  },
  nextUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "nextSibling", until );
  },
  prevUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "previousSibling", until );
  },
  siblings: function( elem ) {
    return jQuery.sibling( elem.parentNode.firstChild, elem );
  },
  children: function( elem ) {
    return jQuery.sibling( elem.firstChild );
  },
  contents: function( elem ) {
    return jQuery.nodeName( elem, "iframe" ) ?
      elem.contentDocument || elem.contentWindow.document :
      jQuery.makeArray( elem.childNodes );
  }
}, function( name, fn ) {
  jQuery.fn[ name ] = function( until, selector ) {
    var ret = jQuery.map( this, fn, until );

    if ( !runtil.test( name ) ) {
      selector = until;
    }

    if ( selector && typeof selector === "string" ) {
      ret = jQuery.filter( selector, ret );
    }

    ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

    if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
      ret = ret.reverse();
    }

    return this.pushStack( ret, name, slice.call( arguments ).join(",") );
  };
});

jQuery.extend({
  filter: function( expr, elems, not ) {
    if ( not ) {
      expr = ":not(" + expr + ")";
    }

    return elems.length === 1 ?
      jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
      jQuery.find.matches(expr, elems);
  },

  dir: function( elem, dir, until ) {
    var matched = [],
      cur = elem[ dir ];

    while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
      if ( cur.nodeType === 1 ) {
        matched.push( cur );
      }
      cur = cur[dir];
    }
    return matched;
  },

  nth: function( cur, result, dir, elem ) {
    result = result || 1;
    var num = 0;

    for ( ; cur; cur = cur[dir] ) {
      if ( cur.nodeType === 1 && ++num === result ) {
        break;
      }
    }

    return cur;
  },

  sibling: function( n, elem ) {
    var r = [];

    for ( ; n; n = n.nextSibling ) {
      if ( n.nodeType === 1 && n !== elem ) {
        r.push( n );
      }
    }

    return r;
  }
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

  // Can't pass null or undefined to indexOf in Firefox 4
  // Set to 0 to skip string check
  qualifier = qualifier || 0;

  if ( jQuery.isFunction( qualifier ) ) {
    return jQuery.grep(elements, function( elem, i ) {
      var retVal = !!qualifier.call( elem, i, elem );
      return retVal === keep;
    });

  } else if ( qualifier.nodeType ) {
    return jQuery.grep(elements, function( elem, i ) {
      return ( elem === qualifier ) === keep;
    });

  } else if ( typeof qualifier === "string" ) {
    var filtered = jQuery.grep(elements, function( elem ) {
      return elem.nodeType === 1;
    });

    if ( isSimple.test( qualifier ) ) {
      return jQuery.filter(qualifier, filtered, !keep);
    } else {
      qualifier = jQuery.filter( qualifier, filtered );
    }
  }

  return jQuery.grep(elements, function( elem, i ) {
    return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
  });
}




function createSafeFragment( document ) {
  var list = nodeNames.split( "|" ),
  safeFrag = document.createDocumentFragment();

  if ( safeFrag.createElement ) {
    while ( list.length ) {
      safeFrag.createElement(
        list.pop()
      );
    }
  }
  return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
    "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
  rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
  rleadingWhitespace = /^\s+/,
  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
  rtagName = /<([\w:]+)/,
  rtbody = /<tbody/i,
  rhtml = /<|&#?\w+;/,
  rnoInnerhtml = /<(?:script|style)/i,
  rnocache = /<(?:script|object|embed|option|style)/i,
  rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
  // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  rscriptType = /\/(java|ecma)script/i,
  rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
  wrapMap = {
    option: [ 1, "<select multiple='multiple'>", "</select>" ],
    legend: [ 1, "<fieldset>", "</fieldset>" ],
    thead: [ 1, "<table>", "</table>" ],
    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
    col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
    area: [ 1, "<map>", "</map>" ],
    _default: [ 0, "", "" ]
  },
  safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
  wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
  text: function( text ) {
    if ( jQuery.isFunction(text) ) {
      return this.each(function(i) {
        var self = jQuery( this );

        self.text( text.call(this, i, self.text()) );
      });
    }

    if ( typeof text !== "object" && text !== undefined ) {
      return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
    }

    return jQuery.text( this );
  },

  wrapAll: function( html ) {
    if ( jQuery.isFunction( html ) ) {
      return this.each(function(i) {
        jQuery(this).wrapAll( html.call(this, i) );
      });
    }

    if ( this[0] ) {
      // The elements to wrap the target around
      var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

      if ( this[0].parentNode ) {
        wrap.insertBefore( this[0] );
      }

      wrap.map(function() {
        var elem = this;

        while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
          elem = elem.firstChild;
        }

        return elem;
      }).append( this );
    }

    return this;
  },

  wrapInner: function( html ) {
    if ( jQuery.isFunction( html ) ) {
      return this.each(function(i) {
        jQuery(this).wrapInner( html.call(this, i) );
      });
    }

    return this.each(function() {
      var self = jQuery( this ),
        contents = self.contents();

      if ( contents.length ) {
        contents.wrapAll( html );

      } else {
        self.append( html );
      }
    });
  },

  wrap: function( html ) {
    var isFunction = jQuery.isFunction( html );

    return this.each(function(i) {
      jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
    });
  },

  unwrap: function() {
    return this.parent().each(function() {
      if ( !jQuery.nodeName( this, "body" ) ) {
        jQuery( this ).replaceWith( this.childNodes );
      }
    }).end();
  },

  append: function() {
    return this.domManip(arguments, true, function( elem ) {
      if ( this.nodeType === 1 ) {
        this.appendChild( elem );
      }
    });
  },

  prepend: function() {
    return this.domManip(arguments, true, function( elem ) {
      if ( this.nodeType === 1 ) {
        this.insertBefore( elem, this.firstChild );
      }
    });
  },

  before: function() {
    if ( this[0] && this[0].parentNode ) {
      return this.domManip(arguments, false, function( elem ) {
        this.parentNode.insertBefore( elem, this );
      });
    } else if ( arguments.length ) {
      var set = jQuery.clean( arguments );
      set.push.apply( set, this.toArray() );
      return this.pushStack( set, "before", arguments );
    }
  },

  after: function() {
    if ( this[0] && this[0].parentNode ) {
      return this.domManip(arguments, false, function( elem ) {
        this.parentNode.insertBefore( elem, this.nextSibling );
      });
    } else if ( arguments.length ) {
      var set = this.pushStack( this, "after", arguments );
      set.push.apply( set, jQuery.clean(arguments) );
      return set;
    }
  },

  // keepData is for internal use only--do not document
  remove: function( selector, keepData ) {
    for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
      if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
        if ( !keepData && elem.nodeType === 1 ) {
          jQuery.cleanData( elem.getElementsByTagName("*") );
          jQuery.cleanData( [ elem ] );
        }

        if ( elem.parentNode ) {
          elem.parentNode.removeChild( elem );
        }
      }
    }

    return this;
  },

  empty: function() {
    for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
      // Remove element nodes and prevent memory leaks
      if ( elem.nodeType === 1 ) {
        jQuery.cleanData( elem.getElementsByTagName("*") );
      }

      // Remove any remaining nodes
      while ( elem.firstChild ) {
        elem.removeChild( elem.firstChild );
      }
    }

    return this;
  },

  clone: function( dataAndEvents, deepDataAndEvents ) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    return this.map( function () {
      return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    });
  },

  html: function( value ) {
    if ( value === undefined ) {
      return this[0] && this[0].nodeType === 1 ?
        this[0].innerHTML.replace(rinlinejQuery, "") :
        null;

    // See if we can take a shortcut and just use innerHTML
    } else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
      (jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
      !wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

      value = value.replace(rxhtmlTag, "<$1></$2>");

      try {
        for ( var i = 0, l = this.length; i < l; i++ ) {
          // Remove element nodes and prevent memory leaks
          if ( this[i].nodeType === 1 ) {
            jQuery.cleanData( this[i].getElementsByTagName("*") );
            this[i].innerHTML = value;
          }
        }

      // If using innerHTML throws an exception, use the fallback method
      } catch(e) {
        this.empty().append( value );
      }

    } else if ( jQuery.isFunction( value ) ) {
      this.each(function(i){
        var self = jQuery( this );

        self.html( value.call(this, i, self.html()) );
      });

    } else {
      this.empty().append( value );
    }

    return this;
  },

  replaceWith: function( value ) {
    if ( this[0] && this[0].parentNode ) {
      // Make sure that the elements are removed from the DOM before they are inserted
      // this can help fix replacing a parent with child elements
      if ( jQuery.isFunction( value ) ) {
        return this.each(function(i) {
          var self = jQuery(this), old = self.html();
          self.replaceWith( value.call( this, i, old ) );
        });
      }

      if ( typeof value !== "string" ) {
        value = jQuery( value ).detach();
      }

      return this.each(function() {
        var next = this.nextSibling,
          parent = this.parentNode;

        jQuery( this ).remove();

        if ( next ) {
          jQuery(next).before( value );
        } else {
          jQuery(parent).append( value );
        }
      });
    } else {
      return this.length ?
        this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
        this;
    }
  },

  detach: function( selector ) {
    return this.remove( selector, true );
  },

  domManip: function( args, table, callback ) {
    var results, first, fragment, parent,
      value = args[0],
      scripts = [];

    // We can't cloneNode fragments that contain checked, in WebKit
    if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
      return this.each(function() {
        jQuery(this).domManip( args, table, callback, true );
      });
    }

    if ( jQuery.isFunction(value) ) {
      return this.each(function(i) {
        var self = jQuery(this);
        args[0] = value.call(this, i, table ? self.html() : undefined);
        self.domManip( args, table, callback );
      });
    }

    if ( this[0] ) {
      parent = value && value.parentNode;

      // If we're in a fragment, just use that instead of building a new one
      if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
        results = { fragment: parent };

      } else {
        results = jQuery.buildFragment( args, this, scripts );
      }

      fragment = results.fragment;

      if ( fragment.childNodes.length === 1 ) {
        first = fragment = fragment.firstChild;
      } else {
        first = fragment.firstChild;
      }

      if ( first ) {
        table = table && jQuery.nodeName( first, "tr" );

        for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
          callback.call(
            table ?
              root(this[i], first) :
              this[i],
            // Make sure that we do not leak memory by inadvertently discarding
            // the original fragment (which might have attached data) instead of
            // using it; in addition, use the original fragment object for the last
            // item instead of first because it can end up being emptied incorrectly
            // in certain situations (Bug #8070).
            // Fragments from the fragment cache must always be cloned and never used
            // in place.
            results.cacheable || ( l > 1 && i < lastIndex ) ?
              jQuery.clone( fragment, true, true ) :
              fragment
          );
        }
      }

      if ( scripts.length ) {
        jQuery.each( scripts, evalScript );
      }
    }

    return this;
  }
});

function root( elem, cur ) {
  return jQuery.nodeName(elem, "table") ?
    (elem.getElementsByTagName("tbody")[0] ||
    elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
    elem;
}

function cloneCopyEvent( src, dest ) {

  if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
    return;
  }

  var type, i, l,
    oldData = jQuery._data( src ),
    curData = jQuery._data( dest, oldData ),
    events = oldData.events;

  if ( events ) {
    delete curData.handle;
    curData.events = {};

    for ( type in events ) {
      for ( i = 0, l = events[ type ].length; i < l; i++ ) {
        jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
      }
    }
  }

  // make the cloned public data object a copy from the original
  if ( curData.data ) {
    curData.data = jQuery.extend( {}, curData.data );
  }
}

function cloneFixAttributes( src, dest ) {
  var nodeName;

  // We do not need to do anything for non-Elements
  if ( dest.nodeType !== 1 ) {
    return;
  }

  // clearAttributes removes the attributes, which we don't want,
  // but also removes the attachEvent events, which we *do* want
  if ( dest.clearAttributes ) {
    dest.clearAttributes();
  }

  // mergeAttributes, in contrast, only merges back on the
  // original attributes, not the events
  if ( dest.mergeAttributes ) {
    dest.mergeAttributes( src );
  }

  nodeName = dest.nodeName.toLowerCase();

  // IE6-8 fail to clone children inside object elements that use
  // the proprietary classid attribute value (rather than the type
  // attribute) to identify the type of content to display
  if ( nodeName === "object" ) {
    dest.outerHTML = src.outerHTML;

  } else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
    // IE6-8 fails to persist the checked state of a cloned checkbox
    // or radio button. Worse, IE6-7 fail to give the cloned element
    // a checked appearance if the defaultChecked value isn't also set
    if ( src.checked ) {
      dest.defaultChecked = dest.checked = src.checked;
    }

    // IE6-7 get confused and end up setting the value of a cloned
    // checkbox/radio button to an empty string instead of "on"
    if ( dest.value !== src.value ) {
      dest.value = src.value;
    }

  // IE6-8 fails to return the selected option to the default selected
  // state when cloning options
  } else if ( nodeName === "option" ) {
    dest.selected = src.defaultSelected;

  // IE6-8 fails to set the defaultValue to the correct value when
  // cloning other types of input fields
  } else if ( nodeName === "input" || nodeName === "textarea" ) {
    dest.defaultValue = src.defaultValue;
  }

  // Event data gets referenced instead of copied if the expando
  // gets copied too
  dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
  var fragment, cacheable, cacheresults, doc,
  first = args[ 0 ];

  // nodes may contain either an explicit document object,
  // a jQuery collection or context object.
  // If nodes[0] contains a valid object to assign to doc
  if ( nodes && nodes[0] ) {
    doc = nodes[0].ownerDocument || nodes[0];
  }

  // Ensure that an attr object doesn't incorrectly stand in as a document object
  // Chrome and Firefox seem to allow this to occur and will throw exception
  // Fixes #8950
  if ( !doc.createDocumentFragment ) {
    doc = document;
  }

  // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
  // Cloning options loses the selected state, so don't cache them
  // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
  // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
  // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
  if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
    first.charAt(0) === "<" && !rnocache.test( first ) &&
    (jQuery.support.checkClone || !rchecked.test( first )) &&
    (jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

    cacheable = true;

    cacheresults = jQuery.fragments[ first ];
    if ( cacheresults && cacheresults !== 1 ) {
      fragment = cacheresults;
    }
  }

  if ( !fragment ) {
    fragment = doc.createDocumentFragment();
    jQuery.clean( args, doc, fragment, scripts );
  }

  if ( cacheable ) {
    jQuery.fragments[ first ] = cacheresults ? fragment : 1;
  }

  return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
  appendTo: "append",
  prependTo: "prepend",
  insertBefore: "before",
  insertAfter: "after",
  replaceAll: "replaceWith"
}, function( name, original ) {
  jQuery.fn[ name ] = function( selector ) {
    var ret = [],
      insert = jQuery( selector ),
      parent = this.length === 1 && this[0].parentNode;

    if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
      insert[ original ]( this[0] );
      return this;

    } else {
      for ( var i = 0, l = insert.length; i < l; i++ ) {
        var elems = ( i > 0 ? this.clone(true) : this ).get();
        jQuery( insert[i] )[ original ]( elems );
        ret = ret.concat( elems );
      }

      return this.pushStack( ret, name, insert.selector );
    }
  };
});

function getAll( elem ) {
  if ( typeof elem.getElementsByTagName !== "undefined" ) {
    return elem.getElementsByTagName( "*" );

  } else if ( typeof elem.querySelectorAll !== "undefined" ) {
    return elem.querySelectorAll( "*" );

  } else {
    return [];
  }
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
  if ( elem.type === "checkbox" || elem.type === "radio" ) {
    elem.defaultChecked = elem.checked;
  }
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
  var nodeName = ( elem.nodeName || "" ).toLowerCase();
  if ( nodeName === "input" ) {
    fixDefaultChecked( elem );
  // Skip scripts, get other children
  } else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
    jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
  }
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
  var div = document.createElement( "div" );
  safeFragment.appendChild( div );

  div.innerHTML = elem.outerHTML;
  return div.firstChild;
}

jQuery.extend({
  clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    var srcElements,
      destElements,
      i,
      // IE<=8 does not properly clone detached, unknown element nodes
      clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
        elem.cloneNode( true ) :
        shimCloneNode( elem );

    if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
        (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
      // IE copies events bound via attachEvent when using cloneNode.
      // Calling detachEvent on the clone will also remove the events
      // from the original. In order to get around this, we use some
      // proprietary methods to clear the events. Thanks to MooTools
      // guys for this hotness.

      cloneFixAttributes( elem, clone );

      // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
      srcElements = getAll( elem );
      destElements = getAll( clone );

      // Weird iteration because IE will replace the length property
      // with an element if you are cloning the body and one of the
      // elements on the page has a name or id of "length"
      for ( i = 0; srcElements[i]; ++i ) {
        // Ensure that the destination node is not null; Fixes #9587
        if ( destElements[i] ) {
          cloneFixAttributes( srcElements[i], destElements[i] );
        }
      }
    }

    // Copy the events from the original to the clone
    if ( dataAndEvents ) {
      cloneCopyEvent( elem, clone );

      if ( deepDataAndEvents ) {
        srcElements = getAll( elem );
        destElements = getAll( clone );

        for ( i = 0; srcElements[i]; ++i ) {
          cloneCopyEvent( srcElements[i], destElements[i] );
        }
      }
    }

    srcElements = destElements = null;

    // Return the cloned set
    return clone;
  },

  clean: function( elems, context, fragment, scripts ) {
    var checkScriptType;

    context = context || document;

    // !context.createElement fails in IE with an error but returns typeof 'object'
    if ( typeof context.createElement === "undefined" ) {
      context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
    }

    var ret = [], j;

    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
      if ( typeof elem === "number" ) {
        elem += "";
      }

      if ( !elem ) {
        continue;
      }

      // Convert html string into DOM nodes
      if ( typeof elem === "string" ) {
        if ( !rhtml.test( elem ) ) {
          elem = context.createTextNode( elem );
        } else {
          // Fix "XHTML"-style tags in all browsers
          elem = elem.replace(rxhtmlTag, "<$1></$2>");

          // Trim whitespace, otherwise indexOf won't work as expected
          var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
            wrap = wrapMap[ tag ] || wrapMap._default,
            depth = wrap[0],
            div = context.createElement("div");

          // Append wrapper element to unknown element safe doc fragment
          if ( context === document ) {
            // Use the fragment we've already created for this document
            safeFragment.appendChild( div );
          } else {
            // Use a fragment created with the owner document
            createSafeFragment( context ).appendChild( div );
          }

          // Go to html and back, then peel off extra wrappers
          div.innerHTML = wrap[1] + elem + wrap[2];

          // Move to the right depth
          while ( depth-- ) {
            div = div.lastChild;
          }

          // Remove IE's autoinserted <tbody> from table fragments
          if ( !jQuery.support.tbody ) {

            // String was a <table>, *may* have spurious <tbody>
            var hasBody = rtbody.test(elem),
              tbody = tag === "table" && !hasBody ?
                div.firstChild && div.firstChild.childNodes :

                // String was a bare <thead> or <tfoot>
                wrap[1] === "<table>" && !hasBody ?
                  div.childNodes :
                  [];

            for ( j = tbody.length - 1; j >= 0 ; --j ) {
              if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
                tbody[ j ].parentNode.removeChild( tbody[ j ] );
              }
            }
          }

          // IE completely kills leading whitespace when innerHTML is used
          if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
            div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
          }

          elem = div.childNodes;
        }
      }

      // Resets defaultChecked for any radios and checkboxes
      // about to be appended to the DOM in IE 6/7 (#8060)
      var len;
      if ( !jQuery.support.appendChecked ) {
        if ( elem[0] && typeof (len = elem.length) === "number" ) {
          for ( j = 0; j < len; j++ ) {
            findInputs( elem[j] );
          }
        } else {
          findInputs( elem );
        }
      }

      if ( elem.nodeType ) {
        ret.push( elem );
      } else {
        ret = jQuery.merge( ret, elem );
      }
    }

    if ( fragment ) {
      checkScriptType = function( elem ) {
        return !elem.type || rscriptType.test( elem.type );
      };
      for ( i = 0; ret[i]; i++ ) {
        if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
          scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

        } else {
          if ( ret[i].nodeType === 1 ) {
            var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

            ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
          }
          fragment.appendChild( ret[i] );
        }
      }
    }

    return ret;
  },

  cleanData: function( elems ) {
    var data, id,
      cache = jQuery.cache,
      special = jQuery.event.special,
      deleteExpando = jQuery.support.deleteExpando;

    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
      if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
        continue;
      }

      id = elem[ jQuery.expando ];

      if ( id ) {
        data = cache[ id ];

        if ( data && data.events ) {
          for ( var type in data.events ) {
            if ( special[ type ] ) {
              jQuery.event.remove( elem, type );

            // This is a shortcut to avoid jQuery.event.remove's overhead
            } else {
              jQuery.removeEvent( elem, type, data.handle );
            }
          }

          // Null the DOM reference to avoid IE6/7/8 leak (#7054)
          if ( data.handle ) {
            data.handle.elem = null;
          }
        }

        if ( deleteExpando ) {
          delete elem[ jQuery.expando ];

        } else if ( elem.removeAttribute ) {
          elem.removeAttribute( jQuery.expando );
        }

        delete cache[ id ];
      }
    }
  }
});

function evalScript( i, elem ) {
  if ( elem.src ) {
    jQuery.ajax({
      url: elem.src,
      async: false,
      dataType: "script"
    });
  } else {
    jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
  }

  if ( elem.parentNode ) {
    elem.parentNode.removeChild( elem );
  }
}




var ralpha = /alpha\([^)]*\)/i,
  ropacity = /opacity=([^)]*)/,
  // fixed for IE9, see #8346
  rupper = /([A-Z]|^ms)/g,
  rnumpx = /^-?\d+(?:px)?$/i,
  rnum = /^-?\d/,
  rrelNum = /^([\-+])=([\-+.\de]+)/,

  cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  cssWidth = [ "Left", "Right" ],
  cssHeight = [ "Top", "Bottom" ],
  curCSS,

  getComputedStyle,
  currentStyle;

jQuery.fn.css = function( name, value ) {
  // Setting 'undefined' is a no-op
  if ( arguments.length === 2 && value === undefined ) {
    return this;
  }

  return jQuery.access( this, name, value, true, function( elem, name, value ) {
    return value !== undefined ?
      jQuery.style( elem, name, value ) :
      jQuery.css( elem, name );
  });
};

jQuery.extend({
  // Add in style property hooks for overriding the default
  // behavior of getting and setting a style property
  cssHooks: {
    opacity: {
      get: function( elem, computed ) {
        if ( computed ) {
          // We should always get a number back from opacity
          var ret = curCSS( elem, "opacity", "opacity" );
          return ret === "" ? "1" : ret;

        } else {
          return elem.style.opacity;
        }
      }
    }
  },

  // Exclude the following css properties to add px
  cssNumber: {
    "fillOpacity": true,
    "fontWeight": true,
    "lineHeight": true,
    "opacity": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
  },

  // Add in properties whose names you wish to fix before
  // setting or getting the value
  cssProps: {
    // normalize float css property
    "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
  },

  // Get and set the style property on a DOM Node
  style: function( elem, name, value, extra ) {
    // Don't set styles on text and comment nodes
    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
      return;
    }

    // Make sure that we're working with the right name
    var ret, type, origName = jQuery.camelCase( name ),
      style = elem.style, hooks = jQuery.cssHooks[ origName ];

    name = jQuery.cssProps[ origName ] || origName;

    // Check if we're setting a value
    if ( value !== undefined ) {
      type = typeof value;

      // convert relative number strings (+= or -=) to relative numbers. #7345
      if ( type === "string" && (ret = rrelNum.exec( value )) ) {
        value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
        // Fixes bug #9237
        type = "number";
      }

      // Make sure that NaN and null values aren't set. See: #7116
      if ( value == null || type === "number" && isNaN( value ) ) {
        return;
      }

      // If a number was passed in, add 'px' to the (except for certain CSS properties)
      if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
        value += "px";
      }

      // If a hook was provided, use that value, otherwise just set the specified value
      if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
        // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
        // Fixes bug #5509
        try {
          style[ name ] = value;
        } catch(e) {}
      }

    } else {
      // If a hook was provided get the non-computed value from there
      if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
        return ret;
      }

      // Otherwise just get the value from the style object
      return style[ name ];
    }
  },

  css: function( elem, name, extra ) {
    var ret, hooks;

    // Make sure that we're working with the right name
    name = jQuery.camelCase( name );
    hooks = jQuery.cssHooks[ name ];
    name = jQuery.cssProps[ name ] || name;

    // cssFloat needs a special treatment
    if ( name === "cssFloat" ) {
      name = "float";
    }

    // If a hook was provided get the computed value from there
    if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
      return ret;

    // Otherwise, if a way to get the computed value exists, use that
    } else if ( curCSS ) {
      return curCSS( elem, name );
    }
  },

  // A method for quickly swapping in/out CSS properties to get correct calculations
  swap: function( elem, options, callback ) {
    var old = {};

    // Remember the old values, and insert the new ones
    for ( var name in options ) {
      old[ name ] = elem.style[ name ];
      elem.style[ name ] = options[ name ];
    }

    callback.call( elem );

    // Revert the old values
    for ( name in options ) {
      elem.style[ name ] = old[ name ];
    }
  }
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
  jQuery.cssHooks[ name ] = {
    get: function( elem, computed, extra ) {
      var val;

      if ( computed ) {
        if ( elem.offsetWidth !== 0 ) {
          return getWH( elem, name, extra );
        } else {
          jQuery.swap( elem, cssShow, function() {
            val = getWH( elem, name, extra );
          });
        }

        return val;
      }
    },

    set: function( elem, value ) {
      if ( rnumpx.test( value ) ) {
        // ignore negative width and height values #1599
        value = parseFloat( value );

        if ( value >= 0 ) {
          return value + "px";
        }

      } else {
        return value;
      }
    }
  };
});

if ( !jQuery.support.opacity ) {
  jQuery.cssHooks.opacity = {
    get: function( elem, computed ) {
      // IE uses filters for opacity
      return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
        ( parseFloat( RegExp.$1 ) / 100 ) + "" :
        computed ? "1" : "";
    },

    set: function( elem, value ) {
      var style = elem.style,
        currentStyle = elem.currentStyle,
        opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
        filter = currentStyle && currentStyle.filter || style.filter || "";

      // IE has trouble with opacity if it does not have layout
      // Force it by setting the zoom level
      style.zoom = 1;

      // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
      if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

        // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
        // if "filter:" is present at all, clearType is disabled, we want to avoid this
        // style.removeAttribute is IE Only, but so apparently is this code path...
        style.removeAttribute( "filter" );

        // if there there is no filter style applied in a css rule, we are done
        if ( currentStyle && !currentStyle.filter ) {
          return;
        }
      }

      // otherwise, set new filter values
      style.filter = ralpha.test( filter ) ?
        filter.replace( ralpha, opacity ) :
        filter + " " + opacity;
    }
  };
}

jQuery(function() {
  // This hook cannot be added until DOM ready because the support test
  // for it is not run until after DOM ready
  if ( !jQuery.support.reliableMarginRight ) {
    jQuery.cssHooks.marginRight = {
      get: function( elem, computed ) {
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        // Work around by temporarily setting element display to inline-block
        var ret;
        jQuery.swap( elem, { "display": "inline-block" }, function() {
          if ( computed ) {
            ret = curCSS( elem, "margin-right", "marginRight" );
          } else {
            ret = elem.style.marginRight;
          }
        });
        return ret;
      }
    };
  }
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
  getComputedStyle = function( elem, name ) {
    var ret, defaultView, computedStyle;

    name = name.replace( rupper, "-$1" ).toLowerCase();

    if ( (defaultView = elem.ownerDocument.defaultView) &&
        (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
      ret = computedStyle.getPropertyValue( name );
      if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
        ret = jQuery.style( elem, name );
      }
    }

    return ret;
  };
}

if ( document.documentElement.currentStyle ) {
  currentStyle = function( elem, name ) {
    var left, rsLeft, uncomputed,
      ret = elem.currentStyle && elem.currentStyle[ name ],
      style = elem.style;

    // Avoid setting ret to empty string here
    // so we don't default to auto
    if ( ret === null && style && (uncomputed = style[ name ]) ) {
      ret = uncomputed;
    }

    // From the awesome hack by Dean Edwards
    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

    // If we're not dealing with a regular pixel number
    // but a number that has a weird ending, we need to convert it to pixels
    if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {

      // Remember the original values
      left = style.left;
      rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

      // Put in the new values to get a computed value out
      if ( rsLeft ) {
        elem.runtimeStyle.left = elem.currentStyle.left;
      }
      style.left = name === "fontSize" ? "1em" : ( ret || 0 );
      ret = style.pixelLeft + "px";

      // Revert the changed values
      style.left = left;
      if ( rsLeft ) {
        elem.runtimeStyle.left = rsLeft;
      }
    }

    return ret === "" ? "auto" : ret;
  };
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

  // Start with offset property
  var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
    which = name === "width" ? cssWidth : cssHeight,
    i = 0,
    len = which.length;

  if ( val > 0 ) {
    if ( extra !== "border" ) {
      for ( ; i < len; i++ ) {
        if ( !extra ) {
          val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
        }
        if ( extra === "margin" ) {
          val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
        } else {
          val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
        }
      }
    }

    return val + "px";
  }

  // Fall back to computed then uncomputed css if necessary
  val = curCSS( elem, name, name );
  if ( val < 0 || val == null ) {
    val = elem.style[ name ] || 0;
  }
  // Normalize "", auto, and prepare for extra
  val = parseFloat( val ) || 0;

  // Add padding, border, margin
  if ( extra ) {
    for ( ; i < len; i++ ) {
      val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
      if ( extra !== "padding" ) {
        val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
      }
      if ( extra === "margin" ) {
        val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
      }
    }
  }

  return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
  jQuery.expr.filters.hidden = function( elem ) {
    var width = elem.offsetWidth,
      height = elem.offsetHeight;

    return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
  };

  jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
  };
}




var r20 = /%20/g,
  rbracket = /\[\]$/,
  rCRLF = /\r?\n/g,
  rhash = /#.*$/,
  rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
  rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
  // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
  rnoContent = /^(?:GET|HEAD)$/,
  rprotocol = /^\/\//,
  rquery = /\?/,
  rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
  rselectTextarea = /^(?:select|textarea)/i,
  rspacesAjax = /\s+/,
  rts = /([?&])_=[^&]*/,
  rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

  // Keep a copy of the old load method
  _load = jQuery.fn.load,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},

  // Document location
  ajaxLocation,

  // Document location segments
  ajaxLocParts,

  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
  ajaxLocation = location.href;
} catch( e ) {
  // Use the href attribute of an A element
  // since IE will modify it given document.location
  ajaxLocation = document.createElement( "a" );
  ajaxLocation.href = "";
  ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

  // dataTypeExpression is optional and defaults to "*"
  return function( dataTypeExpression, func ) {

    if ( typeof dataTypeExpression !== "string" ) {
      func = dataTypeExpression;
      dataTypeExpression = "*";
    }

    if ( jQuery.isFunction( func ) ) {
      var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
        i = 0,
        length = dataTypes.length,
        dataType,
        list,
        placeBefore;

      // For each dataType in the dataTypeExpression
      for ( ; i < length; i++ ) {
        dataType = dataTypes[ i ];
        // We control if we're asked to add before
        // any existing element
        placeBefore = /^\+/.test( dataType );
        if ( placeBefore ) {
          dataType = dataType.substr( 1 ) || "*";
        }
        list = structure[ dataType ] = structure[ dataType ] || [];
        // then we add to the structure accordingly
        list[ placeBefore ? "unshift" : "push" ]( func );
      }
    }
  };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
    dataType /* internal */, inspected /* internal */ ) {

  dataType = dataType || options.dataTypes[ 0 ];
  inspected = inspected || {};

  inspected[ dataType ] = true;

  var list = structure[ dataType ],
    i = 0,
    length = list ? list.length : 0,
    executeOnly = ( structure === prefilters ),
    selection;

  for ( ; i < length && ( executeOnly || !selection ); i++ ) {
    selection = list[ i ]( options, originalOptions, jqXHR );
    // If we got redirected to another dataType
    // we try there if executing only and not done already
    if ( typeof selection === "string" ) {
      if ( !executeOnly || inspected[ selection ] ) {
        selection = undefined;
      } else {
        options.dataTypes.unshift( selection );
        selection = inspectPrefiltersOrTransports(
            structure, options, originalOptions, jqXHR, selection, inspected );
      }
    }
  }
  // If we're only executing or nothing was selected
  // we try the catchall dataType if not done already
  if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
    selection = inspectPrefiltersOrTransports(
        structure, options, originalOptions, jqXHR, "*", inspected );
  }
  // unnecessary when only executing (prefilters)
  // but it'll be ignored by the caller in that case
  return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
  var key, deep,
    flatOptions = jQuery.ajaxSettings.flatOptions || {};
  for ( key in src ) {
    if ( src[ key ] !== undefined ) {
      ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
    }
  }
  if ( deep ) {
    jQuery.extend( true, target, deep );
  }
}

jQuery.fn.extend({
  load: function( url, params, callback ) {
    if ( typeof url !== "string" && _load ) {
      return _load.apply( this, arguments );

    // Don't do a request if no elements are being requested
    } else if ( !this.length ) {
      return this;
    }

    var off = url.indexOf( " " );
    if ( off >= 0 ) {
      var selector = url.slice( off, url.length );
      url = url.slice( 0, off );
    }

    // Default to a GET request
    var type = "GET";

    // If the second parameter was provided
    if ( params ) {
      // If it's a function
      if ( jQuery.isFunction( params ) ) {
        // We assume that it's the callback
        callback = params;
        params = undefined;

      // Otherwise, build a param string
      } else if ( typeof params === "object" ) {
        params = jQuery.param( params, jQuery.ajaxSettings.traditional );
        type = "POST";
      }
    }

    var self = this;

    // Request the remote document
    jQuery.ajax({
      url: url,
      type: type,
      dataType: "html",
      data: params,
      // Complete callback (responseText is used internally)
      complete: function( jqXHR, status, responseText ) {
        // Store the response as specified by the jqXHR object
        responseText = jqXHR.responseText;
        // If successful, inject the HTML into all the matched elements
        if ( jqXHR.isResolved() ) {
          // #4825: Get the actual response in case
          // a dataFilter is present in ajaxSettings
          jqXHR.done(function( r ) {
            responseText = r;
          });
          // See if a selector was specified
          self.html( selector ?
            // Create a dummy div to hold the results
            jQuery("<div>")
              // inject the contents of the document in, removing the scripts
              // to avoid any 'Permission Denied' errors in IE
              .append(responseText.replace(rscript, ""))

              // Locate the specified elements
              .find(selector) :

            // If not, just inject the full result
            responseText );
        }

        if ( callback ) {
          self.each( callback, [ responseText, status, jqXHR ] );
        }
      }
    });

    return this;
  },

  serialize: function() {
    return jQuery.param( this.serializeArray() );
  },

  serializeArray: function() {
    return this.map(function(){
      return this.elements ? jQuery.makeArray( this.elements ) : this;
    })
    .filter(function(){
      return this.name && !this.disabled &&
        ( this.checked || rselectTextarea.test( this.nodeName ) ||
          rinput.test( this.type ) );
    })
    .map(function( i, elem ){
      var val = jQuery( this ).val();

      return val == null ?
        null :
        jQuery.isArray( val ) ?
          jQuery.map( val, function( val, i ){
            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
          }) :
          { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    }).get();
  }
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
  jQuery.fn[ o ] = function( f ){
    return this.on( o, f );
  };
});

jQuery.each( [ "get", "post" ], function( i, method ) {
  jQuery[ method ] = function( url, data, callback, type ) {
    // shift arguments if data argument was omitted
    if ( jQuery.isFunction( data ) ) {
      type = type || callback;
      callback = data;
      data = undefined;
    }

    return jQuery.ajax({
      type: method,
      url: url,
      data: data,
      success: callback,
      dataType: type
    });
  };
});

jQuery.extend({

  getScript: function( url, callback ) {
    return jQuery.get( url, undefined, callback, "script" );
  },

  getJSON: function( url, data, callback ) {
    return jQuery.get( url, data, callback, "json" );
  },

  // Creates a full fledged settings object into target
  // with both ajaxSettings and settings fields.
  // If target is omitted, writes into ajaxSettings.
  ajaxSetup: function( target, settings ) {
    if ( settings ) {
      // Building a settings object
      ajaxExtend( target, jQuery.ajaxSettings );
    } else {
      // Extending ajaxSettings
      settings = target;
      target = jQuery.ajaxSettings;
    }
    ajaxExtend( target, settings );
    return target;
  },

  ajaxSettings: {
    url: ajaxLocation,
    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
    global: true,
    type: "GET",
    contentType: "application/x-www-form-urlencoded",
    processData: true,
    async: true,
    /*
    timeout: 0,
    data: null,
    dataType: null,
    username: null,
    password: null,
    cache: null,
    traditional: false,
    headers: {},
    */

    accepts: {
      xml: "application/xml, text/xml",
      html: "text/html",
      text: "text/plain",
      json: "application/json, text/javascript",
      "*": allTypes
    },

    contents: {
      xml: /xml/,
      html: /html/,
      json: /json/
    },

    responseFields: {
      xml: "responseXML",
      text: "responseText"
    },

    // List of data converters
    // 1) key format is "source_type destination_type" (a single space in-between)
    // 2) the catchall symbol "*" can be used for source_type
    converters: {

      // Convert anything to text
      "* text": window.String,

      // Text to html (true = no transformation)
      "text html": true,

      // Evaluate text as a json expression
      "text json": jQuery.parseJSON,

      // Parse text as xml
      "text xml": jQuery.parseXML
    },

    // For options that shouldn't be deep extended:
    // you can add your own custom options here if
    // and when you create one that shouldn't be
    // deep extended (see ajaxExtend)
    flatOptions: {
      context: true,
      url: true
    }
  },

  ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  ajaxTransport: addToPrefiltersOrTransports( transports ),

  // Main method
  ajax: function( url, options ) {

    // If url is an object, simulate pre-1.5 signature
    if ( typeof url === "object" ) {
      options = url;
      url = undefined;
    }

    // Force options to be an object
    options = options || {};

    var // Create the final options object
      s = jQuery.ajaxSetup( {}, options ),
      // Callbacks context
      callbackContext = s.context || s,
      // Context for global events
      // It's the callbackContext if one was provided in the options
      // and if it's a DOM node or a jQuery collection
      globalEventContext = callbackContext !== s &&
        ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
            jQuery( callbackContext ) : jQuery.event,
      // Deferreds
      deferred = jQuery.Deferred(),
      completeDeferred = jQuery.Callbacks( "once memory" ),
      // Status-dependent callbacks
      statusCode = s.statusCode || {},
      // ifModified key
      ifModifiedKey,
      // Headers (they are sent all at once)
      requestHeaders = {},
      requestHeadersNames = {},
      // Response headers
      responseHeadersString,
      responseHeaders,
      // transport
      transport,
      // timeout handle
      timeoutTimer,
      // Cross-domain detection vars
      parts,
      // The jqXHR state
      state = 0,
      // To know if global events are to be dispatched
      fireGlobals,
      // Loop variable
      i,
      // Fake xhr
      jqXHR = {

        readyState: 0,

        // Caches the header
        setRequestHeader: function( name, value ) {
          if ( !state ) {
            var lname = name.toLowerCase();
            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
            requestHeaders[ name ] = value;
          }
          return this;
        },

        // Raw string
        getAllResponseHeaders: function() {
          return state === 2 ? responseHeadersString : null;
        },

        // Builds headers hashtable if needed
        getResponseHeader: function( key ) {
          var match;
          if ( state === 2 ) {
            if ( !responseHeaders ) {
              responseHeaders = {};
              while( ( match = rheaders.exec( responseHeadersString ) ) ) {
                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
              }
            }
            match = responseHeaders[ key.toLowerCase() ];
          }
          return match === undefined ? null : match;
        },

        // Overrides response content-type header
        overrideMimeType: function( type ) {
          if ( !state ) {
            s.mimeType = type;
          }
          return this;
        },

        // Cancel the request
        abort: function( statusText ) {
          statusText = statusText || "abort";
          if ( transport ) {
            transport.abort( statusText );
          }
          done( 0, statusText );
          return this;
        }
      };

    // Callback for when everything is done
    // It is defined here because jslint complains if it is declared
    // at the end of the function (which would be more logical and readable)
    function done( status, nativeStatusText, responses, headers ) {

      // Called once
      if ( state === 2 ) {
        return;
      }

      // State is "done" now
      state = 2;

      // Clear timeout if it exists
      if ( timeoutTimer ) {
        clearTimeout( timeoutTimer );
      }

      // Dereference transport for early garbage collection
      // (no matter how long the jqXHR object will be used)
      transport = undefined;

      // Cache response headers
      responseHeadersString = headers || "";

      // Set readyState
      jqXHR.readyState = status > 0 ? 4 : 0;

      var isSuccess,
        success,
        error,
        statusText = nativeStatusText,
        response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
        lastModified,
        etag;

      // If successful, handle type chaining
      if ( status >= 200 && status < 300 || status === 304 ) {

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {

          if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
            jQuery.lastModified[ ifModifiedKey ] = lastModified;
          }
          if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
            jQuery.etag[ ifModifiedKey ] = etag;
          }
        }

        // If not modified
        if ( status === 304 ) {

          statusText = "notmodified";
          isSuccess = true;

        // If we have data
        } else {

          try {
            success = ajaxConvert( s, response );
            statusText = "success";
            isSuccess = true;
          } catch(e) {
            // We have a parsererror
            statusText = "parsererror";
            error = e;
          }
        }
      } else {
        // We extract error from statusText
        // then normalize statusText and status for non-aborts
        error = statusText;
        if ( !statusText || status ) {
          statusText = "error";
          if ( status < 0 ) {
            status = 0;
          }
        }
      }

      // Set data for the fake xhr object
      jqXHR.status = status;
      jqXHR.statusText = "" + ( nativeStatusText || statusText );

      // Success/Error
      if ( isSuccess ) {
        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
      } else {
        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
      }

      // Status-dependent callbacks
      jqXHR.statusCode( statusCode );
      statusCode = undefined;

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
            [ jqXHR, s, isSuccess ? success : error ] );
      }

      // Complete
      completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
        // Handle the global AJAX counter
        if ( !( --jQuery.active ) ) {
          jQuery.event.trigger( "ajaxStop" );
        }
      }
    }

    // Attach deferreds
    deferred.promise( jqXHR );
    jqXHR.success = jqXHR.done;
    jqXHR.error = jqXHR.fail;
    jqXHR.complete = completeDeferred.add;

    // Status-dependent callbacks
    jqXHR.statusCode = function( map ) {
      if ( map ) {
        var tmp;
        if ( state < 2 ) {
          for ( tmp in map ) {
            statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
          }
        } else {
          tmp = map[ jqXHR.status ];
          jqXHR.then( tmp, tmp );
        }
      }
      return this;
    };

    // Remove hash character (#7531: and string promotion)
    // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
    // We also use the url parameter if available
    s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

    // Extract dataTypes list
    s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

    // Determine if a cross-domain request is in order
    if ( s.crossDomain == null ) {
      parts = rurl.exec( s.url.toLowerCase() );
      s.crossDomain = !!( parts &&
        ( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
          ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
      );
    }

    // Convert data if not already a string
    if ( s.data && s.processData && typeof s.data !== "string" ) {
      s.data = jQuery.param( s.data, s.traditional );
    }

    // Apply prefilters
    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

    // If request was aborted inside a prefiler, stop there
    if ( state === 2 ) {
      return false;
    }

    // We can fire global events as of now if asked to
    fireGlobals = s.global;

    // Uppercase the type
    s.type = s.type.toUpperCase();

    // Determine if request has content
    s.hasContent = !rnoContent.test( s.type );

    // Watch for a new set of requests
    if ( fireGlobals && jQuery.active++ === 0 ) {
      jQuery.event.trigger( "ajaxStart" );
    }

    // More options handling for requests with no content
    if ( !s.hasContent ) {

      // If data is available, append data to url
      if ( s.data ) {
        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
        // #9682: remove data so that it's not used in an eventual retry
        delete s.data;
      }

      // Get ifModifiedKey before adding the anti-cache parameter
      ifModifiedKey = s.url;

      // Add anti-cache in url if needed
      if ( s.cache === false ) {

        var ts = jQuery.now(),
          // try replacing _= if it is there
          ret = s.url.replace( rts, "$1_=" + ts );

        // if nothing was replaced, add timestamp to the end
        s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
      }
    }

    // Set the correct header, if data is being sent
    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
      jqXHR.setRequestHeader( "Content-Type", s.contentType );
    }

    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    if ( s.ifModified ) {
      ifModifiedKey = ifModifiedKey || s.url;
      if ( jQuery.lastModified[ ifModifiedKey ] ) {
        jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
      }
      if ( jQuery.etag[ ifModifiedKey ] ) {
        jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
      }
    }

    // Set the Accepts header for the server, depending on the dataType
    jqXHR.setRequestHeader(
      "Accept",
      s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
        s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
        s.accepts[ "*" ]
    );

    // Check for headers option
    for ( i in s.headers ) {
      jqXHR.setRequestHeader( i, s.headers[ i ] );
    }

    // Allow custom headers/mimetypes and early abort
    if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
        // Abort if not done already
        jqXHR.abort();
        return false;

    }

    // Install callbacks on deferreds
    for ( i in { success: 1, error: 1, complete: 1 } ) {
      jqXHR[ i ]( s[ i ] );
    }

    // Get transport
    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

    // If no transport, we auto-abort
    if ( !transport ) {
      done( -1, "No Transport" );
    } else {
      jqXHR.readyState = 1;
      // Send global event
      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
      }
      // Timeout
      if ( s.async && s.timeout > 0 ) {
        timeoutTimer = setTimeout( function(){
          jqXHR.abort( "timeout" );
        }, s.timeout );
      }

      try {
        state = 1;
        transport.send( requestHeaders, done );
      } catch (e) {
        // Propagate exception as error if not done
        if ( state < 2 ) {
          done( -1, e );
        // Simply rethrow otherwise
        } else {
          throw e;
        }
      }
    }

    return jqXHR;
  },

  // Serialize an array of form elements or a set of
  // key/values into a query string
  param: function( a, traditional ) {
    var s = [],
      add = function( key, value ) {
        // If value is a function, invoke it and return its value
        value = jQuery.isFunction( value ) ? value() : value;
        s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
      };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if ( traditional === undefined ) {
      traditional = jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
      // Serialize the form elements
      jQuery.each( a, function() {
        add( this.name, this.value );
      });

    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for ( var prefix in a ) {
        buildParams( prefix, a[ prefix ], traditional, add );
      }
    }

    // Return the resulting serialization
    return s.join( "&" ).replace( r20, "+" );
  }
});

function buildParams( prefix, obj, traditional, add ) {
  if ( jQuery.isArray( obj ) ) {
    // Serialize array item.
    jQuery.each( obj, function( i, v ) {
      if ( traditional || rbracket.test( prefix ) ) {
        // Treat each array item as a scalar.
        add( prefix, v );

      } else {
        // If array item is non-scalar (array or object), encode its
        // numeric index to resolve deserialization ambiguity issues.
        // Note that rack (as of 1.0.0) can't currently deserialize
        // nested arrays properly, and attempting to do so may cause
        // a server error. Possible fixes are to modify rack's
        // deserialization algorithm or to provide an option or flag
        // to force array serialization to be shallow.
        buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
      }
    });

  } else if ( !traditional && obj != null && typeof obj === "object" ) {
    // Serialize object item.
    for ( var name in obj ) {
      buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    }

  } else {
    // Serialize scalar item.
    add( prefix, obj );
  }
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

  // Counter for holding the number of active queries
  active: 0,

  // Last-Modified header cache for next request
  lastModified: {},
  etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

  var contents = s.contents,
    dataTypes = s.dataTypes,
    responseFields = s.responseFields,
    ct,
    type,
    finalDataType,
    firstDataType;

  // Fill responseXXX fields
  for ( type in responseFields ) {
    if ( type in responses ) {
      jqXHR[ responseFields[type] ] = responses[ type ];
    }
  }

  // Remove auto dataType and get content-type in the process
  while( dataTypes[ 0 ] === "*" ) {
    dataTypes.shift();
    if ( ct === undefined ) {
      ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
    }
  }

  // Check if we're dealing with a known content-type
  if ( ct ) {
    for ( type in contents ) {
      if ( contents[ type ] && contents[ type ].test( ct ) ) {
        dataTypes.unshift( type );
        break;
      }
    }
  }

  // Check to see if we have a response for the expected dataType
  if ( dataTypes[ 0 ] in responses ) {
    finalDataType = dataTypes[ 0 ];
  } else {
    // Try convertible dataTypes
    for ( type in responses ) {
      if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
        finalDataType = type;
        break;
      }
      if ( !firstDataType ) {
        firstDataType = type;
      }
    }
    // Or just use first one
    finalDataType = finalDataType || firstDataType;
  }

  // If we found a dataType
  // We add the dataType to the list if needed
  // and return the corresponding response
  if ( finalDataType ) {
    if ( finalDataType !== dataTypes[ 0 ] ) {
      dataTypes.unshift( finalDataType );
    }
    return responses[ finalDataType ];
  }
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

  // Apply the dataFilter if provided
  if ( s.dataFilter ) {
    response = s.dataFilter( response, s.dataType );
  }

  var dataTypes = s.dataTypes,
    converters = {},
    i,
    key,
    length = dataTypes.length,
    tmp,
    // Current and previous dataTypes
    current = dataTypes[ 0 ],
    prev,
    // Conversion expression
    conversion,
    // Conversion function
    conv,
    // Conversion functions (transitive conversion)
    conv1,
    conv2;

  // For each dataType in the chain
  for ( i = 1; i < length; i++ ) {

    // Create converters map
    // with lowercased keys
    if ( i === 1 ) {
      for ( key in s.converters ) {
        if ( typeof key === "string" ) {
          converters[ key.toLowerCase() ] = s.converters[ key ];
        }
      }
    }

    // Get the dataTypes
    prev = current;
    current = dataTypes[ i ];

    // If current is auto dataType, update it to prev
    if ( current === "*" ) {
      current = prev;
    // If no auto and dataTypes are actually different
    } else if ( prev !== "*" && prev !== current ) {

      // Get the converter
      conversion = prev + " " + current;
      conv = converters[ conversion ] || converters[ "* " + current ];

      // If there is no direct converter, search transitively
      if ( !conv ) {
        conv2 = undefined;
        for ( conv1 in converters ) {
          tmp = conv1.split( " " );
          if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
            conv2 = converters[ tmp[1] + " " + current ];
            if ( conv2 ) {
              conv1 = converters[ conv1 ];
              if ( conv1 === true ) {
                conv = conv2;
              } else if ( conv2 === true ) {
                conv = conv1;
              }
              break;
            }
          }
        }
      }
      // If we found no converter, dispatch an error
      if ( !( conv || conv2 ) ) {
        jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
      }
      // If found converter is not an equivalence
      if ( conv !== true ) {
        // Convert with 1 or 2 converters accordingly
        response = conv ? conv( response ) : conv2( conv1(response) );
      }
    }
  }
  return response;
}




var jsc = jQuery.now(),
  jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
  jsonp: "callback",
  jsonpCallback: function() {
    return jQuery.expando + "_" + ( jsc++ );
  }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
    ( typeof s.data === "string" );

  if ( s.dataTypes[ 0 ] === "jsonp" ||
    s.jsonp !== false && ( jsre.test( s.url ) ||
        inspectData && jsre.test( s.data ) ) ) {

    var responseContainer,
      jsonpCallback = s.jsonpCallback =
        jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
      previous = window[ jsonpCallback ],
      url = s.url,
      data = s.data,
      replace = "$1" + jsonpCallback + "$2";

    if ( s.jsonp !== false ) {
      url = url.replace( jsre, replace );
      if ( s.url === url ) {
        if ( inspectData ) {
          data = data.replace( jsre, replace );
        }
        if ( s.data === data ) {
          // Add callback manually
          url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
        }
      }
    }

    s.url = url;
    s.data = data;

    // Install callback
    window[ jsonpCallback ] = function( response ) {
      responseContainer = [ response ];
    };

    // Clean-up function
    jqXHR.always(function() {
      // Set callback back to previous value
      window[ jsonpCallback ] = previous;
      // Call if it was a function and we have a response
      if ( responseContainer && jQuery.isFunction( previous ) ) {
        window[ jsonpCallback ]( responseContainer[ 0 ] );
      }
    });

    // Use data converter to retrieve json after script execution
    s.converters["script json"] = function() {
      if ( !responseContainer ) {
        jQuery.error( jsonpCallback + " was not called" );
      }
      return responseContainer[ 0 ];
    };

    // force json dataType
    s.dataTypes[ 0 ] = "json";

    // Delegate to script
    return "script";
  }
});




// Install script dataType
jQuery.ajaxSetup({
  accepts: {
    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
  },
  contents: {
    script: /javascript|ecmascript/
  },
  converters: {
    "text script": function( text ) {
      jQuery.globalEval( text );
      return text;
    }
  }
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
  if ( s.cache === undefined ) {
    s.cache = false;
  }
  if ( s.crossDomain ) {
    s.type = "GET";
    s.global = false;
  }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

  // This transport only deals with cross domain requests
  if ( s.crossDomain ) {

    var script,
      head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

    return {

      send: function( _, callback ) {

        script = document.createElement( "script" );

        script.async = "async";

        if ( s.scriptCharset ) {
          script.charset = s.scriptCharset;
        }

        script.src = s.url;

        // Attach handlers for all browsers
        script.onload = script.onreadystatechange = function( _, isAbort ) {

          if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

            // Handle memory leak in IE
            script.onload = script.onreadystatechange = null;

            // Remove the script
            if ( head && script.parentNode ) {
              head.removeChild( script );
            }

            // Dereference the script
            script = undefined;

            // Callback if not abort
            if ( !isAbort ) {
              callback( 200, "success" );
            }
          }
        };
        // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
        // This arises when a base node is used (#2709 and #4378).
        head.insertBefore( script, head.firstChild );
      },

      abort: function() {
        if ( script ) {
          script.onload( 0, 1 );
        }
      }
    };
  }
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
  xhrOnUnloadAbort = window.ActiveXObject ? function() {
    // Abort all pending requests
    for ( var key in xhrCallbacks ) {
      xhrCallbacks[ key ]( 0, 1 );
    }
  } : false,
  xhrId = 0,
  xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
  try {
    return new window.XMLHttpRequest();
  } catch( e ) {}
}

function createActiveXHR() {
  try {
    return new window.ActiveXObject( "Microsoft.XMLHTTP" );
  } catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
  /* Microsoft failed to properly
   * implement the XMLHttpRequest in IE7 (can't request local files),
   * so we use the ActiveXObject when it is available
   * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
   * we need a fallback.
   */
  function() {
    return !this.isLocal && createStandardXHR() || createActiveXHR();
  } :
  // For all other browsers, use the standard XMLHttpRequest object
  createStandardXHR;

// Determine support properties
(function( xhr ) {
  jQuery.extend( jQuery.support, {
    ajax: !!xhr,
    cors: !!xhr && ( "withCredentials" in xhr )
  });
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

  jQuery.ajaxTransport(function( s ) {
    // Cross domain only allowed if supported through XMLHttpRequest
    if ( !s.crossDomain || jQuery.support.cors ) {

      var callback;

      return {
        send: function( headers, complete ) {

          // Get a new xhr
          var xhr = s.xhr(),
            handle,
            i;

          // Open the socket
          // Passing null username, generates a login popup on Opera (#2865)
          if ( s.username ) {
            xhr.open( s.type, s.url, s.async, s.username, s.password );
          } else {
            xhr.open( s.type, s.url, s.async );
          }

          // Apply custom fields if provided
          if ( s.xhrFields ) {
            for ( i in s.xhrFields ) {
              xhr[ i ] = s.xhrFields[ i ];
            }
          }

          // Override mime type if needed
          if ( s.mimeType && xhr.overrideMimeType ) {
            xhr.overrideMimeType( s.mimeType );
          }

          // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.
          if ( !s.crossDomain && !headers["X-Requested-With"] ) {
            headers[ "X-Requested-With" ] = "XMLHttpRequest";
          }

          // Need an extra try/catch for cross domain requests in Firefox 3
          try {
            for ( i in headers ) {
              xhr.setRequestHeader( i, headers[ i ] );
            }
          } catch( _ ) {}

          // Do send the request
          // This may raise an exception which is actually
          // handled in jQuery.ajax (so no try/catch here)
          xhr.send( ( s.hasContent && s.data ) || null );

          // Listener
          callback = function( _, isAbort ) {

            var status,
              statusText,
              responseHeaders,
              responses,
              xml;

            // Firefox throws exceptions when accessing properties
            // of an xhr when a network error occured
            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
            try {

              // Was never called and is aborted or complete
              if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

                // Only called once
                callback = undefined;

                // Do not keep as active anymore
                if ( handle ) {
                  xhr.onreadystatechange = jQuery.noop;
                  if ( xhrOnUnloadAbort ) {
                    delete xhrCallbacks[ handle ];
                  }
                }

                // If it's an abort
                if ( isAbort ) {
                  // Abort it manually if needed
                  if ( xhr.readyState !== 4 ) {
                    xhr.abort();
                  }
                } else {
                  status = xhr.status;
                  responseHeaders = xhr.getAllResponseHeaders();
                  responses = {};
                  xml = xhr.responseXML;

                  // Construct response list
                  if ( xml && xml.documentElement /* #4958 */ ) {
                    responses.xml = xml;
                  }
                  responses.text = xhr.responseText;

                  // Firefox throws an exception when accessing
                  // statusText for faulty cross-domain requests
                  try {
                    statusText = xhr.statusText;
                  } catch( e ) {
                    // We normalize with Webkit giving an empty statusText
                    statusText = "";
                  }

                  // Filter status for non standard behaviors

                  // If the request is local and we have data: assume a success
                  // (success with no data won't get notified, that's the best we
                  // can do given current implementations)
                  if ( !status && s.isLocal && !s.crossDomain ) {
                    status = responses.text ? 200 : 404;
                  // IE - #1450: sometimes returns 1223 when it should be 204
                  } else if ( status === 1223 ) {
                    status = 204;
                  }
                }
              }
            } catch( firefoxAccessException ) {
              if ( !isAbort ) {
                complete( -1, firefoxAccessException );
              }
            }

            // Call complete if needed
            if ( responses ) {
              complete( status, statusText, responses, responseHeaders );
            }
          };

          // if we're in sync mode or it's in cache
          // and has been retrieved directly (IE6 & IE7)
          // we need to manually fire the callback
          if ( !s.async || xhr.readyState === 4 ) {
            callback();
          } else {
            handle = ++xhrId;
            if ( xhrOnUnloadAbort ) {
              // Create the active xhrs callbacks list if needed
              // and attach the unload handler
              if ( !xhrCallbacks ) {
                xhrCallbacks = {};
                jQuery( window ).unload( xhrOnUnloadAbort );
              }
              // Add to list of active xhrs callbacks
              xhrCallbacks[ handle ] = callback;
            }
            xhr.onreadystatechange = callback;
          }
        },

        abort: function() {
          if ( callback ) {
            callback(0,1);
          }
        }
      };
    }
  });
}




var elemdisplay = {},
  iframe, iframeDoc,
  rfxtypes = /^(?:toggle|show|hide)$/,
  rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
  timerId,
  fxAttrs = [
    // height animations
    [ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
    // width animations
    [ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
    // opacity animations
    [ "opacity" ]
  ],
  fxNow;

jQuery.fn.extend({
  show: function( speed, easing, callback ) {
    var elem, display;

    if ( speed || speed === 0 ) {
      return this.animate( genFx("show", 3), speed, easing, callback );

    } else {
      for ( var i = 0, j = this.length; i < j; i++ ) {
        elem = this[ i ];

        if ( elem.style ) {
          display = elem.style.display;

          // Reset the inline display of this element to learn if it is
          // being hidden by cascaded rules or not
          if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
            display = elem.style.display = "";
          }

          // Set elements which have been overridden with display: none
          // in a stylesheet to whatever the default browser style is
          // for such an element
          if ( display === "" && jQuery.css(elem, "display") === "none" ) {
            jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
          }
        }
      }

      // Set the display of most of the elements in a second loop
      // to avoid the constant reflow
      for ( i = 0; i < j; i++ ) {
        elem = this[ i ];

        if ( elem.style ) {
          display = elem.style.display;

          if ( display === "" || display === "none" ) {
            elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
          }
        }
      }

      return this;
    }
  },

  hide: function( speed, easing, callback ) {
    if ( speed || speed === 0 ) {
      return this.animate( genFx("hide", 3), speed, easing, callback);

    } else {
      var elem, display,
        i = 0,
        j = this.length;

      for ( ; i < j; i++ ) {
        elem = this[i];
        if ( elem.style ) {
          display = jQuery.css( elem, "display" );

          if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
            jQuery._data( elem, "olddisplay", display );
          }
        }
      }

      // Set the display of the elements in a second loop
      // to avoid the constant reflow
      for ( i = 0; i < j; i++ ) {
        if ( this[i].style ) {
          this[i].style.display = "none";
        }
      }

      return this;
    }
  },

  // Save the old toggle function
  _toggle: jQuery.fn.toggle,

  toggle: function( fn, fn2, callback ) {
    var bool = typeof fn === "boolean";

    if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
      this._toggle.apply( this, arguments );

    } else if ( fn == null || bool ) {
      this.each(function() {
        var state = bool ? fn : jQuery(this).is(":hidden");
        jQuery(this)[ state ? "show" : "hide" ]();
      });

    } else {
      this.animate(genFx("toggle", 3), fn, fn2, callback);
    }

    return this;
  },

  fadeTo: function( speed, to, easing, callback ) {
    return this.filter(":hidden").css("opacity", 0).show().end()
          .animate({opacity: to}, speed, easing, callback);
  },

  animate: function( prop, speed, easing, callback ) {
    var optall = jQuery.speed( speed, easing, callback );

    if ( jQuery.isEmptyObject( prop ) ) {
      return this.each( optall.complete, [ false ] );
    }

    // Do not change referenced properties as per-property easing will be lost
    prop = jQuery.extend( {}, prop );

    function doAnimation() {
      // XXX 'this' does not always have a nodeName when running the
      // test suite

      if ( optall.queue === false ) {
        jQuery._mark( this );
      }

      var opt = jQuery.extend( {}, optall ),
        isElement = this.nodeType === 1,
        hidden = isElement && jQuery(this).is(":hidden"),
        name, val, p, e,
        parts, start, end, unit,
        method;

      // will store per property easing and be used to determine when an animation is complete
      opt.animatedProperties = {};

      for ( p in prop ) {

        // property name normalization
        name = jQuery.camelCase( p );
        if ( p !== name ) {
          prop[ name ] = prop[ p ];
          delete prop[ p ];
        }

        val = prop[ name ];

        // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
        if ( jQuery.isArray( val ) ) {
          opt.animatedProperties[ name ] = val[ 1 ];
          val = prop[ name ] = val[ 0 ];
        } else {
          opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
        }

        if ( val === "hide" && hidden || val === "show" && !hidden ) {
          return opt.complete.call( this );
        }

        if ( isElement && ( name === "height" || name === "width" ) ) {
          // Make sure that nothing sneaks out
          // Record all 3 overflow attributes because IE does not
          // change the overflow attribute when overflowX and
          // overflowY are set to the same value
          opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

          // Set display property to inline-block for height/width
          // animations on inline elements that are having width/height animated
          if ( jQuery.css( this, "display" ) === "inline" &&
              jQuery.css( this, "float" ) === "none" ) {

            // inline-level elements accept inline-block;
            // block-level elements need to be inline with layout
            if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
              this.style.display = "inline-block";

            } else {
              this.style.zoom = 1;
            }
          }
        }
      }

      if ( opt.overflow != null ) {
        this.style.overflow = "hidden";
      }

      for ( p in prop ) {
        e = new jQuery.fx( this, opt, p );
        val = prop[ p ];

        if ( rfxtypes.test( val ) ) {

          // Tracks whether to show or hide based on private
          // data attached to the element
          method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
          if ( method ) {
            jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
            e[ method ]();
          } else {
            e[ val ]();
          }

        } else {
          parts = rfxnum.exec( val );
          start = e.cur();

          if ( parts ) {
            end = parseFloat( parts[2] );
            unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

            // We need to compute starting value
            if ( unit !== "px" ) {
              jQuery.style( this, p, (end || 1) + unit);
              start = ( (end || 1) / e.cur() ) * start;
              jQuery.style( this, p, start + unit);
            }

            // If a +=/-= token was provided, we're doing a relative animation
            if ( parts[1] ) {
              end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
            }

            e.custom( start, end, unit );

          } else {
            e.custom( start, val, "" );
          }
        }
      }

      // For JS strict compliance
      return true;
    }

    return optall.queue === false ?
      this.each( doAnimation ) :
      this.queue( optall.queue, doAnimation );
  },

  stop: function( type, clearQueue, gotoEnd ) {
    if ( typeof type !== "string" ) {
      gotoEnd = clearQueue;
      clearQueue = type;
      type = undefined;
    }
    if ( clearQueue && type !== false ) {
      this.queue( type || "fx", [] );
    }

    return this.each(function() {
      var index,
        hadTimers = false,
        timers = jQuery.timers,
        data = jQuery._data( this );

      // clear marker counters if we know they won't be
      if ( !gotoEnd ) {
        jQuery._unmark( true, this );
      }

      function stopQueue( elem, data, index ) {
        var hooks = data[ index ];
        jQuery.removeData( elem, index, true );
        hooks.stop( gotoEnd );
      }

      if ( type == null ) {
        for ( index in data ) {
          if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
            stopQueue( this, data, index );
          }
        }
      } else if ( data[ index = type + ".run" ] && data[ index ].stop ){
        stopQueue( this, data, index );
      }

      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
          if ( gotoEnd ) {

            // force the next step to be the last
            timers[ index ]( true );
          } else {
            timers[ index ].saveState();
          }
          hadTimers = true;
          timers.splice( index, 1 );
        }
      }

      // start the next in the queue if the last step wasn't forced
      // timers currently will call their complete callbacks, which will dequeue
      // but only if they were gotoEnd
      if ( !( gotoEnd && hadTimers ) ) {
        jQuery.dequeue( this, type );
      }
    });
  }

});

// Animations created synchronously will run synchronously
function createFxNow() {
  setTimeout( clearFxNow, 0 );
  return ( fxNow = jQuery.now() );
}

function clearFxNow() {
  fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
  var obj = {};

  jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
    obj[ this ] = type;
  });

  return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
  slideDown: genFx( "show", 1 ),
  slideUp: genFx( "hide", 1 ),
  slideToggle: genFx( "toggle", 1 ),
  fadeIn: { opacity: "show" },
  fadeOut: { opacity: "hide" },
  fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return this.animate( props, speed, easing, callback );
  };
});

jQuery.extend({
  speed: function( speed, easing, fn ) {
    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
      complete: fn || !fn && easing ||
        jQuery.isFunction( speed ) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    };

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
      opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

    // normalize opt.queue - true/undefined/null -> "fx"
    if ( opt.queue == null || opt.queue === true ) {
      opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function( noUnmark ) {
      if ( jQuery.isFunction( opt.old ) ) {
        opt.old.call( this );
      }

      if ( opt.queue ) {
        jQuery.dequeue( this, opt.queue );
      } else if ( noUnmark !== false ) {
        jQuery._unmark( this );
      }
    };

    return opt;
  },

  easing: {
    linear: function( p, n, firstNum, diff ) {
      return firstNum + diff * p;
    },
    swing: function( p, n, firstNum, diff ) {
      return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
    }
  },

  timers: [],

  fx: function( elem, options, prop ) {
    this.options = options;
    this.elem = elem;
    this.prop = prop;

    options.orig = options.orig || {};
  }

});

jQuery.fx.prototype = {
  // Simple function for setting a style value
  update: function() {
    if ( this.options.step ) {
      this.options.step.call( this.elem, this.now, this );
    }

    ( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
  },

  // Get the current size
  cur: function() {
    if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
      return this.elem[ this.prop ];
    }

    var parsed,
      r = jQuery.css( this.elem, this.prop );
    // Empty strings, null, undefined and "auto" are converted to 0,
    // complex values such as "rotate(1rad)" are returned as is,
    // simple values such as "10px" are parsed to Float.
    return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
  },

  // Start an animation from one number to another
  custom: function( from, to, unit ) {
    var self = this,
      fx = jQuery.fx;

    this.startTime = fxNow || createFxNow();
    this.end = to;
    this.now = this.start = from;
    this.pos = this.state = 0;
    this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

    function t( gotoEnd ) {
      return self.step( gotoEnd );
    }

    t.queue = this.options.queue;
    t.elem = this.elem;
    t.saveState = function() {
      if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
        jQuery._data( self.elem, "fxshow" + self.prop, self.start );
      }
    };

    if ( t() && jQuery.timers.push(t) && !timerId ) {
      timerId = setInterval( fx.tick, fx.interval );
    }
  },

  // Simple 'show' function
  show: function() {
    var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

    // Remember where we started, so that we can go back to it later
    this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
    this.options.show = true;

    // Begin the animation
    // Make sure that we start at a small width/height to avoid any flash of content
    if ( dataShow !== undefined ) {
      // This show is picking up where a previous hide or show left off
      this.custom( this.cur(), dataShow );
    } else {
      this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
    }

    // Start by showing the element
    jQuery( this.elem ).show();
  },

  // Simple 'hide' function
  hide: function() {
    // Remember where we started, so that we can go back to it later
    this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
    this.options.hide = true;

    // Begin the animation
    this.custom( this.cur(), 0 );
  },

  // Each step of an animation
  step: function( gotoEnd ) {
    var p, n, complete,
      t = fxNow || createFxNow(),
      done = true,
      elem = this.elem,
      options = this.options;

    if ( gotoEnd || t >= options.duration + this.startTime ) {
      this.now = this.end;
      this.pos = this.state = 1;
      this.update();

      options.animatedProperties[ this.prop ] = true;

      for ( p in options.animatedProperties ) {
        if ( options.animatedProperties[ p ] !== true ) {
          done = false;
        }
      }

      if ( done ) {
        // Reset the overflow
        if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

          jQuery.each( [ "", "X", "Y" ], function( index, value ) {
            elem.style[ "overflow" + value ] = options.overflow[ index ];
          });
        }

        // Hide the element if the "hide" operation was done
        if ( options.hide ) {
          jQuery( elem ).hide();
        }

        // Reset the properties, if the item has been hidden or shown
        if ( options.hide || options.show ) {
          for ( p in options.animatedProperties ) {
            jQuery.style( elem, p, options.orig[ p ] );
            jQuery.removeData( elem, "fxshow" + p, true );
            // Toggle data is no longer needed
            jQuery.removeData( elem, "toggle" + p, true );
          }
        }

        // Execute the complete function
        // in the event that the complete function throws an exception
        // we must ensure it won't be called twice. #5684

        complete = options.complete;
        if ( complete ) {

          options.complete = false;
          complete.call( elem );
        }
      }

      return false;

    } else {
      // classical easing cannot be used with an Infinity duration
      if ( options.duration == Infinity ) {
        this.now = t;
      } else {
        n = t - this.startTime;
        this.state = n / options.duration;

        // Perform the easing function, defaults to swing
        this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
        this.now = this.start + ( (this.end - this.start) * this.pos );
      }
      // Perform the next step of the animation
      this.update();
    }

    return true;
  }
};

jQuery.extend( jQuery.fx, {
  tick: function() {
    var timer,
      timers = jQuery.timers,
      i = 0;

    for ( ; i < timers.length; i++ ) {
      timer = timers[ i ];
      // Checks the timer has not already been removed
      if ( !timer() && timers[ i ] === timer ) {
        timers.splice( i--, 1 );
      }
    }

    if ( !timers.length ) {
      jQuery.fx.stop();
    }
  },

  interval: 13,

  stop: function() {
    clearInterval( timerId );
    timerId = null;
  },

  speeds: {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  },

  step: {
    opacity: function( fx ) {
      jQuery.style( fx.elem, "opacity", fx.now );
    },

    _default: function( fx ) {
      if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
        fx.elem.style[ fx.prop ] = fx.now + fx.unit;
      } else {
        fx.elem[ fx.prop ] = fx.now;
      }
    }
  }
});

// Adds width/height step functions
// Do not set anything below 0
jQuery.each([ "width", "height" ], function( i, prop ) {
  jQuery.fx.step[ prop ] = function( fx ) {
    jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
  };
});

if ( jQuery.expr && jQuery.expr.filters ) {
  jQuery.expr.filters.animated = function( elem ) {
    return jQuery.grep(jQuery.timers, function( fn ) {
      return elem === fn.elem;
    }).length;
  };
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

  if ( !elemdisplay[ nodeName ] ) {

    var body = document.body,
      elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
      display = elem.css( "display" );
    elem.remove();

    // If the simple way fails,
    // get element's real default display by attaching it to a temp iframe
    if ( display === "none" || display === "" ) {
      // No iframe to use yet, so create it
      if ( !iframe ) {
        iframe = document.createElement( "iframe" );
        iframe.frameBorder = iframe.width = iframe.height = 0;
      }

      body.appendChild( iframe );

      // Create a cacheable copy of the iframe document on first call.
      // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
      // document to it; WebKit & Firefox won't allow reusing the iframe document.
      if ( !iframeDoc || !iframe.createElement ) {
        iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
        iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
        iframeDoc.close();
      }

      elem = iframeDoc.createElement( nodeName );

      iframeDoc.body.appendChild( elem );

      display = jQuery.css( elem, "display" );
      body.removeChild( iframe );
    }

    // Store the correct default display
    elemdisplay[ nodeName ] = display;
  }

  return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
  rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
  jQuery.fn.offset = function( options ) {
    var elem = this[0], box;

    if ( options ) {
      return this.each(function( i ) {
        jQuery.offset.setOffset( this, options, i );
      });
    }

    if ( !elem || !elem.ownerDocument ) {
      return null;
    }

    if ( elem === elem.ownerDocument.body ) {
      return jQuery.offset.bodyOffset( elem );
    }

    try {
      box = elem.getBoundingClientRect();
    } catch(e) {}

    var doc = elem.ownerDocument,
      docElem = doc.documentElement;

    // Make sure we're not dealing with a disconnected DOM node
    if ( !box || !jQuery.contains( docElem, elem ) ) {
      return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
    }

    var body = doc.body,
      win = getWindow(doc),
      clientTop  = docElem.clientTop  || body.clientTop  || 0,
      clientLeft = docElem.clientLeft || body.clientLeft || 0,
      scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
      scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
      top  = box.top  + scrollTop  - clientTop,
      left = box.left + scrollLeft - clientLeft;

    return { top: top, left: left };
  };

} else {
  jQuery.fn.offset = function( options ) {
    var elem = this[0];

    if ( options ) {
      return this.each(function( i ) {
        jQuery.offset.setOffset( this, options, i );
      });
    }

    if ( !elem || !elem.ownerDocument ) {
      return null;
    }

    if ( elem === elem.ownerDocument.body ) {
      return jQuery.offset.bodyOffset( elem );
    }

    var computedStyle,
      offsetParent = elem.offsetParent,
      prevOffsetParent = elem,
      doc = elem.ownerDocument,
      docElem = doc.documentElement,
      body = doc.body,
      defaultView = doc.defaultView,
      prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
      top = elem.offsetTop,
      left = elem.offsetLeft;

    while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
      if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
        break;
      }

      computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
      top  -= elem.scrollTop;
      left -= elem.scrollLeft;

      if ( elem === offsetParent ) {
        top  += elem.offsetTop;
        left += elem.offsetLeft;

        if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
          top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
          left += parseFloat( computedStyle.borderLeftWidth ) || 0;
        }

        prevOffsetParent = offsetParent;
        offsetParent = elem.offsetParent;
      }

      if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
        top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
        left += parseFloat( computedStyle.borderLeftWidth ) || 0;
      }

      prevComputedStyle = computedStyle;
    }

    if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
      top  += body.offsetTop;
      left += body.offsetLeft;
    }

    if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
      top  += Math.max( docElem.scrollTop, body.scrollTop );
      left += Math.max( docElem.scrollLeft, body.scrollLeft );
    }

    return { top: top, left: left };
  };
}

jQuery.offset = {

  bodyOffset: function( body ) {
    var top = body.offsetTop,
      left = body.offsetLeft;

    if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
      top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
      left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
    }

    return { top: top, left: left };
  },

  setOffset: function( elem, options, i ) {
    var position = jQuery.css( elem, "position" );

    // set position first, in-case top/left are set even on static elem
    if ( position === "static" ) {
      elem.style.position = "relative";
    }

    var curElem = jQuery( elem ),
      curOffset = curElem.offset(),
      curCSSTop = jQuery.css( elem, "top" ),
      curCSSLeft = jQuery.css( elem, "left" ),
      calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
      props = {}, curPosition = {}, curTop, curLeft;

    // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
    if ( calculatePosition ) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;
    } else {
      curTop = parseFloat( curCSSTop ) || 0;
      curLeft = parseFloat( curCSSLeft ) || 0;
    }

    if ( jQuery.isFunction( options ) ) {
      options = options.call( elem, i, curOffset );
    }

    if ( options.top != null ) {
      props.top = ( options.top - curOffset.top ) + curTop;
    }
    if ( options.left != null ) {
      props.left = ( options.left - curOffset.left ) + curLeft;
    }

    if ( "using" in options ) {
      options.using.call( elem, props );
    } else {
      curElem.css( props );
    }
  }
};


jQuery.fn.extend({

  position: function() {
    if ( !this[0] ) {
      return null;
    }

    var elem = this[0],

    // Get *real* offsetParent
    offsetParent = this.offsetParent(),

    // Get correct offsets
    offset       = this.offset(),
    parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

    // Subtract element margins
    // note: when an element has margin: auto the offsetLeft and marginLeft
    // are the same in Safari causing offset.left to incorrectly be 0
    offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
    offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

    // Add offsetParent borders
    parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
    parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

    // Subtract the two offsets
    return {
      top:  offset.top  - parentOffset.top,
      left: offset.left - parentOffset.left
    };
  },

  offsetParent: function() {
    return this.map(function() {
      var offsetParent = this.offsetParent || document.body;
      while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent;
    });
  }
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
  var method = "scroll" + name;

  jQuery.fn[ method ] = function( val ) {
    var elem, win;

    if ( val === undefined ) {
      elem = this[ 0 ];

      if ( !elem ) {
        return null;
      }

      win = getWindow( elem );

      // Return the scroll offset
      return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
        jQuery.support.boxModel && win.document.documentElement[ method ] ||
          win.document.body[ method ] :
        elem[ method ];
    }

    // Set the scroll offset
    return this.each(function() {
      win = getWindow( this );

      if ( win ) {
        win.scrollTo(
          !i ? val : jQuery( win ).scrollLeft(),
           i ? val : jQuery( win ).scrollTop()
        );

      } else {
        this[ method ] = val;
      }
    });
  };
});

function getWindow( elem ) {
  return jQuery.isWindow( elem ) ?
    elem :
    elem.nodeType === 9 ?
      elem.defaultView || elem.parentWindow :
      false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

  var type = name.toLowerCase();

  // innerHeight and innerWidth
  jQuery.fn[ "inner" + name ] = function() {
    var elem = this[0];
    return elem ?
      elem.style ?
      parseFloat( jQuery.css( elem, type, "padding" ) ) :
      this[ type ]() :
      null;
  };

  // outerHeight and outerWidth
  jQuery.fn[ "outer" + name ] = function( margin ) {
    var elem = this[0];
    return elem ?
      elem.style ?
      parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
      this[ type ]() :
      null;
  };

  jQuery.fn[ type ] = function( size ) {
    // Get window width or height
    var elem = this[0];
    if ( !elem ) {
      return size == null ? null : this;
    }

    if ( jQuery.isFunction( size ) ) {
      return this.each(function( i ) {
        var self = jQuery( this );
        self[ type ]( size.call( this, i, self[ type ]() ) );
      });
    }

    if ( jQuery.isWindow( elem ) ) {
      // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
      // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
      var docElemProp = elem.document.documentElement[ "client" + name ],
        body = elem.document.body;
      return elem.document.compatMode === "CSS1Compat" && docElemProp ||
        body && body[ "client" + name ] || docElemProp;

    // Get document width or height
    } else if ( elem.nodeType === 9 ) {
      // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
      return Math.max(
        elem.documentElement["client" + name],
        elem.body["scroll" + name], elem.documentElement["scroll" + name],
        elem.body["offset" + name], elem.documentElement["offset" + name]
      );

    // Get or set width or height on the element
    } else if ( size === undefined ) {
      var orig = jQuery.css( elem, type ),
        ret = parseFloat( orig );

      return jQuery.isNumeric( ret ) ? ret : orig;

    // Set the width or height on the element (default to pixels if value is unitless)
    } else {
      return this.css( type, typeof size === "string" ? size : size + "px" );
    }
  };

});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
  define( "jquery", [], function () { return jQuery; } );
}



})( window );;/*
 * JavaScript Pretty Date
 * Copyright (c) 2011 John Resig (ejohn.org)
 * Licensed under the MIT and GPL licenses.
 */

// Takes an ISO time and returns a string representing how
// long ago the date represents.
function prettyDate(time){
  var date = new Date((time || "").replace(/-/g,"/").replace(/[TZ]/g," ")),
    diff = (((new Date()).getTime() - date.getTime()) / 1000),
    day_diff = Math.floor(diff / 86400);

  if ( isNaN(day_diff) || day_diff < 0 || day_diff >= 31 )
    return;

  return day_diff == 0 && (
      diff < 60 && "just now" ||
      diff < 120 && "1 minute ago" ||
      diff < 3600 && Math.floor( diff / 60 ) + " minutes ago" ||
      diff < 7200 && "1 hour ago" ||
      diff < 86400 && Math.floor( diff / 3600 ) + " hours ago") ||
    day_diff == 1 && "Yesterday" ||
    day_diff < 7 && day_diff + " days ago" ||
    day_diff < 31 && Math.ceil( day_diff / 7 ) + " weeks ago";
}

// If jQuery is included in the page, adds a jQuery plugin to handle it as well
if ( typeof window.$ != "undefined" )
  window.$.fn.prettyDate = function(){
    return this.each(function(){
      var date = prettyDate(this.getAttribute('pubdate'));
      if ( date )
        $(this).text( date );
    });
  };;if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
    "use strict";
    if (this == null) {
      throw new TypeError();
    }
    var t = Object(this);
    var len = t.length >>> 0;
    if (len === 0) {
      return -1;
    }
    var n = 0;
    if (arguments.length > 0) {
      n = Number(arguments[1]);
      if (n != n) { // shortcut for verifying if it's NaN
        n = 0;
      } else if (n != 0 && n != Infinity && n != -Infinity) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }
    if (n >= len) {
      return -1;
    }
    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
    for (; k < len; k++) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  }
}

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.com/#x15.4.4.18
if ( !Array.prototype.forEach ) {

  Array.prototype.forEach = function( callback, thisArg ) {

    var T, k;

    if ( this == null ) {
      throw new TypeError( " this is null or not defined" );
    }

    // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0; // Hack to convert O.length to a UInt32

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if ( {}.toString.call(callback) != "[object Function]" ) {
      throw new TypeError( callback + " is not a function" );
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if ( thisArg ) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while( k < len ) {

      var kValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if ( k in O ) {

        // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
        kValue = O[ k ];

        // ii. Call the Call internal method of callback with T as the this value and
        // argument list containing kValue, k, and O.
        callback.call( T, kValue, k, O );
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

// https://gist.github.com/1035982
''.trim||(String.prototype.trim=function(){return this.replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g,'')});

if ( !Object.prototype.hasOwnProperty ) {
  Object.prototype.hasOwnProperty = function(prop) {
    var proto = obj.__proto__ || obj.constructor.prototype;
    return (prop in this) && (!(prop in proto) || proto[prop] !== this[prop]);
  };
}

Date.now||(Date.now=function(){return+new Date})

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
                                   || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = Date.now();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());

(function () {
  function Empty() {}
  var slice = [].slice;

  if (!Function.prototype.bind) {
      Function.prototype.bind = function bind(that) { // .length is 1
          // 1. Let Target be the this value.
          var target = this;
          // 2. If IsCallable(Target) is false, throw a TypeError exception.
          if (typeof target != "function") {
              throw new TypeError("Function.prototype.bind called on incompatible " + target);
          }
          // 3. Let A be a new (possibly empty) internal list of all of the
          //   argument values provided after thisArg (arg1, arg2 etc), in order.
          // XXX slicedArgs will stand in for "A" if used
          var args = slice.call(arguments, 1); // for normal call
          // 4. Let F be a new native ECMAScript object.
          // 11. Set the [[Prototype]] internal property of F to the standard
          //   built-in Function prototype object as specified in 15.3.3.1.
          // 12. Set the [[Call]] internal property of F as described in
          //   15.3.4.5.1.
          // 13. Set the [[Construct]] internal property of F as described in
          //   15.3.4.5.2.
          // 14. Set the [[HasInstance]] internal property of F as described in
          //   15.3.4.5.3.
          var bound = function () {

              if (this instanceof bound) {
                  // 15.3.4.5.2 [[Construct]]
                  // When the [[Construct]] internal method of a function object,
                  // F that was created using the bind function is called with a
                  // list of arguments ExtraArgs, the following steps are taken:
                  // 1. Let target be the value of F's [[TargetFunction]]
                  //   internal property.
                  // 2. If target has no [[Construct]] internal method, a
                  //   TypeError exception is thrown.
                  // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                  //   property.
                  // 4. Let args be a new list containing the same values as the
                  //   list boundArgs in the same order followed by the same
                  //   values as the list ExtraArgs in the same order.
                  // 5. Return the result of calling the [[Construct]] internal
                  //   method of target providing args as the arguments.

                  var result = target.apply(
                      this,
                      args.concat(slice.call(arguments))
                  );
                  if (Object(result) === result) {
                      return result;
                  }
                  return this;

              } else {
                  // 15.3.4.5.1 [[Call]]
                  // When the [[Call]] internal method of a function object, F,
                  // which was created using the bind function is called with a
                  // this value and a list of arguments ExtraArgs, the following
                  // steps are taken:
                  // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                  //   property.
                  // 2. Let boundThis be the value of F's [[BoundThis]] internal
                  //   property.
                  // 3. Let target be the value of F's [[TargetFunction]] internal
                  //   property.
                  // 4. Let args be a new list containing the same values as the
                  //   list boundArgs in the same order followed by the same
                  //   values as the list ExtraArgs in the same order.
                  // 5. Return the result of calling the [[Call]] internal method
                  //   of target providing boundThis as the this value and
                  //   providing args as the arguments.

                  // equiv: target.call(this, ...boundArgs, ...args)
                  return target.apply(
                      that,
                      args.concat(slice.call(arguments))
                  );

              }

          };
          if(target.prototype) {
              Empty.prototype = target.prototype;
              bound.prototype = new Empty();
              // Clean up dangling references.
              Empty.prototype = null;
          }
          // XXX bound.length is never writable, so don't even try
          //
          // 15. If the [[Class]] internal property of Target is "Function", then
          //     a. Let L be the length property of Target minus the length of A.
          //     b. Set the length own property of F to either 0 or L, whichever is
          //       larger.
          // 16. Else set the length own property of F to 0.
          // 17. Set the attributes of the length own property of F to the values
          //   specified in 15.3.5.1.

          // TODO
          // 18. Set the [[Extensible]] internal property of F to true.

          // TODO
          // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
          // 20. Call the [[DefineOwnProperty]] internal method of F with
          //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
          //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
          //   false.
          // 21. Call the [[DefineOwnProperty]] internal method of F with
          //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
          //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
          //   and false.

          // TODO
          // NOTE Function objects created using Function.prototype.bind do not
          // have a prototype property or the [[Code]], [[FormalParameters]], and
          // [[Scope]] internal properties.
          // XXX can't delete prototype in pure-js.

          // 22. Return F.
          return bound;
      };
  }
}());;/*!
 * JSHint, by JSHint Community.
 *
 * Licensed under the same slightly modified MIT license that JSLint is.
 * It stops evil-doers everywhere.
 *
 * JSHint is a derivative work of JSLint:
 *
 *   Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)
 *
 *   Permission is hereby granted, free of charge, to any person obtaining
 *   a copy of this software and associated documentation files (the "Software"),
 *   to deal in the Software without restriction, including without limitation
 *   the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *   and/or sell copies of the Software, and to permit persons to whom
 *   the Software is furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included
 *   in all copies or substantial portions of the Software.
 *
 *   The Software shall be used for Good, not Evil.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 * JSHint was forked from the 2010-12-16 edition of JSLint.
 *
 */

/*
 JSHINT is a global function. It takes two parameters.

     var myResult = JSHINT(source, option);

 The first parameter is either a string or an array of strings. If it is a
 string, it will be split on '\n' or '\r'. If it is an array of strings, it
 is assumed that each string represents one line. The source can be a
 JavaScript text or a JSON text.

 The second parameter is an optional object of options which control the
 operation of JSHINT. Most of the options are booleans: They are all
 optional and have a default value of false. One of the options, predef,
 can be an array of names, which will be used to declare global variables,
 or an object whose keys are used as global names, with a boolean value
 that determines if they are assignable.

 If it checks out, JSHINT returns true. Otherwise, it returns false.

 If false, you can inspect JSHINT.errors to find out the problems.
 JSHINT.errors is an array of objects containing these members:

 {
     line      : The line (relative to 1) at which the lint was found
     character : The character (relative to 1) at which the lint was found
     reason    : The problem
     evidence  : The text line in which the problem occurred
     raw       : The raw message before the details were inserted
     a         : The first detail
     b         : The second detail
     c         : The third detail
     d         : The fourth detail
 }

 If a fatal error was found, a null will be the last element of the
 JSHINT.errors array.

 You can request a data structure which contains JSHint's results.

     var myData = JSHINT.data();

 It returns a structure with this form:

 {
     errors: [
         {
             line: NUMBER,
             character: NUMBER,
             reason: STRING,
             evidence: STRING
         }
     ],
     functions: [
         name: STRING,
         line: NUMBER,
         character: NUMBER,
         last: NUMBER,
         lastcharacter: NUMBER,
         param: [
             STRING
         ],
         closure: [
             STRING
         ],
         var: [
             STRING
         ],
         exception: [
             STRING
         ],
         outer: [
             STRING
         ],
         unused: [
             STRING
         ],
         global: [
             STRING
         ],
         label: [
             STRING
         ]
     ],
     globals: [
         STRING
     ],
     member: {
         STRING: NUMBER
     },
     unused: [
         {
             name: STRING,
             line: NUMBER
         }
     ],
     implieds: [
         {
             name: STRING,
             line: NUMBER
         }
     ],
     urls: [
         STRING
     ],
     json: BOOLEAN
 }

 Empty arrays will not be included.

*/

/*jshint
 evil: true, nomen: false, onevar: false, regexp: false, strict: true, boss: true,
 undef: true, maxlen: 100, indent: 4, quotmark: double, unused: true
*/

/*members "\b", "\t", "\n", "\f", "\r", "!=", "!==", "\"", "%", "(begin)",
 "(breakage)", "(character)", "(context)", "(error)", "(explicitNewcap)", "(global)",
 "(identifier)", "(last)", "(lastcharacter)", "(line)", "(loopage)", "(metrics)",
 "(name)", "(onevar)", "(params)", "(scope)", "(statement)", "(verb)", "(tokens)",
 "*", "+", "++", "-", "--", "\/", "<", "<=", "==",
 "===", ">", ">=", $, $$, $A, $F, $H, $R, $break, $continue, $w, Abstract, Ajax,
 __filename, __dirname, ActiveXObject, Array, ArrayBuffer, ArrayBufferView, Audio,
 Autocompleter, Asset, Boolean, Builder, Buffer, Browser, COM, CScript, Canvas,
 CustomAnimation, Class, Control, ComplexityCount, Chain, Color, Cookie, Core, DataView, Date,
 Debug, Draggable, Draggables, Droppables, Document, DomReady, DOMEvent, DOMReady, DOMParser,
 Drag, E, Enumerator, Enumerable, Element, Elements, Error, Effect, EvalError, Event,
 Events, FadeAnimation, Field, Flash, Float32Array, Float64Array, Form,
 FormField, Frame, FormData, Function, Fx, GetObject, Group, Hash, HotKey,
 HTMLElement, HTMLAnchorElement, HTMLBaseElement, HTMLBlockquoteElement,
 HTMLBodyElement, HTMLBRElement, HTMLButtonElement, HTMLCanvasElement, HTMLDirectoryElement,
 HTMLDivElement, HTMLDListElement, HTMLFieldSetElement,
 HTMLFontElement, HTMLFormElement, HTMLFrameElement, HTMLFrameSetElement,
 HTMLHeadElement, HTMLHeadingElement, HTMLHRElement, HTMLHtmlElement,
 HTMLIFrameElement, HTMLImageElement, HTMLInputElement, HTMLIsIndexElement,
 HTMLLabelElement, HTMLLayerElement, HTMLLegendElement, HTMLLIElement,
 HTMLLinkElement, HTMLMapElement, HTMLMenuElement, HTMLMetaElement,
 HTMLModElement, HTMLObjectElement, HTMLOListElement, HTMLOptGroupElement,
 HTMLOptionElement, HTMLParagraphElement, HTMLParamElement, HTMLPreElement,
 HTMLQuoteElement, HTMLScriptElement, HTMLSelectElement, HTMLStyleElement,
 HtmlTable, HTMLTableCaptionElement, HTMLTableCellElement, HTMLTableColElement,
 HTMLTableElement, HTMLTableRowElement, HTMLTableSectionElement,
 HTMLTextAreaElement, HTMLTitleElement, HTMLUListElement, HTMLVideoElement,
 Iframe, IframeShim, Image, importScripts, Int16Array, Int32Array, Int8Array,
 Insertion, InputValidator, JSON, Keyboard, Locale, LN10, LN2, LOG10E, LOG2E,
 MAX_VALUE, MIN_VALUE, Map, Mask, Math, MenuItem, MessageChannel, MessageEvent, MessagePort,
 MoveAnimation, MooTools, MutationObserver, Native, NEGATIVE_INFINITY, Node, NodeFilter,
 Number, Object, ObjectRange,
 Option, Options, OverText, PI, POSITIVE_INFINITY, PeriodicalExecuter, Point, Position, Prototype,
 RangeError, Rectangle, ReferenceError, RegExp, ResizeAnimation, Request, RotateAnimation, Set,
 SQRT1_2, SQRT2, ScrollBar, ScriptEngine, ScriptEngineBuildVersion,
 ScriptEngineMajorVersion, ScriptEngineMinorVersion, Scriptaculous, Scroller,
 Slick, Slider, Selector, SharedWorker, String, Style, SyntaxError, Sortable, Sortables,
 SortableObserver, Sound, Spinner, System, Swiff, Text, TextArea, Template,
 Timer, Tips, Type, TypeError, Toggle, Try, "use strict", unescape, URI, URIError, URL,
 VBArray, WeakMap, WSH, WScript, XDomainRequest, Web, Window, XMLDOM, XMLHttpRequest, XMLSerializer,
 XPathEvaluator, XPathException, XPathExpression, XPathNamespace, XPathNSResolver, XPathResult,
 "\\", a, abs, addEventListener, address, alert, apply, applicationCache, arguments, arity,
 asi, atob, b, basic, basicToken, bitwise, blacklist, block, blur, boolOptions, boss,
 browser, btoa, c, call, callee, caller, camelcase, cases, charAt, charCodeAt, character,
 clearInterval, clearTimeout, close, closed, closure, comment, complexityCount, condition,
 confirm, console, constructor, content, couch, create, css, curly, d, data, datalist, dd, debug,
 decodeURI, decodeURIComponent, defaultStatus, defineClass, deserialize, devel, document,
 dojo, dijit, dojox, define, else, emit, encodeURI, encodeURIComponent, elem,
 eqeq, eqeqeq, eqnull, errors, es5, escape, esnext, eval, event, evidence, evil,
 ex, exception, exec, exps, expr, exports, FileReader, first, floor, focus, forEach,
 forin, fragment, frames, from, fromCharCode, fud, funcscope, funct, function, functions,
 g, gc, getComputedStyle, getRow, getter, getterToken, GLOBAL, global, globals, globalstrict,
 hasOwnProperty, help, history, i, id, identifier, immed, implieds, importPackage, include,
 indent, indexOf, init, ins, internals, instanceOf, isAlpha, isApplicationRunning, isArray,
 isDigit, isFinite, isNaN, iterator, java, join, jshint,
 JSHINT, json, jquery, jQuery, keys, label, labelled, last, lastcharacter, lastsemic, laxbreak,
 laxcomma, latedef, lbp, led, left, length, line, load, loadClass, localStorage, location,
 log, loopfunc, m, match, max, maxcomplexity, maxdepth, maxerr, maxlen, maxstatements, maxparams,
 member, message, meta, module, moveBy, moveTo, mootools, multistr, name, navigator, new, newcap,
 nestedBlockDepth, noarg, node, noempty, nomen, nonew, nonstandard, nud, onbeforeunload, onblur,
 onerror, onevar, onecase, onfocus, onload, onresize, onunload, open, openDatabase, openURL,
 opener, opera, options, outer, param, parent, parseFloat, parseInt, passfail, plusplus,
 postMessage, pop, predef, print, process, prompt, proto, prototype, prototypejs, provides, push,
 quit, quotmark, range, raw, reach, reason, regexp, readFile, readUrl, regexdash,
 removeEventListener, replace, report, require, reserved, resizeBy, resizeTo, resolvePath,
 resumeUpdates, respond, rhino, right, runCommand, scroll, scope, screen, scripturl, scrollBy,
 scrollTo, scrollbar, search, seal, self, send, serialize, sessionStorage, setInterval, setTimeout,
 setter, setterToken, shift, slice, smarttabs, sort, spawn, split, statementCount, stack, status,
 start, strict, sub, substr, supernew, shadow, supplant, sum, sync, test, toLowerCase, toString,
 toUpperCase, toint32, token, tokens, top, trailing, type, typeOf, Uint16Array, Uint32Array,
 Uint8Array, undef, undefs, unused, urls, validthis, value, valueOf, var, vars, version,
 verifyMaxParametersPerFunction, verifyMaxStatementsPerFunction, verifyMaxComplexityPerFunction,
 verifyMaxNestedBlockDepthPerFunction, WebSocket, withstmt, white, window, windows, Worker, worker,
 wsh*/

/*global exports: false */

// We build the application inside a function so that we produce only a single
// global variable. That function will be invoked immediately, and its return
// value is the JSHINT function itself.

var JSHINT = (function () {
    "use strict";

    var anonname,       // The guessed name for anonymous functions.

// These are operators that should not be used with the ! operator.

        bang = {
            "<"  : true,
            "<=" : true,
            "==" : true,
            "===": true,
            "!==": true,
            "!=" : true,
            ">"  : true,
            ">=" : true,
            "+"  : true,
            "-"  : true,
            "*"  : true,
            "/"  : true,
            "%"  : true
        },

        // These are the JSHint boolean options.
        boolOptions = {
            asi         : true, // if automatic semicolon insertion should be tolerated
            bitwise     : true, // if bitwise operators should not be allowed
            boss        : true, // if advanced usage of assignments should be allowed
            browser     : true, // if the standard browser globals should be predefined
            camelcase   : true, // if identifiers should be required in camel case
            couch       : true, // if CouchDB globals should be predefined
            curly       : true, // if curly braces around all blocks should be required
            debug       : true, // if debugger statements should be allowed
            devel       : true, // if logging globals should be predefined (console,
                                // alert, etc.)
            dojo        : true, // if Dojo Toolkit globals should be predefined
            eqeqeq      : true, // if === should be required
            eqnull      : true, // if == null comparisons should be tolerated
            es5         : true, // if ES5 syntax should be allowed
            esnext      : true, // if es.next specific syntax should be allowed
            evil        : true, // if eval should be allowed
            expr        : true, // if ExpressionStatement should be allowed as Programs
            forin       : true, // if for in statements must filter
            funcscope   : true, // if only function scope should be used for scope tests
            globalstrict: true, // if global "use strict"; should be allowed (also
                                // enables 'strict')
            immed       : true, // if immediate invocations must be wrapped in parens
            iterator    : true, // if the `__iterator__` property should be allowed
            jquery      : true, // if jQuery globals should be predefined
            lastsemic   : true, // if semicolons may be ommitted for the trailing
                                // statements inside of a one-line blocks.
            latedef     : true, // if the use before definition should not be tolerated
            laxbreak    : true, // if line breaks should not be checked
            laxcomma    : true, // if line breaks should not be checked around commas
            loopfunc    : true, // if functions should be allowed to be defined within
                                // loops
            mootools    : true, // if MooTools globals should be predefined
            multistr    : true, // allow multiline strings
            newcap      : true, // if constructor names must be capitalized
            noarg       : true, // if arguments.caller and arguments.callee should be
                                // disallowed
            node        : true, // if the Node.js environment globals should be
                                // predefined
            noempty     : true, // if empty blocks should be disallowed
            nonew       : true, // if using `new` for side-effects should be disallowed
            nonstandard : true, // if non-standard (but widely adopted) globals should
                                // be predefined
            nomen       : true, // if names should be checked
            onevar      : true, // if only one var statement per function should be
                                // allowed
            onecase     : true, // if one case switch statements should be allowed
            passfail    : true, // if the scan should stop on first error
            plusplus    : true, // if increment/decrement should not be allowed
            proto       : true, // if the `__proto__` property should be allowed
            prototypejs : true, // if Prototype and Scriptaculous globals should be
                                // predefined
            regexdash   : true, // if unescaped first/last dash (-) inside brackets
                                // should be tolerated
            regexp      : true, // if the . should not be allowed in regexp literals
            rhino       : true, // if the Rhino environment globals should be predefined
            undef       : true, // if variables should be declared before used
            unused      : true, // if variables should be always used
            scripturl   : true, // if script-targeted URLs should be tolerated
            shadow      : true, // if variable shadowing should be tolerated
            smarttabs   : true, // if smarttabs should be tolerated
                                // (http://www.emacswiki.org/emacs/SmartTabs)
            strict      : true, // require the "use strict"; pragma
            sub         : true, // if all forms of subscript notation are tolerated
            supernew    : true, // if `new function () { ... };` and `new Object;`
                                // should be tolerated
            trailing    : true, // if trailing whitespace rules apply
            validthis   : true, // if 'this' inside a non-constructor function is valid.
                                // This is a function scoped option only.
            withstmt    : true, // if with statements should be allowed
            white       : true, // if strict whitespace rules apply
            worker      : true, // if Web Worker script symbols should be allowed
            wsh         : true  // if the Windows Scripting Host environment globals
                                // should be predefined
        },

        // These are the JSHint options that can take any value
        // (we use this object to detect invalid options)
        valOptions = {
            maxlen       : false,
            indent       : false,
            maxerr       : false,
            predef       : false,
            quotmark     : false, //'single'|'double'|true
            scope        : false,
            maxstatements: false, // {int} max statements per function
            maxdepth     : false, // {int} max nested block depth per function
            maxparams    : false, // {int} max params per function
            maxcomplexity: false  // {int} max cyclomatic complexity per function
        },

        // These are JSHint boolean options which are shared with JSLint
        // where the definition in JSHint is opposite JSLint
        invertedOptions = {
            bitwise     : true,
            forin       : true,
            newcap      : true,
            nomen       : true,
            plusplus    : true,
            regexp      : true,
            undef       : true,
            white       : true,

            // Inverted and renamed, use JSHint name here
            eqeqeq      : true,
            onevar      : true
        },

        // These are JSHint boolean options which are shared with JSLint
        // where the name has been changed but the effect is unchanged
        renamedOptions = {
            eqeq        : "eqeqeq",
            vars        : "onevar",
            windows     : "wsh"
        },


        // browser contains a set of global names which are commonly provided by a
        // web browser environment.
        browser = {
            ArrayBuffer              :  false,
            ArrayBufferView          :  false,
            Audio                    :  false,
            addEventListener         :  false,
            applicationCache         :  false,
            atob                     :  false,
            blur                     :  false,
            btoa                     :  false,
            clearInterval            :  false,
            clearTimeout             :  false,
            close                    :  false,
            closed                   :  false,
            DataView                 :  false,
            DOMParser                :  false,
            defaultStatus            :  false,
            document                 :  false,
            event                    :  false,
            FileReader               :  false,
            Float32Array             :  false,
            Float64Array             :  false,
            FormData                 :  false,
            focus                    :  false,
            frames                   :  false,
            getComputedStyle         :  false,
            HTMLElement              :  false,
            HTMLAnchorElement        :  false,
            HTMLBaseElement          :  false,
            HTMLBlockquoteElement    :  false,
            HTMLBodyElement          :  false,
            HTMLBRElement            :  false,
            HTMLButtonElement        :  false,
            HTMLCanvasElement        :  false,
            HTMLDirectoryElement     :  false,
            HTMLDivElement           :  false,
            HTMLDListElement         :  false,
            HTMLFieldSetElement      :  false,
            HTMLFontElement          :  false,
            HTMLFormElement          :  false,
            HTMLFrameElement         :  false,
            HTMLFrameSetElement      :  false,
            HTMLHeadElement          :  false,
            HTMLHeadingElement       :  false,
            HTMLHRElement            :  false,
            HTMLHtmlElement          :  false,
            HTMLIFrameElement        :  false,
            HTMLImageElement         :  false,
            HTMLInputElement         :  false,
            HTMLIsIndexElement       :  false,
            HTMLLabelElement         :  false,
            HTMLLayerElement         :  false,
            HTMLLegendElement        :  false,
            HTMLLIElement            :  false,
            HTMLLinkElement          :  false,
            HTMLMapElement           :  false,
            HTMLMenuElement          :  false,
            HTMLMetaElement          :  false,
            HTMLModElement           :  false,
            HTMLObjectElement        :  false,
            HTMLOListElement         :  false,
            HTMLOptGroupElement      :  false,
            HTMLOptionElement        :  false,
            HTMLParagraphElement     :  false,
            HTMLParamElement         :  false,
            HTMLPreElement           :  false,
            HTMLQuoteElement         :  false,
            HTMLScriptElement        :  false,
            HTMLSelectElement        :  false,
            HTMLStyleElement         :  false,
            HTMLTableCaptionElement  :  false,
            HTMLTableCellElement     :  false,
            HTMLTableColElement      :  false,
            HTMLTableElement         :  false,
            HTMLTableRowElement      :  false,
            HTMLTableSectionElement  :  false,
            HTMLTextAreaElement      :  false,
            HTMLTitleElement         :  false,
            HTMLUListElement         :  false,
            HTMLVideoElement         :  false,
            history                  :  false,
            Int16Array               :  false,
            Int32Array               :  false,
            Int8Array                :  false,
            Image                    :  false,
            length                   :  false,
            localStorage             :  false,
            location                 :  false,
            MessageChannel           :  false,
            MessageEvent             :  false,
            MessagePort              :  false,
            moveBy                   :  false,
            moveTo                   :  false,
            MutationObserver         :  false,
            name                     :  false,
            Node                     :  false,
            NodeFilter               :  false,
            navigator                :  false,
            onbeforeunload           :  true,
            onblur                   :  true,
            onerror                  :  true,
            onfocus                  :  true,
            onload                   :  true,
            onresize                 :  true,
            onunload                 :  true,
            open                     :  false,
            openDatabase             :  false,
            opener                   :  false,
            Option                   :  false,
            parent                   :  false,
            print                    :  false,
            removeEventListener      :  false,
            resizeBy                 :  false,
            resizeTo                 :  false,
            screen                   :  false,
            scroll                   :  false,
            scrollBy                 :  false,
            scrollTo                 :  false,
            sessionStorage           :  false,
            setInterval              :  false,
            setTimeout               :  false,
            SharedWorker             :  false,
            status                   :  false,
            top                      :  false,
            Uint16Array              :  false,
            Uint32Array              :  false,
            Uint8Array               :  false,
            WebSocket                :  false,
            window                   :  false,
            Worker                   :  false,
            XMLHttpRequest           :  false,
            XMLSerializer            :  false,
            XPathEvaluator           :  false,
            XPathException           :  false,
            XPathExpression          :  false,
            XPathNamespace           :  false,
            XPathNSResolver          :  false,
            XPathResult              :  false
        },

        couch = {
            "require" : false,
            respond   : false,
            getRow    : false,
            emit      : false,
            send      : false,
            start     : false,
            sum       : false,
            log       : false,
            exports   : false,
            module    : false,
            provides  : false
        },

        declared, // Globals that were declared using /*global ... */ syntax.

        devel = {
            alert   : false,
            confirm : false,
            console : false,
            Debug   : false,
            opera   : false,
            prompt  : false
        },

        dojo = {
            dojo      : false,
            dijit     : false,
            dojox     : false,
            define    : false,
            "require" : false
        },

        funct,          // The current function

        functionicity = [
            "closure", "exception", "global", "label",
            "outer", "unused", "var"
        ],

        functions,      // All of the functions

        global,         // The global scope
        implied,        // Implied globals
        inblock,
        indent,
        jsonmode,

        jquery = {
            "$"    : false,
            jQuery : false
        },

        lines,
        lookahead,
        member,
        membersOnly,

        mootools = {
            "$"             : false,
            "$$"            : false,
            Asset           : false,
            Browser         : false,
            Chain           : false,
            Class           : false,
            Color           : false,
            Cookie          : false,
            Core            : false,
            Document        : false,
            DomReady        : false,
            DOMEvent        : false,
            DOMReady        : false,
            Drag            : false,
            Element         : false,
            Elements        : false,
            Event           : false,
            Events          : false,
            Fx              : false,
            Group           : false,
            Hash            : false,
            HtmlTable       : false,
            Iframe          : false,
            IframeShim      : false,
            InputValidator  : false,
            instanceOf      : false,
            Keyboard        : false,
            Locale          : false,
            Mask            : false,
            MooTools        : false,
            Native          : false,
            Options         : false,
            OverText        : false,
            Request         : false,
            Scroller        : false,
            Slick           : false,
            Slider          : false,
            Sortables       : false,
            Spinner         : false,
            Swiff           : false,
            Tips            : false,
            Type            : false,
            typeOf          : false,
            URI             : false,
            Window          : false
        },

        nexttoken,

        node = {
            __filename    : false,
            __dirname     : false,
            Buffer        : false,
            console       : false,
            exports       : true,  // In Node it is ok to exports = module.exports = foo();
            GLOBAL        : false,
            global        : false,
            module        : false,
            process       : false,
            require       : false,
            setTimeout    : false,
            clearTimeout  : false,
            setInterval   : false,
            clearInterval : false
        },

        noreach,
        option,
        predefined,     // Global variables defined by option
        prereg,
        prevtoken,

        prototypejs = {
            "$"               : false,
            "$$"              : false,
            "$A"              : false,
            "$F"              : false,
            "$H"              : false,
            "$R"              : false,
            "$break"          : false,
            "$continue"       : false,
            "$w"              : false,
            Abstract          : false,
            Ajax              : false,
            Class             : false,
            Enumerable        : false,
            Element           : false,
            Event             : false,
            Field             : false,
            Form              : false,
            Hash              : false,
            Insertion         : false,
            ObjectRange       : false,
            PeriodicalExecuter: false,
            Position          : false,
            Prototype         : false,
            Selector          : false,
            Template          : false,
            Toggle            : false,
            Try               : false,
            Autocompleter     : false,
            Builder           : false,
            Control           : false,
            Draggable         : false,
            Draggables        : false,
            Droppables        : false,
            Effect            : false,
            Sortable          : false,
            SortableObserver  : false,
            Sound             : false,
            Scriptaculous     : false
        },

        quotmark,

        rhino = {
            defineClass  : false,
            deserialize  : false,
            gc           : false,
            help         : false,
            importPackage: false,
            "java"       : false,
            load         : false,
            loadClass    : false,
            print        : false,
            quit         : false,
            readFile     : false,
            readUrl      : false,
            runCommand   : false,
            seal         : false,
            serialize    : false,
            spawn        : false,
            sync         : false,
            toint32      : false,
            version      : false
        },

        scope,      // The current scope
        stack,

        // standard contains the global names that are provided by the
        // ECMAScript standard.
        standard = {
            Array               : false,
            Boolean             : false,
            Date                : false,
            decodeURI           : false,
            decodeURIComponent  : false,
            encodeURI           : false,
            encodeURIComponent  : false,
            Error               : false,
            "eval"              : false,
            EvalError           : false,
            Function            : false,
            hasOwnProperty      : false,
            isFinite            : false,
            isNaN               : false,
            JSON                : false,
            Map                 : false,
            Math                : false,
            Number              : false,
            Object              : false,
            parseInt            : false,
            parseFloat          : false,
            RangeError          : false,
            ReferenceError      : false,
            RegExp              : false,
            Set                 : false,
            String              : false,
            SyntaxError         : false,
            TypeError           : false,
            URIError            : false,
            WeakMap             : false
        },

        // widely adopted global names that are not part of ECMAScript standard
        nonstandard = {
            escape              : false,
            unescape            : false
        },

        directive,
        syntax = {},
        tab,
        token,
        unuseds,
        urls,
        useESNextSyntax,
        warnings,

        worker = {
            importScripts       : true,
            postMessage         : true,
            self                : true
        },

        wsh = {
            ActiveXObject             : true,
            Enumerator                : true,
            GetObject                 : true,
            ScriptEngine              : true,
            ScriptEngineBuildVersion  : true,
            ScriptEngineMajorVersion  : true,
            ScriptEngineMinorVersion  : true,
            VBArray                   : true,
            WSH                       : true,
            WScript                   : true,
            XDomainRequest            : true
        };

    // Regular expressions. Some of these are stupidly long.
    var ax, cx, tx, nx, nxg, lx, ix, jx, ft;
    (function () {
        /*jshint maxlen:300 */

        // unsafe comment or string
        ax = /@cc|<\/?|script|\]\s*\]|<\s*!|&lt/i;

        // unsafe characters that are silently deleted by one or more browsers
        cx = /[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;

        // token
        tx = /^\s*([(){}\[.,:;'"~\?\]#@]|==?=?|\/(\*(jshint|jslint|members?|global)?|=|\/)?|\*[\/=]?|\+(?:=|\++)?|-(?:=|-+)?|%=?|&[&=]?|\|[|=]?|>>?>?=?|<([\/=!]|\!(\[|--)?|<=?)?|\^=?|\!=?=?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+([xX][0-9a-fA-F]+|\.[0-9]*)?([eE][+\-]?[0-9]+)?)/;

        // characters in strings that need escapement
        nx = /[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;
        nxg = /[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

        // star slash
        lx = /\*\//;

        // identifier
        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;

        // javascript url
        jx = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\s*:/i;

        // catches /* falls through */ comments
        ft = /^\s*\/\*\s*falls\sthrough\s*\*\/\s*$/;
    }());

    function F() {}     // Used by Object.create

    function is_own(object, name) {
        // The object.hasOwnProperty method fails when the property under consideration
        // is named 'hasOwnProperty'. So we have to use this more convoluted form.
        return Object.prototype.hasOwnProperty.call(object, name);
    }

    function checkOption(name, t) {
        if (valOptions[name] === undefined && boolOptions[name] === undefined) {
            warning("Bad option: '" + name + "'.", t);
        }
    }

    function isString(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
    }

    // Provide critical ES5 functions to ES3.

    if (typeof Array.isArray !== "function") {
        Array.isArray = function (o) {
            return Object.prototype.toString.apply(o) === "[object Array]";
        };
    }

    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function (fn, scope) {
            var len = this.length;

            for (var i = 0; i < len; i++) {
                fn.call(scope || this, this[i], i, this);
            }
        };
    }

    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            if (this === null || this === undefined) {
                throw new TypeError();
            }

            var t = new Object(this);
            var len = t.length >>> 0;

            if (len === 0) {
                return -1;
            }

            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n !== 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }

            if (n >= len) {
                return -1;
            }

            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }

            return -1;
        };
    }

    if (typeof Object.create !== "function") {
        Object.create = function (o) {
            F.prototype = o;
            return new F();
        };
    }

    if (typeof Object.keys !== "function") {
        Object.keys = function (o) {
            var a = [], k;
            for (k in o) {
                if (is_own(o, k)) {
                    a.push(k);
                }
            }
            return a;
        };
    }

    // Non standard methods

    function isAlpha(str) {
        return (str >= "a" && str <= "z\uffff") ||
            (str >= "A" && str <= "Z\uffff");
    }

    function isDigit(str) {
        return (str >= "0" && str <= "9");
    }

    function supplant(str, data) {
        return str.replace(/\{([^{}]*)\}/g, function (a, b) {
            var r = data[b];
            return typeof r === "string" || typeof r === "number" ? r : a;
        });
    }

    function combine(t, o) {
        var n;
        for (n in o) {
            if (is_own(o, n) && !is_own(JSHINT.blacklist, n)) {
                t[n] = o[n];
            }
        }
    }

    function updatePredefined() {
        Object.keys(JSHINT.blacklist).forEach(function (key) {
            delete predefined[key];
        });
    }

    function assume() {
        if (option.couch) {
            combine(predefined, couch);
        }

        if (option.rhino) {
            combine(predefined, rhino);
        }

        if (option.prototypejs) {
            combine(predefined, prototypejs);
        }

        if (option.node) {
            combine(predefined, node);
            option.globalstrict = true;
        }

        if (option.devel) {
            combine(predefined, devel);
        }

        if (option.dojo) {
            combine(predefined, dojo);
        }

        if (option.browser) {
            combine(predefined, browser);
        }

        if (option.nonstandard) {
            combine(predefined, nonstandard);
        }

        if (option.jquery) {
            combine(predefined, jquery);
        }

        if (option.mootools) {
            combine(predefined, mootools);
        }

        if (option.worker) {
            combine(predefined, worker);
        }

        if (option.wsh) {
            combine(predefined, wsh);
        }

        if (option.esnext) {
            useESNextSyntax();
        }

        if (option.globalstrict && option.strict !== false) {
            option.strict = true;
        }
    }


    // Produce an error warning.
    function quit(message, line, chr) {
        var percentage = Math.floor((line / lines.length) * 100);

        throw {
            name: "JSHintError",
            line: line,
            character: chr,
            message: message + " (" + percentage + "% scanned).",
            raw: message
        };
    }

    function isundef(scope, m, t, a) {
        return JSHINT.undefs.push([scope, m, t, a]);
    }

    function warning(m, t, a, b, c, d) {
        var ch, l, w;
        t = t || nexttoken;
        if (t.id === "(end)") {  // `~
            t = token;
        }
        l = t.line || 0;
        ch = t.from || 0;
        w = {
            id: "(error)",
            raw: m,
            evidence: lines[l - 1] || "",
            line: l,
            character: ch,
            scope: JSHINT.scope,
            a: a,
            b: b,
            c: c,
            d: d
        };
        w.reason = supplant(m, w);
        JSHINT.errors.push(w);
        if (option.passfail) {
            quit("Stopping. ", l, ch);
        }
        warnings += 1;
        if (warnings >= option.maxerr) {
            quit("Too many errors.", l, ch);
        }
        return w;
    }

    function warningAt(m, l, ch, a, b, c, d) {
        return warning(m, {
            line: l,
            from: ch
        }, a, b, c, d);
    }

    function error(m, t, a, b, c, d) {
        warning(m, t, a, b, c, d);
    }

    function errorAt(m, l, ch, a, b, c, d) {
        return error(m, {
            line: l,
            from: ch
        }, a, b, c, d);
    }

    // Tracking of "internal" scripts, like eval containing a static string
    function addInternalSrc(elem, src) {
        var i;
        i = {
            id: "(internal)",
            elem: elem,
            value: src
        };
        JSHINT.internals.push(i);
        return i;
    }


// lexical analysis and token construction

    var lex = (function lex() {
        var character, from, line, s;

// Private lex methods

        function nextLine() {
            var at,
                tw; // trailing whitespace check

            if (line >= lines.length)
                return false;

            character = 1;
            s = lines[line];
            line += 1;

            // If smarttabs option is used check for spaces followed by tabs only.
            // Otherwise check for any occurence of mixed tabs and spaces.
            // Tabs and one space followed by block comment is allowed.
            if (option.smarttabs)
                at = s.search(/ \t/);
            else
                at = s.search(/ \t|\t [^\*]/);

            if (at >= 0)
                warningAt("Mixed spaces and tabs.", line, at + 1);

            s = s.replace(/\t/g, tab);
            at = s.search(cx);

            if (at >= 0)
                warningAt("Unsafe character.", line, at);

            if (option.maxlen && option.maxlen < s.length)
                warningAt("Line too long.", line, s.length);

            // Check for trailing whitespaces
            tw = option.trailing && s.match(/^(.*?)\s+$/);
            if (tw && !/^\s+$/.test(s)) {
                warningAt("Trailing whitespace.", line, tw[1].length + 1);
            }
            return true;
        }

// Produce a token object.  The token inherits from a syntax symbol.

        function it(type, value) {
            var i, t;

            function checkName(name) {
                if (!option.proto && name === "__proto__") {
                    warningAt("The '{a}' property is deprecated.", line, from, name);
                    return;
                }

                if (!option.iterator && name === "__iterator__") {
                    warningAt("'{a}' is only available in JavaScript 1.7.", line, from, name);
                    return;
                }

                // Check for dangling underscores unless we're in Node
                // environment and this identifier represents built-in
                // Node globals with underscores.

                var hasDangling = /^(_+.*|.*_+)$/.test(name);

                if (option.nomen && hasDangling && name !== "_") {
                    if (option.node && token.id !== "." && /^(__dirname|__filename)$/.test(name))
                        return;

                    warningAt("Unexpected {a} in '{b}'.", line, from, "dangling '_'", name);
                    return;
                }

                // Check for non-camelcase names. Names like MY_VAR and
                // _myVar are okay though.

                if (option.camelcase) {
                    if (name.replace(/^_+/, "").indexOf("_") > -1 && !name.match(/^[A-Z0-9_]*$/)) {
                        warningAt("Identifier '{a}' is not in camel case.", line, from, value);
                    }
                }
            }

            if (type === "(color)" || type === "(range)") {
                t = {type: type};
            } else if (type === "(punctuator)" ||
                    (type === "(identifier)" && is_own(syntax, value))) {
                t = syntax[value] || syntax["(error)"];
            } else {
                t = syntax[type];
            }

            t = Object.create(t);

            if (type === "(string)" || type === "(range)") {
                if (!option.scripturl && jx.test(value)) {
                    warningAt("Script URL.", line, from);
                }
            }

            if (type === "(identifier)") {
                t.identifier = true;
                checkName(value);
            }

            t.value = value;
            t.line = line;
            t.character = character;
            t.from = from;
            i = t.id;
            if (i !== "(endline)") {
                prereg = i &&
                    (("(,=:[!&|?{};".indexOf(i.charAt(i.length - 1)) >= 0) ||
                    i === "return" ||
                    i === "case");
            }
            return t;
        }

        // Public lex methods
        return {
            init: function (source) {
                if (typeof source === "string") {
                    lines = source
                        .replace(/\r\n/g, "\n")
                        .replace(/\r/g, "\n")
                        .split("\n");
                } else {
                    lines = source;
                }

                // If the first line is a shebang (#!), make it a blank and move on.
                // Shebangs are used by Node scripts.
                if (lines[0] && lines[0].substr(0, 2) === "#!")
                    lines[0] = "";

                line = 0;
                nextLine();
                from = 1;
            },

            range: function (begin, end) {
                var c, value = "";
                from = character;
                if (s.charAt(0) !== begin) {
                    errorAt("Expected '{a}' and instead saw '{b}'.",
                            line, character, begin, s.charAt(0));
                }
                for (;;) {
                    s = s.slice(1);
                    character += 1;
                    c = s.charAt(0);
                    switch (c) {
                    case "":
                        errorAt("Missing '{a}'.", line, character, c);
                        break;
                    case end:
                        s = s.slice(1);
                        character += 1;
                        return it("(range)", value);
                    case "\\":
                        warningAt("Unexpected '{a}'.", line, character, c);
                    }
                    value += c;
                }

            },


            // token -- this is called by advance to get the next token
            token: function () {
                var b, c, captures, d, depth, high, i, l, low, q, t, isLiteral, isInRange, n;

                function match(x) {
                    var r = x.exec(s), r1;
                    if (r) {
                        l = r[0].length;
                        r1 = r[1];
                        c = r1.charAt(0);
                        s = s.substr(l);
                        from = character + l - r1.length;
                        character += l;
                        return r1;
                    }
                }

                function string(x) {
                    var c, j, r = "", allowNewLine = false;

                    if (jsonmode && x !== "\"") {
                        warningAt("Strings must use doublequote.",
                                line, character);
                    }

                    if (option.quotmark) {
                        if (option.quotmark === "single" && x !== "'") {
                            warningAt("Strings must use singlequote.",
                                    line, character);
                        } else if (option.quotmark === "double" && x !== "\"") {
                            warningAt("Strings must use doublequote.",
                                    line, character);
                        } else if (option.quotmark === true) {
                            quotmark = quotmark || x;
                            if (quotmark !== x) {
                                warningAt("Mixed double and single quotes.",
                                        line, character);
                            }
                        }
                    }

                    function esc(n) {
                        var i = parseInt(s.substr(j + 1, n), 16);
                        j += n;
                        if (i >= 32 && i <= 126 &&
                                i !== 34 && i !== 92 && i !== 39) {
                            warningAt("Unnecessary escapement.", line, character);
                        }
                        character += n;
                        c = String.fromCharCode(i);
                    }
                    j = 0;
unclosedString:     for (;;) {
                        while (j >= s.length) {
                            j = 0;

                            var cl = line, cf = from;
                            if (!nextLine()) {
                                errorAt("Unclosed string.", cl, cf);
                                break unclosedString;
                            }

                            if (allowNewLine) {
                                allowNewLine = false;
                            } else {
                                warningAt("Unclosed string.", cl, cf);
                            }
                        }
                        c = s.charAt(j);
                        if (c === x) {
                            character += 1;
                            s = s.substr(j + 1);
                            return it("(string)", r, x);
                        }
                        if (c < " ") {
                            if (c === "\n" || c === "\r") {
                                break;
                            }
                            warningAt("Control character in string: {a}.",
                                    line, character + j, s.slice(0, j));
                        } else if (c === "\\") {
                            j += 1;
                            character += 1;
                            c = s.charAt(j);
                            n = s.charAt(j + 1);
                            switch (c) {
                            case "\\":
                            case "\"":
                            case "/":
                                break;
                            case "\'":
                                if (jsonmode) {
                                    warningAt("Avoid \\'.", line, character);
                                }
                                break;
                            case "b":
                                c = "\b";
                                break;
                            case "f":
                                c = "\f";
                                break;
                            case "n":
                                c = "\n";
                                break;
                            case "r":
                                c = "\r";
                                break;
                            case "t":
                                c = "\t";
                                break;
                            case "0":
                                c = "\0";
                                // Octal literals fail in strict mode
                                // check if the number is between 00 and 07
                                // where 'n' is the token next to 'c'
                                if (n >= 0 && n <= 7 && directive["use strict"]) {
                                    warningAt(
                                    "Octal literals are not allowed in strict mode.",
                                    line, character);
                                }
                                break;
                            case "u":
                                esc(4);
                                break;
                            case "v":
                                if (jsonmode) {
                                    warningAt("Avoid \\v.", line, character);
                                }
                                c = "\v";
                                break;
                            case "x":
                                if (jsonmode) {
                                    warningAt("Avoid \\x-.", line, character);
                                }
                                esc(2);
                                break;
                            case "":
                                // last character is escape character
                                // always allow new line if escaped, but show
                                // warning if option is not set
                                allowNewLine = true;
                                if (option.multistr) {
                                    if (jsonmode) {
                                        warningAt("Avoid EOL escapement.", line, character);
                                    }
                                    c = "";
                                    character -= 1;
                                    break;
                                }
                                warningAt("Bad escapement of EOL. Use option multistr if needed.",
                                    line, character);
                                break;
                            default:
                                warningAt("Bad escapement.", line, character);
                            }
                        }
                        r += c;
                        character += 1;
                        j += 1;
                    }
                }

                for (;;) {
                    if (!s) {
                        return it(nextLine() ? "(endline)" : "(end)", "");
                    }
                    t = match(tx);
                    if (!t) {
                        t = "";
                        c = "";
                        while (s && s < "!") {
                            s = s.substr(1);
                        }
                        if (s) {
                            errorAt("Unexpected '{a}'.", line, character, s.substr(0, 1));
                            s = "";
                        }
                    } else {

    //      identifier

                        if (isAlpha(c) || c === "_" || c === "$") {
                            return it("(identifier)", t);
                        }

    //      number

                        if (isDigit(c)) {
                            if (!isFinite(Number(t))) {
                                warningAt("Bad number '{a}'.",
                                    line, character, t);
                            }
                            if (isAlpha(s.substr(0, 1))) {
                                warningAt("Missing space after '{a}'.",
                                        line, character, t);
                            }
                            if (c === "0") {
                                d = t.substr(1, 1);
                                if (isDigit(d)) {
                                    if (token.id !== ".") {
                                        warningAt("Don't use extra leading zeros '{a}'.",
                                            line, character, t);
                                    }
                                } else if (jsonmode && (d === "x" || d === "X")) {
                                    warningAt("Avoid 0x-. '{a}'.",
                                            line, character, t);
                                }
                            }
                            if (t.substr(t.length - 1) === ".") {
                                warningAt(
"A trailing decimal point can be confused with a dot '{a}'.", line, character, t);
                            }
                            return it("(number)", t);
                        }
                        switch (t) {

    //      string

                        case "\"":
                        case "'":
                            return string(t);

    //      // comment

                        case "//":
                            s = "";
                            token.comment = true;
                            break;

    //      /* comment

                        case "/*":
                            for (;;) {
                                i = s.search(lx);
                                if (i >= 0) {
                                    break;
                                }
                                if (!nextLine()) {
                                    errorAt("Unclosed comment.", line, character);
                                }
                            }
                            s = s.substr(i + 2);
                            token.comment = true;
                            break;

    //      /*members /*jshint /*global

                        case "/*members":
                        case "/*member":
                        case "/*jshint":
                        case "/*jslint":
                        case "/*global":
                        case "*/":
                            return {
                                value: t,
                                type: "special",
                                line: line,
                                character: character,
                                from: from
                            };

                        case "":
                            break;
    //      /
                        case "/":
                            if (token.id === "/=") {
                                errorAt("A regular expression literal can be confused with '/='.",
                                    line, from);
                            }
                            if (prereg) {
                                depth = 0;
                                captures = 0;
                                l = 0;
                                for (;;) {
                                    b = true;
                                    c = s.charAt(l);
                                    l += 1;
                                    switch (c) {
                                    case "":
                                        errorAt("Unclosed regular expression.", line, from);
                                        return quit("Stopping.", line, from);
                                    case "/":
                                        if (depth > 0) {
                                            warningAt("{a} unterminated regular expression " +
                                                "group(s).", line, from + l, depth);
                                        }
                                        c = s.substr(0, l - 1);
                                        q = {
                                            g: true,
                                            i: true,
                                            m: true
                                        };
                                        while (q[s.charAt(l)] === true) {
                                            q[s.charAt(l)] = false;
                                            l += 1;
                                        }
                                        character += l;
                                        s = s.substr(l);
                                        q = s.charAt(0);
                                        if (q === "/" || q === "*") {
                                            errorAt("Confusing regular expression.",
                                                    line, from);
                                        }
                                        return it("(regexp)", c);
                                    case "\\":
                                        c = s.charAt(l);
                                        if (c < " ") {
                                            warningAt(
"Unexpected control character in regular expression.", line, from + l);
                                        } else if (c === "<") {
                                            warningAt(
"Unexpected escaped character '{a}' in regular expression.", line, from + l, c);
                                        }
                                        l += 1;
                                        break;
                                    case "(":
                                        depth += 1;
                                        b = false;
                                        if (s.charAt(l) === "?") {
                                            l += 1;
                                            switch (s.charAt(l)) {
                                            case ":":
                                            case "=":
                                            case "!":
                                                l += 1;
                                                break;
                                            default:
                                                warningAt(
"Expected '{a}' and instead saw '{b}'.", line, from + l, ":", s.charAt(l));
                                            }
                                        } else {
                                            captures += 1;
                                        }
                                        break;
                                    case "|":
                                        b = false;
                                        break;
                                    case ")":
                                        if (depth === 0) {
                                            warningAt("Unescaped '{a}'.",
                                                    line, from + l, ")");
                                        } else {
                                            depth -= 1;
                                        }
                                        break;
                                    case " ":
                                        q = 1;
                                        while (s.charAt(l) === " ") {
                                            l += 1;
                                            q += 1;
                                        }
                                        if (q > 1) {
                                            warningAt(
"Spaces are hard to count. Use {{a}}.", line, from + l, q);
                                        }
                                        break;
                                    case "[":
                                        c = s.charAt(l);
                                        if (c === "^") {
                                            l += 1;
                                            if (option.regexp) {
                                                warningAt("Insecure '{a}'.",
                                                        line, from + l, c);
                                            } else if (s.charAt(l) === "]") {
                                                errorAt("Unescaped '{a}'.",
                                                    line, from + l, "^");
                                            }
                                        }
                                        if (c === "]") {
                                            warningAt("Empty class.", line,
                                                    from + l - 1);
                                        }
                                        isLiteral = false;
                                        isInRange = false;
klass:                                  do {
                                            c = s.charAt(l);
                                            l += 1;
                                            switch (c) {
                                            case "[":
                                            case "^":
                                                warningAt("Unescaped '{a}'.",
                                                        line, from + l, c);
                                                if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                                break;
                                            case "-":
                                                if (isLiteral && !isInRange) {
                                                    isLiteral = false;
                                                    isInRange = true;
                                                } else if (isInRange) {
                                                    isInRange = false;
                                                } else if (s.charAt(l) === "]") {
                                                    isInRange = true;
                                                } else {
                                                    if (option.regexdash !== (l === 2 || (l === 3 &&
                                                        s.charAt(1) === "^"))) {
                                                        warningAt("Unescaped '{a}'.",
                                                            line, from + l - 1, "-");
                                                    }
                                                    isLiteral = true;
                                                }
                                                break;
                                            case "]":
                                                if (isInRange && !option.regexdash) {
                                                    warningAt("Unescaped '{a}'.",
                                                            line, from + l - 1, "-");
                                                }
                                                break klass;
                                            case "\\":
                                                c = s.charAt(l);
                                                if (c < " ") {
                                                    warningAt(
"Unexpected control character in regular expression.", line, from + l);
                                                } else if (c === "<") {
                                                    warningAt(
"Unexpected escaped character '{a}' in regular expression.", line, from + l, c);
                                                }
                                                l += 1;

                                                // \w, \s and \d are never part of a character range
                                                if (/[wsd]/i.test(c)) {
                                                    if (isInRange) {
                                                        warningAt("Unescaped '{a}'.",
                                                            line, from + l, "-");
                                                        isInRange = false;
                                                    }
                                                    isLiteral = false;
                                                } else if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                                break;
                                            case "/":
                                                warningAt("Unescaped '{a}'.",
                                                        line, from + l - 1, "/");

                                                if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                                break;
                                            case "<":
                                                if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                                break;
                                            default:
                                                if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                            }
                                        } while (c);
                                        break;
                                    case ".":
                                        if (option.regexp) {
                                            warningAt("Insecure '{a}'.", line,
                                                    from + l, c);
                                        }
                                        break;
                                    case "]":
                                    case "?":
                                    case "{":
                                    case "}":
                                    case "+":
                                    case "*":
                                        warningAt("Unescaped '{a}'.", line,
                                                from + l, c);
                                    }
                                    if (b) {
                                        switch (s.charAt(l)) {
                                        case "?":
                                        case "+":
                                        case "*":
                                            l += 1;
                                            if (s.charAt(l) === "?") {
                                                l += 1;
                                            }
                                            break;
                                        case "{":
                                            l += 1;
                                            c = s.charAt(l);
                                            if (c < "0" || c > "9") {
                                                warningAt(
"Expected a number and instead saw '{a}'.", line, from + l, c);
                                            }
                                            l += 1;
                                            low = +c;
                                            for (;;) {
                                                c = s.charAt(l);
                                                if (c < "0" || c > "9") {
                                                    break;
                                                }
                                                l += 1;
                                                low = +c + (low * 10);
                                            }
                                            high = low;
                                            if (c === ",") {
                                                l += 1;
                                                high = Infinity;
                                                c = s.charAt(l);
                                                if (c >= "0" && c <= "9") {
                                                    l += 1;
                                                    high = +c;
                                                    for (;;) {
                                                        c = s.charAt(l);
                                                        if (c < "0" || c > "9") {
                                                            break;
                                                        }
                                                        l += 1;
                                                        high = +c + (high * 10);
                                                    }
                                                }
                                            }
                                            if (s.charAt(l) !== "}") {
                                                warningAt(
"Expected '{a}' and instead saw '{b}'.", line, from + l, "}", c);
                                            } else {
                                                l += 1;
                                            }
                                            if (s.charAt(l) === "?") {
                                                l += 1;
                                            }
                                            if (low > high) {
                                                warningAt(
"'{a}' should not be greater than '{b}'.", line, from + l, low, high);
                                            }
                                        }
                                    }
                                }
                                c = s.substr(0, l - 1);
                                character += l;
                                s = s.substr(l);
                                return it("(regexp)", c);
                            }
                            return it("(punctuator)", t);

    //      punctuator

                        case "#":
                            return it("(punctuator)", t);
                        default:
                            return it("(punctuator)", t);
                        }
                    }
                }
            }
        };
    }());


    function addlabel(t, type, token) {
        if (t === "hasOwnProperty") {
            warning("'hasOwnProperty' is a really bad name.");
        }

        // Define t in the current function in the current scope.
        if (is_own(funct, t) && !funct["(global)"]) {
            if (funct[t] === true) {
                if (option.latedef)
                    warning("'{a}' was used before it was defined.", nexttoken, t);
            } else {
                if (!option.shadow && type !== "exception")
                    warning("'{a}' is already defined.", nexttoken, t);
            }
        }

        funct[t] = type;

        if (token) {
            funct["(tokens)"][t] = token;
        }

        if (funct["(global)"]) {
            global[t] = funct;
            if (is_own(implied, t)) {
                if (option.latedef)
                    warning("'{a}' was used before it was defined.", nexttoken, t);
                delete implied[t];
            }
        } else {
            scope[t] = funct;
        }
    }


    function doOption() {
        var nt = nexttoken;
        var o  = nt.value;
        var quotmarkValue = option.quotmark;
        var predef = {};
        var b, obj, filter, t, tn, v, minus;

        switch (o) {
        case "*/":
            error("Unbegun comment.");
            break;
        case "/*members":
        case "/*member":
            o = "/*members";
            if (!membersOnly) {
                membersOnly = {};
            }
            obj = membersOnly;
            option.quotmark = false;
            break;
        case "/*jshint":
        case "/*jslint":
            obj = option;
            filter = boolOptions;
            break;
        case "/*global":
            obj = predef;
            break;
        default:
            error("What?");
        }

        t = lex.token();
loop:   for (;;) {
            minus = false;
            for (;;) {
                if (t.type === "special" && t.value === "*/") {
                    break loop;
                }
                if (t.id !== "(endline)" && t.id !== ",") {
                    break;
                }
                t = lex.token();
            }

            if (o === "/*global" && t.value === "-") {
                minus = true;
                t = lex.token();
            }

            if (t.type !== "(string)" && t.type !== "(identifier)" && o !== "/*members") {
                error("Bad option.", t);
            }

            v = lex.token();
            if (v.id === ":") {
                v = lex.token();

                if (obj === membersOnly) {
                    error("Expected '{a}' and instead saw '{b}'.", t, "*/", ":");
                }

                if (o === "/*jshint") {
                    checkOption(t.value, t);
                }

                if (t.value === "indent" && (o === "/*jshint" || o === "/*jslint")) {
                    b = +v.value;
                    if (typeof b !== "number" || !isFinite(b) || b <= 0 ||
                            Math.floor(b) !== b) {
                        error("Expected a small integer and instead saw '{a}'.",
                                v, v.value);
                    }
                    obj.white = true;
                    obj.indent = b;
                } else if (t.value === "maxerr" && (o === "/*jshint" || o === "/*jslint")) {
                    b = +v.value;
                    if (typeof b !== "number" || !isFinite(b) || b <= 0 ||
                            Math.floor(b) !== b) {
                        error("Expected a small integer and instead saw '{a}'.",
                                v, v.value);
                    }
                    obj.maxerr = b;
                } else if (t.value === "maxlen" && (o === "/*jshint" || o === "/*jslint")) {
                    b = +v.value;
                    if (typeof b !== "number" || !isFinite(b) || b <= 0 ||
                            Math.floor(b) !== b) {
                        error("Expected a small integer and instead saw '{a}'.",
                                v, v.value);
                    }
                    obj.maxlen = b;
                } else if (t.value === "validthis") {
                    if (funct["(global)"]) {
                        error("Option 'validthis' can't be used in a global scope.");
                    } else {
                        if (v.value === "true" || v.value === "false")
                            obj[t.value] = v.value === "true";
                        else
                            error("Bad option value.", v);
                    }
                } else if (t.value === "quotmark" && (o === "/*jshint")) {
                    switch (v.value) {
                    case "true":
                        obj.quotmark = true;
                        break;
                    case "false":
                        obj.quotmark = false;
                        break;
                    case "double":
                    case "single":
                        obj.quotmark = v.value;
                        break;
                    default:
                        error("Bad option value.", v);
                    }
                } else if (v.value === "true" || v.value === "false") {
                    if (o === "/*jslint") {
                        tn = renamedOptions[t.value] || t.value;
                        obj[tn] = v.value === "true";
                        if (invertedOptions[tn] !== undefined) {
                            obj[tn] = !obj[tn];
                        }
                    } else {
                        obj[t.value] = v.value === "true";
                    }

                    if (t.value === "newcap")
                        obj["(explicitNewcap)"] = true;
                } else {
                    error("Bad option value.", v);
                }
                t = lex.token();
            } else {
                if (o === "/*jshint" || o === "/*jslint") {
                    error("Missing option value.", t);
                }

                obj[t.value] = false;

                if (o === "/*global" && minus === true) {
                    JSHINT.blacklist[t.value] = t.value;
                    updatePredefined();
                }

                t = v;
            }
        }

        if (o === "/*members") {
            option.quotmark = quotmarkValue;
        }

        combine(predefined, predef);

        for (var key in predef) {
            if (is_own(predef, key)) {
                declared[key] = nt;
            }
        }

        if (filter) {
            assume();
        }
    }


// We need a peek function. If it has an argument, it peeks that much farther
// ahead. It is used to distinguish
//     for ( var i in ...
// from
//     for ( var i = ...

    function peek(p) {
        var i = p || 0, j = 0, t;

        while (j <= i) {
            t = lookahead[j];
            if (!t) {
                t = lookahead[j] = lex.token();
            }
            j += 1;
        }
        return t;
    }



// Produce the next token. It looks for programming errors.

    function advance(id, t) {
        switch (token.id) {
        case "(number)":
            if (nexttoken.id === ".") {
                warning("A dot following a number can be confused with a decimal point.", token);
            }
            break;
        case "-":
            if (nexttoken.id === "-" || nexttoken.id === "--") {
                warning("Confusing minusses.");
            }
            break;
        case "+":
            if (nexttoken.id === "+" || nexttoken.id === "++") {
                warning("Confusing plusses.");
            }
            break;
        }

        if (token.type === "(string)" || token.identifier) {
            anonname = token.value;
        }

        if (id && nexttoken.id !== id) {
            if (t) {
                if (nexttoken.id === "(end)") {
                    warning("Unmatched '{a}'.", t, t.id);
                } else {
                    warning("Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",
                            nexttoken, id, t.id, t.line, nexttoken.value);
                }
            } else if (nexttoken.type !== "(identifier)" ||
                            nexttoken.value !== id) {
                warning("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, id, nexttoken.value);
            }
        }

        prevtoken = token;
        token = nexttoken;
        for (;;) {
            nexttoken = lookahead.shift() || lex.token();
            if (nexttoken.id === "(end)" || nexttoken.id === "(error)") {
                return;
            }
            if (nexttoken.type === "special") {
                doOption();
            } else {
                if (nexttoken.id !== "(endline)") {
                    break;
                }
            }
        }
    }


// This is the heart of JSHINT, the Pratt parser. In addition to parsing, it
// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is
// like .nud except that it is only used on the first token of a statement.
// Having .fud makes it much easier to define statement-oriented languages like
// JavaScript. I retained Pratt's nomenclature.

// .nud     Null denotation
// .fud     First null denotation
// .led     Left denotation
//  lbp     Left binding power
//  rbp     Right binding power

// They are elements of the parsing method called Top Down Operator Precedence.

    function expression(rbp, initial) {
        var left, isArray = false, isObject = false;

        if (nexttoken.id === "(end)")
            error("Unexpected early end of program.", token);

        advance();
        if (initial) {
            anonname = "anonymous";
            funct["(verb)"] = token.value;
        }
        if (initial === true && token.fud) {
            left = token.fud();
        } else {
            if (token.nud) {
                left = token.nud();
            } else {
                if (nexttoken.type === "(number)" && token.id === ".") {
                    warning("A leading decimal point can be confused with a dot: '.{a}'.",
                            token, nexttoken.value);
                    advance();
                    return token;
                } else {
                    error("Expected an identifier and instead saw '{a}'.",
                            token, token.id);
                }
            }
            while (rbp < nexttoken.lbp) {
                isArray = token.value === "Array";
                isObject = token.value === "Object";

                // #527, new Foo.Array(), Foo.Array(), new Foo.Object(), Foo.Object()
                // Line breaks in IfStatement heads exist to satisfy the checkJSHint
                // "Line too long." error.
                if (left && (left.value || (left.first && left.first.value))) {
                    // If the left.value is not "new", or the left.first.value is a "."
                    // then safely assume that this is not "new Array()" and possibly
                    // not "new Object()"...
                    if (left.value !== "new" ||
                      (left.first && left.first.value && left.first.value === ".")) {
                        isArray = false;
                        // ...In the case of Object, if the left.value and token.value
                        // are not equal, then safely assume that this not "new Object()"
                        if (left.value !== token.value) {
                            isObject = false;
                        }
                    }
                }

                advance();
                if (isArray && token.id === "(" && nexttoken.id === ")")
                    warning("Use the array literal notation [].", token);
                if (isObject && token.id === "(" && nexttoken.id === ")")
                    warning("Use the object literal notation {}.", token);
                if (token.led) {
                    left = token.led(left);
                } else {
                    error("Expected an operator and instead saw '{a}'.",
                        token, token.id);
                }
            }
        }
        return left;
    }


// Functions for conformance of style.

    function adjacent(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (option.white) {
            if (left.character !== right.from && left.line === right.line) {
                left.from += (left.character - left.from);
                warning("Unexpected space after '{a}'.", left, left.value);
            }
        }
    }

    function nobreak(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (option.white && (left.character !== right.from || left.line !== right.line)) {
            warning("Unexpected space before '{a}'.", right, right.value);
        }
    }

    function nospace(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (option.white && !left.comment) {
            if (left.line === right.line) {
                adjacent(left, right);
            }
        }
    }

    function nonadjacent(left, right) {
        if (option.white) {
            left = left || token;
            right = right || nexttoken;
            if (left.value === ";" && right.value === ";") {
                return;
            }
            if (left.line === right.line && left.character === right.from) {
                left.from += (left.character - left.from);
                warning("Missing space after '{a}'.",
                        left, left.value);
            }
        }
    }

    function nobreaknonadjacent(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (!option.laxbreak && left.line !== right.line) {
            warning("Bad line breaking before '{a}'.", right, right.id);
        } else if (option.white) {
            left = left || token;
            right = right || nexttoken;
            if (left.character === right.from) {
                left.from += (left.character - left.from);
                warning("Missing space after '{a}'.",
                        left, left.value);
            }
        }
    }

    function indentation(bias) {
        var i;
        if (option.white && nexttoken.id !== "(end)") {
            i = indent + (bias || 0);
            if (nexttoken.from !== i) {
                warning(
"Expected '{a}' to have an indentation at {b} instead at {c}.",
                        nexttoken, nexttoken.value, i, nexttoken.from);
            }
        }
    }

    function nolinebreak(t) {
        t = t || token;
        if (t.line !== nexttoken.line) {
            warning("Line breaking error '{a}'.", t, t.value);
        }
    }


    function comma() {
        if (token.line !== nexttoken.line) {
            if (!option.laxcomma) {
                if (comma.first) {
                    warning("Comma warnings can be turned off with 'laxcomma'");
                    comma.first = false;
                }
                warning("Bad line breaking before '{a}'.", token, nexttoken.id);
            }
        } else if (!token.comment && token.character !== nexttoken.from && option.white) {
            token.from += (token.character - token.from);
            warning("Unexpected space after '{a}'.", token, token.value);
        }
        advance(",");
        nonadjacent(token, nexttoken);
    }


// Functional constructors for making the symbols that will be inherited by
// tokens.

    function symbol(s, p) {
        var x = syntax[s];
        if (!x || typeof x !== "object") {
            syntax[s] = x = {
                id: s,
                lbp: p,
                value: s
            };
        }
        return x;
    }


    function delim(s) {
        return symbol(s, 0);
    }


    function stmt(s, f) {
        var x = delim(s);
        x.identifier = x.reserved = true;
        x.fud = f;
        return x;
    }


    function blockstmt(s, f) {
        var x = stmt(s, f);
        x.block = true;
        return x;
    }


    function reserveName(x) {
        var c = x.id.charAt(0);
        if ((c >= "a" && c <= "z") || (c >= "A" && c <= "Z")) {
            x.identifier = x.reserved = true;
        }
        return x;
    }


    function prefix(s, f) {
        var x = symbol(s, 150);
        reserveName(x);
        x.nud = (typeof f === "function") ? f : function () {
            this.right = expression(150);
            this.arity = "unary";
            if (this.id === "++" || this.id === "--") {
                if (option.plusplus) {
                    warning("Unexpected use of '{a}'.", this, this.id);
                } else if ((!this.right.identifier || this.right.reserved) &&
                        this.right.id !== "." && this.right.id !== "[") {
                    warning("Bad operand.", this);
                }
            }
            return this;
        };
        return x;
    }


    function type(s, f) {
        var x = delim(s);
        x.type = s;
        x.nud = f;
        return x;
    }


    function reserve(s, f) {
        var x = type(s, f);
        x.identifier = x.reserved = true;
        return x;
    }


    function reservevar(s, v) {
        return reserve(s, function () {
            if (typeof v === "function") {
                v(this);
            }
            return this;
        });
    }


    function infix(s, f, p, w) {
        var x = symbol(s, p);
        reserveName(x);
        x.led = function (left) {
            if (!w) {
                nobreaknonadjacent(prevtoken, token);
                nonadjacent(token, nexttoken);
            }
            if (s === "in" && left.id === "!") {
                warning("Confusing use of '{a}'.", left, "!");
            }
            if (typeof f === "function") {
                return f(left, this);
            } else {
                this.left = left;
                this.right = expression(p);
                return this;
            }
        };
        return x;
    }


    function relation(s, f) {
        var x = symbol(s, 100);
        x.led = function (left) {
            nobreaknonadjacent(prevtoken, token);
            nonadjacent(token, nexttoken);
            var right = expression(100);
            if ((left && left.id === "NaN") || (right && right.id === "NaN")) {
                warning("Use the isNaN function to compare with NaN.", this);
            } else if (f) {
                f.apply(this, [left, right]);
            }
            if (left.id === "!") {
                warning("Confusing use of '{a}'.", left, "!");
            }
            if (right.id === "!") {
                warning("Confusing use of '{a}'.", right, "!");
            }
            this.left = left;
            this.right = right;
            return this;
        };
        return x;
    }


    function isPoorRelation(node) {
        return node &&
              ((node.type === "(number)" && +node.value === 0) ||
               (node.type === "(string)" && node.value === "") ||
               (node.type === "null" && !option.eqnull) ||
                node.type === "true" ||
                node.type === "false" ||
                node.type === "undefined");
    }


    function assignop(s) {
        symbol(s, 20).exps = true;

        return infix(s, function (left, that) {
            that.left = left;

            if (predefined[left.value] === false &&
                    scope[left.value]["(global)"] === true) {
                warning("Read only.", left);
            } else if (left["function"]) {
                warning("'{a}' is a function.", left, left.value);
            }

            if (left) {
                if (option.esnext && funct[left.value] === "const") {
                    warning("Attempting to override '{a}' which is a constant", left, left.value);
                }

                if (left.id === "." || left.id === "[") {
                    if (!left.left || left.left.value === "arguments") {
                        warning("Bad assignment.", that);
                    }
                    that.right = expression(19);
                    return that;
                } else if (left.identifier && !left.reserved) {
                    if (funct[left.value] === "exception") {
                        warning("Do not assign to the exception parameter.", left);
                    }
                    that.right = expression(19);
                    return that;
                }

                if (left === syntax["function"]) {
                    warning(
"Expected an identifier in an assignment and instead saw a function invocation.",
                                token);
                }
            }

            error("Bad assignment.", that);
        }, 20);
    }


    function bitwise(s, f, p) {
        var x = symbol(s, p);
        reserveName(x);
        x.led = (typeof f === "function") ? f : function (left) {
            if (option.bitwise) {
                warning("Unexpected use of '{a}'.", this, this.id);
            }
            this.left = left;
            this.right = expression(p);
            return this;
        };
        return x;
    }


    function bitwiseassignop(s) {
        symbol(s, 20).exps = true;
        return infix(s, function (left, that) {
            if (option.bitwise) {
                warning("Unexpected use of '{a}'.", that, that.id);
            }
            nonadjacent(prevtoken, token);
            nonadjacent(token, nexttoken);
            if (left) {
                if (left.id === "." || left.id === "[" ||
                        (left.identifier && !left.reserved)) {
                    expression(19);
                    return that;
                }
                if (left === syntax["function"]) {
                    warning(
"Expected an identifier in an assignment, and instead saw a function invocation.",
                                token);
                }
                return that;
            }
            error("Bad assignment.", that);
        }, 20);
    }


    function suffix(s) {
        var x = symbol(s, 150);
        x.led = function (left) {
            if (option.plusplus) {
                warning("Unexpected use of '{a}'.", this, this.id);
            } else if ((!left.identifier || left.reserved) &&
                    left.id !== "." && left.id !== "[") {
                warning("Bad operand.", this);
            }
            this.left = left;
            return this;
        };
        return x;
    }


    // fnparam means that this identifier is being defined as a function
    // argument (see identifier())
    function optionalidentifier(fnparam) {
        if (nexttoken.identifier) {
            advance();
            if (token.reserved && !option.es5) {
                // `undefined` as a function param is a common pattern to protect
                // against the case when somebody does `undefined = true` and
                // help with minification. More info: https://gist.github.com/315916
                if (!fnparam || token.value !== "undefined") {
                    warning("Expected an identifier and instead saw '{a}' (a reserved word).",
                            token, token.id);
                }
            }
            return token.value;
        }
    }

    // fnparam means that this identifier is being defined as a function
    // argument
    function identifier(fnparam) {
        var i = optionalidentifier(fnparam);
        if (i) {
            return i;
        }
        if (token.id === "function" && nexttoken.id === "(") {
            warning("Missing name in function declaration.");
        } else {
            error("Expected an identifier and instead saw '{a}'.",
                    nexttoken, nexttoken.value);
        }
    }


    function reachable(s) {
        var i = 0, t;
        if (nexttoken.id !== ";" || noreach) {
            return;
        }
        for (;;) {
            t = peek(i);
            if (t.reach) {
                return;
            }
            if (t.id !== "(endline)") {
                if (t.id === "function") {
                    if (!option.latedef) {
                        break;
                    }
                    warning(
"Inner functions should be listed at the top of the outer function.", t);
                    break;
                }
                warning("Unreachable '{a}' after '{b}'.", t, t.value, s);
                break;
            }
            i += 1;
        }
    }


    function statement(noindent) {
        var i = indent, r, s = scope, t = nexttoken;

        if (t.id === ";") {
            advance(";");
            return;
        }

        // Is this a labelled statement?

        if (t.identifier && !t.reserved && peek().id === ":") {
            advance();
            advance(":");
            scope = Object.create(s);
            addlabel(t.value, "label");

            if (!nexttoken.labelled && nexttoken.value !== "{") {
                warning("Label '{a}' on {b} statement.", nexttoken, t.value, nexttoken.value);
            }

            if (jx.test(t.value + ":")) {
                warning("Label '{a}' looks like a javascript url.", t, t.value);
            }

            nexttoken.label = t.value;
            t = nexttoken;
        }

        // Is it a lonely block?

        if (t.id === "{") {
            block(true, true);
            return;
        }

        // Parse the statement.

        if (!noindent) {
            indentation();
        }
        r = expression(0, true);

        // Look for the final semicolon.

        if (!t.block) {
            if (!option.expr && (!r || !r.exps)) {
                warning("Expected an assignment or function call and instead saw an expression.",
                    token);
            } else if (option.nonew && r.id === "(" && r.left.id === "new") {
                warning("Do not use 'new' for side effects.", t);
            }

            if (nexttoken.id === ",") {
                return comma();
            }

            if (nexttoken.id !== ";") {
                if (!option.asi) {
                    // If this is the last statement in a block that ends on
                    // the same line *and* option lastsemic is on, ignore the warning.
                    // Otherwise, complain about missing semicolon.
                    if (!option.lastsemic || nexttoken.id !== "}" ||
                            nexttoken.line !== token.line) {
                        warningAt("Missing semicolon.", token.line, token.character);
                    }
                }
            } else {
                adjacent(token, nexttoken);
                advance(";");
                nonadjacent(token, nexttoken);
            }
        }

// Restore the indentation.

        indent = i;
        scope = s;
        return r;
    }


    function statements(startLine) {
        var a = [], p;

        while (!nexttoken.reach && nexttoken.id !== "(end)") {
            if (nexttoken.id === ";") {
                p = peek();
                if (!p || p.id !== "(") {
                    warning("Unnecessary semicolon.");
                }
                advance(";");
            } else {
                a.push(statement(startLine === nexttoken.line));
            }
        }
        return a;
    }


    /*
     * read all directives
     * recognizes a simple form of asi, but always
     * warns, if it is used
     */
    function directives() {
        var i, p, pn;

        for (;;) {
            if (nexttoken.id === "(string)") {
                p = peek(0);
                if (p.id === "(endline)") {
                    i = 1;
                    do {
                        pn = peek(i);
                        i = i + 1;
                    } while (pn.id === "(endline)");

                    if (pn.id !== ";") {
                        if (pn.id !== "(string)" && pn.id !== "(number)" &&
                            pn.id !== "(regexp)" && pn.identifier !== true &&
                            pn.id !== "}") {
                            break;
                        }
                        warning("Missing semicolon.", nexttoken);
                    } else {
                        p = pn;
                    }
                } else if (p.id === "}") {
                    // directive with no other statements, warn about missing semicolon
                    warning("Missing semicolon.", p);
                } else if (p.id !== ";") {
                    break;
                }

                indentation();
                advance();
                if (directive[token.value]) {
                    warning("Unnecessary directive \"{a}\".", token, token.value);
                }

                if (token.value === "use strict") {
                    if (!option["(explicitNewcap)"])
                        option.newcap = true;
                    option.undef = true;
                }

                // there's no directive negation, so always set to true
                directive[token.value] = true;

                if (p.id === ";") {
                    advance(";");
                }
                continue;
            }
            break;
        }
    }


    /*
     * Parses a single block. A block is a sequence of statements wrapped in
     * braces.
     *
     * ordinary - true for everything but function bodies and try blocks.
     * stmt     - true if block can be a single statement (e.g. in if/for/while).
     * isfunc   - true if block is a function body
     */
    function block(ordinary, stmt, isfunc) {
        var a,
            b = inblock,
            old_indent = indent,
            m,
            s = scope,
            t,
            line,
            d;

        inblock = ordinary;
        if (!ordinary || !option.funcscope) scope = Object.create(scope);
        nonadjacent(token, nexttoken);
        t = nexttoken;

        var metrics = funct["(metrics)"];
        metrics.nestedBlockDepth += 1;
        metrics.verifyMaxNestedBlockDepthPerFunction();

        if (nexttoken.id === "{") {
            advance("{");
            line = token.line;
            if (nexttoken.id !== "}") {
                indent += option.indent;
                while (!ordinary && nexttoken.from > indent) {
                    indent += option.indent;
                }

                if (isfunc) {
                    m = {};
                    for (d in directive) {
                        if (is_own(directive, d)) {
                            m[d] = directive[d];
                        }
                    }
                    directives();

                    if (option.strict && funct["(context)"]["(global)"]) {
                        if (!m["use strict"] && !directive["use strict"]) {
                            warning("Missing \"use strict\" statement.");
                        }
                    }
                }

                a = statements(line);

                metrics.statementCount += a.length;

                if (isfunc) {
                    directive = m;
                }

                indent -= option.indent;
                if (line !== nexttoken.line) {
                    indentation();
                }
            } else if (line !== nexttoken.line) {
                indentation();
            }
            advance("}", t);
            indent = old_indent;
        } else if (!ordinary) {
            error("Expected '{a}' and instead saw '{b}'.",
                  nexttoken, "{", nexttoken.value);
        } else {
            if (!stmt || option.curly)
                warning("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, "{", nexttoken.value);

            noreach = true;
            indent += option.indent;
            // test indentation only if statement is in new line
            a = [statement(nexttoken.line === token.line)];
            indent -= option.indent;
            noreach = false;
        }
        funct["(verb)"] = null;
        if (!ordinary || !option.funcscope) scope = s;
        inblock = b;
        if (ordinary && option.noempty && (!a || a.length === 0)) {
            warning("Empty block.");
        }
        metrics.nestedBlockDepth -= 1;
        return a;
    }


    function countMember(m) {
        if (membersOnly && typeof membersOnly[m] !== "boolean") {
            warning("Unexpected /*member '{a}'.", token, m);
        }
        if (typeof member[m] === "number") {
            member[m] += 1;
        } else {
            member[m] = 1;
        }
    }


    function note_implied(token) {
        var name = token.value, line = token.line, a = implied[name];
        if (typeof a === "function") {
            a = false;
        }

        if (!a) {
            a = [line];
            implied[name] = a;
        } else if (a[a.length - 1] !== line) {
            a.push(line);
        }
    }


    // Build the syntax table by declaring the syntactic elements of the language.

    type("(number)", function () {
        return this;
    });

    type("(string)", function () {
        return this;
    });

    syntax["(identifier)"] = {
        type: "(identifier)",
        lbp: 0,
        identifier: true,
        nud: function () {
            var v = this.value,
                s = scope[v],
                f;

            if (typeof s === "function") {
                // Protection against accidental inheritance.
                s = undefined;
            } else if (typeof s === "boolean") {
                f = funct;
                funct = functions[0];
                addlabel(v, "var");
                s = funct;
                funct = f;
            }

            // The name is in scope and defined in the current function.
            if (funct === s) {
                // Change 'unused' to 'var', and reject labels.
                switch (funct[v]) {
                case "unused":
                    funct[v] = "var";
                    break;
                case "unction":
                    funct[v] = "function";
                    this["function"] = true;
                    break;
                case "function":
                    this["function"] = true;
                    break;
                case "label":
                    warning("'{a}' is a statement label.", token, v);
                    break;
                }
            } else if (funct["(global)"]) {
                // The name is not defined in the function.  If we are in the global
                // scope, then we have an undefined variable.
                //
                // Operators typeof and delete do not raise runtime errors even if
                // the base object of a reference is null so no need to display warning
                // if we're inside of typeof or delete.

                if (option.undef && typeof predefined[v] !== "boolean") {
                    // Attempting to subscript a null reference will throw an
                    // error, even within the typeof and delete operators
                    if (!(anonname === "typeof" || anonname === "delete") ||
                        (nexttoken && (nexttoken.value === "." || nexttoken.value === "["))) {

                        isundef(funct, "'{a}' is not defined.", token, v);
                    }
                }

                note_implied(token);
            } else {
                // If the name is already defined in the current
                // function, but not as outer, then there is a scope error.

                switch (funct[v]) {
                case "closure":
                case "function":
                case "var":
                case "unused":
                    warning("'{a}' used out of scope.", token, v);
                    break;
                case "label":
                    warning("'{a}' is a statement label.", token, v);
                    break;
                case "outer":
                case "global":
                    break;
                default:
                    // If the name is defined in an outer function, make an outer entry,
                    // and if it was unused, make it var.
                    if (s === true) {
                        funct[v] = true;
                    } else if (s === null) {
                        warning("'{a}' is not allowed.", token, v);
                        note_implied(token);
                    } else if (typeof s !== "object") {
                        // Operators typeof and delete do not raise runtime errors even
                        // if the base object of a reference is null so no need to
                        // display warning if we're inside of typeof or delete.
                        if (option.undef) {
                            // Attempting to subscript a null reference will throw an
                            // error, even within the typeof and delete operators
                            if (!(anonname === "typeof" || anonname === "delete") ||
                                (nexttoken &&
                                    (nexttoken.value === "." || nexttoken.value === "["))) {

                                isundef(funct, "'{a}' is not defined.", token, v);
                            }
                        }
                        funct[v] = true;
                        note_implied(token);
                    } else {
                        switch (s[v]) {
                        case "function":
                        case "unction":
                            this["function"] = true;
                            s[v] = "closure";
                            funct[v] = s["(global)"] ? "global" : "outer";
                            break;
                        case "var":
                        case "unused":
                            s[v] = "closure";
                            funct[v] = s["(global)"] ? "global" : "outer";
                            break;
                        case "closure":
                            funct[v] = s["(global)"] ? "global" : "outer";
                            break;
                        case "label":
                            warning("'{a}' is a statement label.", token, v);
                        }
                    }
                }
            }
            return this;
        },
        led: function () {
            error("Expected an operator and instead saw '{a}'.",
                nexttoken, nexttoken.value);
        }
    };

    type("(regexp)", function () {
        return this;
    });


// ECMAScript parser

    delim("(endline)");
    delim("(begin)");
    delim("(end)").reach = true;
    delim("</").reach = true;
    delim("<!");
    delim("<!--");
    delim("-->");
    delim("(error)").reach = true;
    delim("}").reach = true;
    delim(")");
    delim("]");
    delim("\"").reach = true;
    delim("'").reach = true;
    delim(";");
    delim(":").reach = true;
    delim(",");
    delim("#");
    delim("@");
    reserve("else");
    reserve("case").reach = true;
    reserve("catch");
    reserve("default").reach = true;
    reserve("finally");
    reservevar("arguments", function (x) {
        if (directive["use strict"] && funct["(global)"]) {
            warning("Strict violation.", x);
        }
    });
    reservevar("eval");
    reservevar("false");
    reservevar("Infinity");
    reservevar("NaN");
    reservevar("null");
    reservevar("this", function (x) {
        if (directive["use strict"] && !option.validthis && ((funct["(statement)"] &&
                funct["(name)"].charAt(0) > "Z") || funct["(global)"])) {
            warning("Possible strict violation.", x);
        }
    });
    reservevar("true");
    reservevar("undefined");
    assignop("=", "assign", 20);
    assignop("+=", "assignadd", 20);
    assignop("-=", "assignsub", 20);
    assignop("*=", "assignmult", 20);
    assignop("/=", "assigndiv", 20).nud = function () {
        error("A regular expression literal can be confused with '/='.");
    };
    assignop("%=", "assignmod", 20);
    bitwiseassignop("&=", "assignbitand", 20);
    bitwiseassignop("|=", "assignbitor", 20);
    bitwiseassignop("^=", "assignbitxor", 20);
    bitwiseassignop("<<=", "assignshiftleft", 20);
    bitwiseassignop(">>=", "assignshiftright", 20);
    bitwiseassignop(">>>=", "assignshiftrightunsigned", 20);
    infix("?", function (left, that) {
        that.left = left;
        that.right = expression(10);
        advance(":");
        that["else"] = expression(10);
        return that;
    }, 30);

    infix("||", "or", 40);
    infix("&&", "and", 50);
    bitwise("|", "bitor", 70);
    bitwise("^", "bitxor", 80);
    bitwise("&", "bitand", 90);
    relation("==", function (left, right) {
        var eqnull = option.eqnull && (left.value === "null" || right.value === "null");

        if (!eqnull && option.eqeqeq)
            warning("Expected '{a}' and instead saw '{b}'.", this, "===", "==");
        else if (isPoorRelation(left))
            warning("Use '{a}' to compare with '{b}'.", this, "===", left.value);
        else if (isPoorRelation(right))
            warning("Use '{a}' to compare with '{b}'.", this, "===", right.value);

        return this;
    });
    relation("===");
    relation("!=", function (left, right) {
        var eqnull = option.eqnull &&
                (left.value === "null" || right.value === "null");

        if (!eqnull && option.eqeqeq) {
            warning("Expected '{a}' and instead saw '{b}'.",
                    this, "!==", "!=");
        } else if (isPoorRelation(left)) {
            warning("Use '{a}' to compare with '{b}'.",
                    this, "!==", left.value);
        } else if (isPoorRelation(right)) {
            warning("Use '{a}' to compare with '{b}'.",
                    this, "!==", right.value);
        }
        return this;
    });
    relation("!==");
    relation("<");
    relation(">");
    relation("<=");
    relation(">=");
    bitwise("<<", "shiftleft", 120);
    bitwise(">>", "shiftright", 120);
    bitwise(">>>", "shiftrightunsigned", 120);
    infix("in", "in", 120);
    infix("instanceof", "instanceof", 120);
    infix("+", function (left, that) {
        var right = expression(130);
        if (left && right && left.id === "(string)" && right.id === "(string)") {
            left.value += right.value;
            left.character = right.character;
            if (!option.scripturl && jx.test(left.value)) {
                warning("JavaScript URL.", left);
            }
            return left;
        }
        that.left = left;
        that.right = right;
        return that;
    }, 130);
    prefix("+", "num");
    prefix("+++", function () {
        warning("Confusing pluses.");
        this.right = expression(150);
        this.arity = "unary";
        return this;
    });
    infix("+++", function (left) {
        warning("Confusing pluses.");
        this.left = left;
        this.right = expression(130);
        return this;
    }, 130);
    infix("-", "sub", 130);
    prefix("-", "neg");
    prefix("---", function () {
        warning("Confusing minuses.");
        this.right = expression(150);
        this.arity = "unary";
        return this;
    });
    infix("---", function (left) {
        warning("Confusing minuses.");
        this.left = left;
        this.right = expression(130);
        return this;
    }, 130);
    infix("*", "mult", 140);
    infix("/", "div", 140);
    infix("%", "mod", 140);

    suffix("++", "postinc");
    prefix("++", "preinc");
    syntax["++"].exps = true;

    suffix("--", "postdec");
    prefix("--", "predec");
    syntax["--"].exps = true;
    prefix("delete", function () {
        var p = expression(0);
        if (!p || (p.id !== "." && p.id !== "[")) {
            warning("Variables should not be deleted.");
        }
        this.first = p;
        return this;
    }).exps = true;

    prefix("~", function () {
        if (option.bitwise) {
            warning("Unexpected '{a}'.", this, "~");
        }
        expression(150);
        return this;
    });

    prefix("!", function () {
        this.right = expression(150);
        this.arity = "unary";
        if (bang[this.right.id] === true) {
            warning("Confusing use of '{a}'.", this, "!");
        }
        return this;
    });
    prefix("typeof", "typeof");
    prefix("new", function () {
        var c = expression(155), i;
        if (c && c.id !== "function") {
            if (c.identifier) {
                c["new"] = true;
                switch (c.value) {
                case "Number":
                case "String":
                case "Boolean":
                case "Math":
                case "JSON":
                    warning("Do not use {a} as a constructor.", prevtoken, c.value);
                    break;
                case "Function":
                    if (!option.evil) {
                        warning("The Function constructor is eval.");
                    }
                    break;
                case "Date":
                case "RegExp":
                    break;
                default:
                    if (c.id !== "function") {
                        i = c.value.substr(0, 1);
                        if (option.newcap && (i < "A" || i > "Z") && !is_own(global, c.value)) {
                            warning("A constructor name should start with an uppercase letter.",
                                token);
                        }
                    }
                }
            } else {
                if (c.id !== "." && c.id !== "[" && c.id !== "(") {
                    warning("Bad constructor.", token);
                }
            }
        } else {
            if (!option.supernew)
                warning("Weird construction. Delete 'new'.", this);
        }
        adjacent(token, nexttoken);
        if (nexttoken.id !== "(" && !option.supernew) {
            warning("Missing '()' invoking a constructor.",
                token, token.value);
        }
        this.first = c;
        return this;
    });
    syntax["new"].exps = true;

    prefix("void").exps = true;

    infix(".", function (left, that) {
        adjacent(prevtoken, token);
        nobreak();
        var m = identifier();
        if (typeof m === "string") {
            countMember(m);
        }
        that.left = left;
        that.right = m;
        if (left && left.value === "arguments" && (m === "callee" || m === "caller")) {
            if (option.noarg)
                warning("Avoid arguments.{a}.", left, m);
            else if (directive["use strict"])
                error("Strict violation.");
        } else if (!option.evil && left && left.value === "document" &&
                (m === "write" || m === "writeln")) {
            warning("document.write can be a form of eval.", left);
        }
        if (!option.evil && (m === "eval" || m === "execScript")) {
            warning("eval is evil.");
        }
        return that;
    }, 160, true);

    infix("(", function (left, that) {
        if (prevtoken.id !== "}" && prevtoken.id !== ")") {
            nobreak(prevtoken, token);
        }
        nospace();
        if (option.immed && !left.immed && left.id === "function") {
            warning("Wrap an immediate function invocation in parentheses " +
                "to assist the reader in understanding that the expression " +
                "is the result of a function, and not the function itself.");
        }
        var n = 0,
            p = [];
        if (left) {
            if (left.type === "(identifier)") {
                if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
                    if (left.value !== "Number" && left.value !== "String" &&
                            left.value !== "Boolean" &&
                            left.value !== "Date") {
                        if (left.value === "Math") {
                            warning("Math is not a function.", left);
                        } else if (option.newcap) {
                            warning(
"Missing 'new' prefix when invoking a constructor.", left);
                        }
                    }
                }
            }
        }
        if (nexttoken.id !== ")") {
            for (;;) {
                p[p.length] = expression(10);
                n += 1;
                if (nexttoken.id !== ",") {
                    break;
                }
                comma();
            }
        }
        advance(")");
        nospace(prevtoken, token);
        if (typeof left === "object") {
            if (left.value === "parseInt" && n === 1) {
                warning("Missing radix parameter.", token);
            }
            if (!option.evil) {
                if (left.value === "eval" || left.value === "Function" ||
                        left.value === "execScript") {
                    warning("eval is evil.", left);

                    if (p[0] && [0].id === "(string)") {
                        addInternalSrc(left, p[0].value);
                    }
                } else if (p[0] && p[0].id === "(string)" &&
                       (left.value === "setTimeout" ||
                        left.value === "setInterval")) {
                    warning(
    "Implied eval is evil. Pass a function instead of a string.", left);
                    addInternalSrc(left, p[0].value);

                // window.setTimeout/setInterval
                } else if (p[0] && p[0].id === "(string)" &&
                       left.value === "." &&
                       left.left.value === "window" &&
                       (left.right === "setTimeout" ||
                        left.right === "setInterval")) {
                    warning(
    "Implied eval is evil. Pass a function instead of a string.", left);
                    addInternalSrc(left, p[0].value);
                }
            }
            if (!left.identifier && left.id !== "." && left.id !== "[" &&
                    left.id !== "(" && left.id !== "&&" && left.id !== "||" &&
                    left.id !== "?") {
                warning("Bad invocation.", left);
            }
        }
        that.left = left;
        return that;
    }, 155, true).exps = true;

    prefix("(", function () {
        nospace();
        if (nexttoken.id === "function") {
            nexttoken.immed = true;
        }
        var v = expression(0);
        advance(")", this);
        nospace(prevtoken, token);
        if (option.immed && v.id === "function") {
            if (nexttoken.id !== "(" &&
              (nexttoken.id !== "." || (peek().value !== "call" && peek().value !== "apply"))) {
                warning(
"Do not wrap function literals in parens unless they are to be immediately invoked.",
                        this);
            }
        }

        return v;
    });

    infix("[", function (left, that) {
        nobreak(prevtoken, token);
        nospace();
        var e = expression(0), s;
        if (e && e.type === "(string)") {
            if (!option.evil && (e.value === "eval" || e.value === "execScript")) {
                warning("eval is evil.", that);
            }
            countMember(e.value);
            if (!option.sub && ix.test(e.value)) {
                s = syntax[e.value];
                if (!s || !s.reserved) {
                    warning("['{a}'] is better written in dot notation.",
                            prevtoken, e.value);
                }
            }
        }
        advance("]", that);
        nospace(prevtoken, token);
        that.left = left;
        that.right = e;
        return that;
    }, 160, true);

    prefix("[", function () {
        var b = token.line !== nexttoken.line;
        this.first = [];
        if (b) {
            indent += option.indent;
            if (nexttoken.from === indent + option.indent) {
                indent += option.indent;
            }
        }
        while (nexttoken.id !== "(end)") {
            while (nexttoken.id === ",") {
                warning("Extra comma.");
                advance(",");
            }
            if (nexttoken.id === "]") {
                break;
            }
            if (b && token.line !== nexttoken.line) {
                indentation();
            }
            this.first.push(expression(10));
            if (nexttoken.id === ",") {
                comma();
                if (nexttoken.id === "]" && !option.es5) {
                    warning("Extra comma.", token);
                    break;
                }
            } else {
                break;
            }
        }
        if (b) {
            indent -= option.indent;
            indentation();
        }
        advance("]", this);
        return this;
    }, 160);


    function property_name() {
        var id = optionalidentifier(true);
        if (!id) {
            if (nexttoken.id === "(string)") {
                id = nexttoken.value;
                advance();
            } else if (nexttoken.id === "(number)") {
                id = nexttoken.value.toString();
                advance();
            }
        }
        return id;
    }


    function functionparams() {
        var next   = nexttoken;
        var params = [];
        var ident;

        advance("(");
        nospace();

        if (nexttoken.id === ")") {
            advance(")");
            return;
        }

        for (;;) {
            ident = identifier(true);
            params.push(ident);
            addlabel(ident, "unused", token);
            if (nexttoken.id === ",") {
                comma();
            } else {
                advance(")", next);
                nospace(prevtoken, token);
                return params;
            }
        }
    }


    function doFunction(i, statement) {
        var f,
            oldOption = option,
            oldScope  = scope;

        option = Object.create(option);
        scope = Object.create(scope);

        funct = {
            "(name)"     : i || "\"" + anonname + "\"",
            "(line)"     : nexttoken.line,
            "(character)": nexttoken.character,
            "(context)"  : funct,
            "(breakage)" : 0,
            "(loopage)"  : 0,
            "(metrics)"  : createMetrics(nexttoken),
            "(scope)"    : scope,
            "(statement)": statement,
            "(tokens)"   : {}
        };
        f = funct;
        token.funct = funct;
        functions.push(funct);
        if (i) {
            addlabel(i, "function");
        }
        funct["(params)"] = functionparams();
        funct["(metrics)"].verifyMaxParametersPerFunction(funct["(params)"]);

        block(false, false, true);

        funct["(metrics)"].verifyMaxStatementsPerFunction();
        funct["(metrics)"].verifyMaxComplexityPerFunction();

        scope = oldScope;
        option = oldOption;
        funct["(last)"] = token.line;
        funct["(lastcharacter)"] = token.character;
        funct = funct["(context)"];
        return f;
    }

    function createMetrics(functionStartToken) {
        return {
            statementCount: 0,
            nestedBlockDepth: -1,
            ComplexityCount: 1,
            verifyMaxStatementsPerFunction: function () {
                if (option.maxstatements &&
                    this.statementCount > option.maxstatements) {
                    var message = "Too many statements per function (" + this.statementCount + ").";
                    warning(message, functionStartToken);
                }
            },

            verifyMaxParametersPerFunction: function (parameters) {
                if (option.maxparams &&
                    parameters.length > option.maxparams) {
                    var message = "Too many parameters per function (" + parameters.length + ").";
                    warning(message, functionStartToken);
                }
            },

            verifyMaxNestedBlockDepthPerFunction: function () {
                if (option.maxdepth &&
                    this.nestedBlockDepth > 0 &&
                    this.nestedBlockDepth === option.maxdepth + 1) {
                    var message = "Blocks are nested too deeply (" + this.nestedBlockDepth + ").";
                    warning(message);
                }
            },

            verifyMaxComplexityPerFunction: function () {
                var max = option.maxcomplexity;
                var cc = this.ComplexityCount;
                if (max && cc > max) {
                    var message = "Cyclomatic complexity is too high per function (" + cc + ").";
                    warning(message, functionStartToken);
                }
            }
        };
    }

    function increaseComplexityCount() {
        funct["(metrics)"].ComplexityCount += 1;
    }


    (function (x) {
        x.nud = function () {
            var b, f, i, p, t;
            var props = {}; // All properties, including accessors

            function saveProperty(name, token) {
                if (props[name] && is_own(props, name))
                    warning("Duplicate member '{a}'.", nexttoken, i);
                else
                    props[name] = {};

                props[name].basic = true;
                props[name].basicToken = token;
            }

            function saveSetter(name, token) {
                if (props[name] && is_own(props, name)) {
                    if (props[name].basic || props[name].setter)
                        warning("Duplicate member '{a}'.", nexttoken, i);
                } else {
                    props[name] = {};
                }

                props[name].setter = true;
                props[name].setterToken = token;
            }

            function saveGetter(name) {
                if (props[name] && is_own(props, name)) {
                    if (props[name].basic || props[name].getter)
                        warning("Duplicate member '{a}'.", nexttoken, i);
                } else {
                    props[name] = {};
                }

                props[name].getter = true;
                props[name].getterToken = token;
            }

            b = token.line !== nexttoken.line;
            if (b) {
                indent += option.indent;
                if (nexttoken.from === indent + option.indent) {
                    indent += option.indent;
                }
            }
            for (;;) {
                if (nexttoken.id === "}") {
                    break;
                }
                if (b) {
                    indentation();
                }
                if (nexttoken.value === "get" && peek().id !== ":") {
                    advance("get");
                    if (!option.es5) {
                        error("get/set are ES5 features.");
                    }
                    i = property_name();
                    if (!i) {
                        error("Missing property name.");
                    }
                    saveGetter(i);
                    t = nexttoken;
                    adjacent(token, nexttoken);
                    f = doFunction();
                    p = f["(params)"];
                    if (p) {
                        warning("Unexpected parameter '{a}' in get {b} function.", t, p[0], i);
                    }
                    adjacent(token, nexttoken);
                } else if (nexttoken.value === "set" && peek().id !== ":") {
                    advance("set");
                    if (!option.es5) {
                        error("get/set are ES5 features.");
                    }
                    i = property_name();
                    if (!i) {
                        error("Missing property name.");
                    }
                    saveSetter(i, nexttoken);
                    t = nexttoken;
                    adjacent(token, nexttoken);
                    f = doFunction();
                    p = f["(params)"];
                    if (!p || p.length !== 1) {
                        warning("Expected a single parameter in set {a} function.", t, i);
                    }
                } else {
                    i = property_name();
                    saveProperty(i, nexttoken);
                    if (typeof i !== "string") {
                        break;
                    }
                    advance(":");
                    nonadjacent(token, nexttoken);
                    expression(10);
                }

                countMember(i);
                if (nexttoken.id === ",") {
                    comma();
                    if (nexttoken.id === ",") {
                        warning("Extra comma.", token);
                    } else if (nexttoken.id === "}" && !option.es5) {
                        warning("Extra comma.", token);
                    }
                } else {
                    break;
                }
            }
            if (b) {
                indent -= option.indent;
                indentation();
            }
            advance("}", this);

            // Check for lonely setters if in the ES5 mode.
            if (option.es5) {
                for (var name in props) {
                    if (is_own(props, name) && props[name].setter && !props[name].getter) {
                        warning("Setter is defined without getter.", props[name].setterToken);
                    }
                }
            }
            return this;
        };
        x.fud = function () {
            error("Expected to see a statement and instead saw a block.", token);
        };
    }(delim("{")));

// This Function is called when esnext option is set to true
// it adds the `const` statement to JSHINT

    useESNextSyntax = function () {
        var conststatement = stmt("const", function (prefix) {
            var id, name, value;

            this.first = [];
            for (;;) {
                nonadjacent(token, nexttoken);
                id = identifier();
                if (funct[id] === "const") {
                    warning("const '" + id + "' has already been declared");
                }
                if (funct["(global)"] && predefined[id] === false) {
                    warning("Redefinition of '{a}'.", token, id);
                }
                addlabel(id, "const");
                if (prefix) {
                    break;
                }
                name = token;
                this.first.push(token);

                if (nexttoken.id !== "=") {
                    warning("const " +
                      "'{a}' is initialized to 'undefined'.", token, id);
                }

                if (nexttoken.id === "=") {
                    nonadjacent(token, nexttoken);
                    advance("=");
                    nonadjacent(token, nexttoken);
                    if (nexttoken.id === "undefined") {
                        warning("It is not necessary to initialize " +
                          "'{a}' to 'undefined'.", token, id);
                    }
                    if (peek(0).id === "=" && nexttoken.identifier) {
                        error("Constant {a} was not declared correctly.",
                                nexttoken, nexttoken.value);
                    }
                    value = expression(0);
                    name.first = value;
                }

                if (nexttoken.id !== ",") {
                    break;
                }
                comma();
            }
            return this;
        });
        conststatement.exps = true;
    };

    var varstatement = stmt("var", function (prefix) {
        // JavaScript does not have block scope. It only has function scope. So,
        // declaring a variable in a block can have unexpected consequences.
        var id, name, value;

        if (funct["(onevar)"] && option.onevar) {
            warning("Too many var statements.");
        } else if (!funct["(global)"]) {
            funct["(onevar)"] = true;
        }

        this.first = [];

        for (;;) {
            nonadjacent(token, nexttoken);
            id = identifier();

            if (option.esnext && funct[id] === "const") {
                warning("const '" + id + "' has already been declared");
            }

            if (funct["(global)"] && predefined[id] === false) {
                warning("Redefinition of '{a}'.", token, id);
            }

            addlabel(id, "unused", token);

            if (prefix) {
                break;
            }

            name = token;
            this.first.push(token);

            if (nexttoken.id === "=") {
                nonadjacent(token, nexttoken);
                advance("=");
                nonadjacent(token, nexttoken);
                if (nexttoken.id === "undefined") {
                    warning("It is not necessary to initialize '{a}' to 'undefined'.", token, id);
                }
                if (peek(0).id === "=" && nexttoken.identifier) {
                    error("Variable {a} was not declared correctly.",
                            nexttoken, nexttoken.value);
                }
                value = expression(0);
                name.first = value;
            }
            if (nexttoken.id !== ",") {
                break;
            }
            comma();
        }
        return this;
    });
    varstatement.exps = true;

    blockstmt("function", function () {
        if (inblock) {
            warning("Function declarations should not be placed in blocks. " +
                "Use a function expression or move the statement to the top of " +
                "the outer function.", token);

        }
        var i = identifier();
        if (option.esnext && funct[i] === "const") {
            warning("const '" + i + "' has already been declared");
        }
        adjacent(token, nexttoken);
        addlabel(i, "unction", token);

        doFunction(i, true);
        if (nexttoken.id === "(" && nexttoken.line === token.line) {
            error(
"Function declarations are not invocable. Wrap the whole function invocation in parens.");
        }
        return this;
    });

    prefix("function", function () {
        var i = optionalidentifier();
        if (i) {
            adjacent(token, nexttoken);
        } else {
            nonadjacent(token, nexttoken);
        }
        doFunction(i);
        if (!option.loopfunc && funct["(loopage)"]) {
            warning("Don't make functions within a loop.");
        }
        return this;
    });

    blockstmt("if", function () {
        var t = nexttoken;
        increaseComplexityCount();
        advance("(");
        nonadjacent(this, t);
        nospace();
        expression(20);
        if (nexttoken.id === "=") {
            if (!option.boss)
                warning("Expected a conditional expression and instead saw an assignment.");
            advance("=");
            expression(20);
        }
        advance(")", t);
        nospace(prevtoken, token);
        block(true, true);
        if (nexttoken.id === "else") {
            nonadjacent(token, nexttoken);
            advance("else");
            if (nexttoken.id === "if" || nexttoken.id === "switch") {
                statement(true);
            } else {
                block(true, true);
            }
        }
        return this;
    });

    blockstmt("try", function () {
        var b, e, s;

        block(false);
        if (nexttoken.id === "catch") {
            increaseComplexityCount();
            advance("catch");
            nonadjacent(token, nexttoken);
            advance("(");
            s = scope;
            scope = Object.create(s);
            e = nexttoken.value;
            if (nexttoken.type !== "(identifier)") {
                warning("Expected an identifier and instead saw '{a}'.",
                    nexttoken, e);
            } else {
                addlabel(e, "exception");
            }
            advance();
            advance(")");
            block(false);
            b = true;
            scope = s;
        }
        if (nexttoken.id === "finally") {
            advance("finally");
            block(false);
            return;
        } else if (!b) {
            error("Expected '{a}' and instead saw '{b}'.",
                    nexttoken, "catch", nexttoken.value);
        }
        return this;
    });

    blockstmt("while", function () {
        var t = nexttoken;
        funct["(breakage)"] += 1;
        funct["(loopage)"] += 1;
        increaseComplexityCount();
        advance("(");
        nonadjacent(this, t);
        nospace();
        expression(20);
        if (nexttoken.id === "=") {
            if (!option.boss)
                warning("Expected a conditional expression and instead saw an assignment.");
            advance("=");
            expression(20);
        }
        advance(")", t);
        nospace(prevtoken, token);
        block(true, true);
        funct["(breakage)"] -= 1;
        funct["(loopage)"] -= 1;
        return this;
    }).labelled = true;

    blockstmt("with", function () {
        var t = nexttoken;
        if (directive["use strict"]) {
            error("'with' is not allowed in strict mode.", token);
        } else if (!option.withstmt) {
            warning("Don't use 'with'.", token);
        }

        advance("(");
        nonadjacent(this, t);
        nospace();
        expression(0);
        advance(")", t);
        nospace(prevtoken, token);
        block(true, true);

        return this;
    });

    blockstmt("switch", function () {
        var t = nexttoken,
            g = false;
        funct["(breakage)"] += 1;
        advance("(");
        nonadjacent(this, t);
        nospace();
        this.condition = expression(20);
        advance(")", t);
        nospace(prevtoken, token);
        nonadjacent(token, nexttoken);
        t = nexttoken;
        advance("{");
        nonadjacent(token, nexttoken);
        indent += option.indent;
        this.cases = [];
        for (;;) {
            switch (nexttoken.id) {
            case "case":
                switch (funct["(verb)"]) {
                case "break":
                case "case":
                case "continue":
                case "return":
                case "switch":
                case "throw":
                    break;
                default:
                    // You can tell JSHint that you don't use break intentionally by
                    // adding a comment /* falls through */ on a line just before
                    // the next `case`.
                    if (!ft.test(lines[nexttoken.line - 2])) {
                        warning(
                            "Expected a 'break' statement before 'case'.",
                            token);
                    }
                }
                indentation(-option.indent);
                advance("case");
                this.cases.push(expression(20));
                increaseComplexityCount();
                g = true;
                advance(":");
                funct["(verb)"] = "case";
                break;
            case "default":
                switch (funct["(verb)"]) {
                case "break":
                case "continue":
                case "return":
                case "throw":
                    break;
                default:
                    if (!ft.test(lines[nexttoken.line - 2])) {
                        warning(
                            "Expected a 'break' statement before 'default'.",
                            token);
                    }
                }
                indentation(-option.indent);
                advance("default");
                g = true;
                advance(":");
                break;
            case "}":
                indent -= option.indent;
                indentation();
                advance("}", t);
                if (this.cases.length === 1 || this.condition.id === "true" ||
                        this.condition.id === "false") {
                    if (!option.onecase)
                        warning("This 'switch' should be an 'if'.", this);
                }
                funct["(breakage)"] -= 1;
                funct["(verb)"] = undefined;
                return;
            case "(end)":
                error("Missing '{a}'.", nexttoken, "}");
                return;
            default:
                if (g) {
                    switch (token.id) {
                    case ",":
                        error("Each value should have its own case label.");
                        return;
                    case ":":
                        g = false;
                        statements();
                        break;
                    default:
                        error("Missing ':' on a case clause.", token);
                        return;
                    }
                } else {
                    if (token.id === ":") {
                        advance(":");
                        error("Unexpected '{a}'.", token, ":");
                        statements();
                    } else {
                        error("Expected '{a}' and instead saw '{b}'.",
                            nexttoken, "case", nexttoken.value);
                        return;
                    }
                }
            }
        }
    }).labelled = true;

    stmt("debugger", function () {
        if (!option.debug) {
            warning("All 'debugger' statements should be removed.");
        }
        return this;
    }).exps = true;

    (function () {
        var x = stmt("do", function () {
            funct["(breakage)"] += 1;
            funct["(loopage)"] += 1;
            increaseComplexityCount();

            this.first = block(true);
            advance("while");
            var t = nexttoken;
            nonadjacent(token, t);
            advance("(");
            nospace();
            expression(20);
            if (nexttoken.id === "=") {
                if (!option.boss)
                    warning("Expected a conditional expression and instead saw an assignment.");
                advance("=");
                expression(20);
            }
            advance(")", t);
            nospace(prevtoken, token);
            funct["(breakage)"] -= 1;
            funct["(loopage)"] -= 1;
            return this;
        });
        x.labelled = true;
        x.exps = true;
    }());

    blockstmt("for", function () {
        var s, t = nexttoken;
        funct["(breakage)"] += 1;
        funct["(loopage)"] += 1;
        increaseComplexityCount();
        advance("(");
        nonadjacent(this, t);
        nospace();
        if (peek(nexttoken.id === "var" ? 1 : 0).id === "in") {
            if (nexttoken.id === "var") {
                advance("var");
                varstatement.fud.call(varstatement, true);
            } else {
                switch (funct[nexttoken.value]) {
                case "unused":
                    funct[nexttoken.value] = "var";
                    break;
                case "var":
                    break;
                default:
                    warning("Bad for in variable '{a}'.",
                            nexttoken, nexttoken.value);
                }
                advance();
            }
            advance("in");
            expression(20);
            advance(")", t);
            s = block(true, true);
            if (option.forin && s && (s.length > 1 || typeof s[0] !== "object" ||
                    s[0].value !== "if")) {
                warning("The body of a for in should be wrapped in an if statement to filter " +
                        "unwanted properties from the prototype.", this);
            }
            funct["(breakage)"] -= 1;
            funct["(loopage)"] -= 1;
            return this;
        } else {
            if (nexttoken.id !== ";") {
                if (nexttoken.id === "var") {
                    advance("var");
                    varstatement.fud.call(varstatement);
                } else {
                    for (;;) {
                        expression(0, "for");
                        if (nexttoken.id !== ",") {
                            break;
                        }
                        comma();
                    }
                }
            }
            nolinebreak(token);
            advance(";");
            if (nexttoken.id !== ";") {
                expression(20);
                if (nexttoken.id === "=") {
                    if (!option.boss)
                        warning("Expected a conditional expression and instead saw an assignment.");
                    advance("=");
                    expression(20);
                }
            }
            nolinebreak(token);
            advance(";");
            if (nexttoken.id === ";") {
                error("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, ")", ";");
            }
            if (nexttoken.id !== ")") {
                for (;;) {
                    expression(0, "for");
                    if (nexttoken.id !== ",") {
                        break;
                    }
                    comma();
                }
            }
            advance(")", t);
            nospace(prevtoken, token);
            block(true, true);
            funct["(breakage)"] -= 1;
            funct["(loopage)"] -= 1;
            return this;
        }
    }).labelled = true;


    stmt("break", function () {
        var v = nexttoken.value;

        if (funct["(breakage)"] === 0)
            warning("Unexpected '{a}'.", nexttoken, this.value);

        if (!option.asi)
            nolinebreak(this);

        if (nexttoken.id !== ";") {
            if (token.line === nexttoken.line) {
                if (funct[v] !== "label") {
                    warning("'{a}' is not a statement label.", nexttoken, v);
                } else if (scope[v] !== funct) {
                    warning("'{a}' is out of scope.", nexttoken, v);
                }
                this.first = nexttoken;
                advance();
            }
        }
        reachable("break");
        return this;
    }).exps = true;


    stmt("continue", function () {
        var v = nexttoken.value;

        if (funct["(breakage)"] === 0)
            warning("Unexpected '{a}'.", nexttoken, this.value);

        if (!option.asi)
            nolinebreak(this);

        if (nexttoken.id !== ";") {
            if (token.line === nexttoken.line) {
                if (funct[v] !== "label") {
                    warning("'{a}' is not a statement label.", nexttoken, v);
                } else if (scope[v] !== funct) {
                    warning("'{a}' is out of scope.", nexttoken, v);
                }
                this.first = nexttoken;
                advance();
            }
        } else if (!funct["(loopage)"]) {
            warning("Unexpected '{a}'.", nexttoken, this.value);
        }
        reachable("continue");
        return this;
    }).exps = true;


    stmt("return", function () {
        if (this.line === nexttoken.line) {
            if (nexttoken.id === "(regexp)")
                warning("Wrap the /regexp/ literal in parens to disambiguate the slash operator.");

            if (nexttoken.id !== ";" && !nexttoken.reach) {
                nonadjacent(token, nexttoken);
                if (peek().value === "=" && !option.boss) {
                    warningAt("Did you mean to return a conditional instead of an assignment?",
                              token.line, token.character + 1);
                }
                this.first = expression(0);
            }
        } else if (!option.asi) {
            nolinebreak(this); // always warn (Line breaking error)
        }
        reachable("return");
        return this;
    }).exps = true;


    stmt("throw", function () {
        nolinebreak(this);
        nonadjacent(token, nexttoken);
        this.first = expression(20);
        reachable("throw");
        return this;
    }).exps = true;

//  Superfluous reserved words

    reserve("class");
    reserve("const");
    reserve("enum");
    reserve("export");
    reserve("extends");
    reserve("import");
    reserve("super");

    reserve("let");
    reserve("yield");
    reserve("implements");
    reserve("interface");
    reserve("package");
    reserve("private");
    reserve("protected");
    reserve("public");
    reserve("static");


// Parse JSON

    function jsonValue() {

        function jsonObject() {
            var o = {}, t = nexttoken;
            advance("{");
            if (nexttoken.id !== "}") {
                for (;;) {
                    if (nexttoken.id === "(end)") {
                        error("Missing '}' to match '{' from line {a}.",
                                nexttoken, t.line);
                    } else if (nexttoken.id === "}") {
                        warning("Unexpected comma.", token);
                        break;
                    } else if (nexttoken.id === ",") {
                        error("Unexpected comma.", nexttoken);
                    } else if (nexttoken.id !== "(string)") {
                        warning("Expected a string and instead saw {a}.",
                                nexttoken, nexttoken.value);
                    }
                    if (o[nexttoken.value] === true) {
                        warning("Duplicate key '{a}'.",
                                nexttoken, nexttoken.value);
                    } else if ((nexttoken.value === "__proto__" &&
                        !option.proto) || (nexttoken.value === "__iterator__" &&
                        !option.iterator)) {
                        warning("The '{a}' key may produce unexpected results.",
                            nexttoken, nexttoken.value);
                    } else {
                        o[nexttoken.value] = true;
                    }
                    advance();
                    advance(":");
                    jsonValue();
                    if (nexttoken.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("}");
        }

        function jsonArray() {
            var t = nexttoken;
            advance("[");
            if (nexttoken.id !== "]") {
                for (;;) {
                    if (nexttoken.id === "(end)") {
                        error("Missing ']' to match '[' from line {a}.",
                                nexttoken, t.line);
                    } else if (nexttoken.id === "]") {
                        warning("Unexpected comma.", token);
                        break;
                    } else if (nexttoken.id === ",") {
                        error("Unexpected comma.", nexttoken);
                    }
                    jsonValue();
                    if (nexttoken.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("]");
        }

        switch (nexttoken.id) {
        case "{":
            jsonObject();
            break;
        case "[":
            jsonArray();
            break;
        case "true":
        case "false":
        case "null":
        case "(number)":
        case "(string)":
            advance();
            break;
        case "-":
            advance("-");
            if (token.character !== nexttoken.from) {
                warning("Unexpected space after '-'.", token);
            }
            adjacent(token, nexttoken);
            advance("(number)");
            break;
        default:
            error("Expected a JSON value.", nexttoken);
        }
    }


    // The actual JSHINT function itself.
    var itself = function (s, o, g) {
        var a, i, k, x;
        var optionKeys;
        var newOptionObj = {};

        if (o && o.scope) {
            JSHINT.scope = o.scope;
        } else {
            JSHINT.errors = [];
            JSHINT.undefs = [];
            JSHINT.internals = [];
            JSHINT.blacklist = {};
            JSHINT.scope = "(main)";
        }

        predefined = Object.create(standard);
        declared = Object.create(null);
        combine(predefined, g || {});

        if (o) {
            a = o.predef;
            if (a) {
                if (!Array.isArray(a) && typeof a === "object") {
                    a = Object.keys(a);
                }
                a.forEach(function (item) {
                    var slice;
                    if (item[0] === "-") {
                        slice = item.slice(1);
                        JSHINT.blacklist[slice] = slice;
                    } else {
                        predefined[item] = true;
                    }
                });
            }
            optionKeys = Object.keys(o);
            for (x = 0; x < optionKeys.length; x++) {
                newOptionObj[optionKeys[x]] = o[optionKeys[x]];

                if (optionKeys[x] === "newcap" && o[optionKeys[x]] === false)
                    newOptionObj["(explicitNewcap)"] = true;
            }
        }

        option = newOptionObj;

        option.indent = option.indent || 4;
        option.maxerr = option.maxerr || 50;

        tab = "";
        for (i = 0; i < option.indent; i += 1) {
            tab += " ";
        }
        indent = 1;
        global = Object.create(predefined);
        scope = global;
        funct = {
            "(global)":   true,
            "(name)":     "(global)",
            "(scope)":    scope,
            "(breakage)": 0,
            "(loopage)":  0,
            "(tokens)":   {},
            "(metrics)":   createMetrics(nexttoken)
        };
        functions = [funct];
        urls = [];
        stack = null;
        member = {};
        membersOnly = null;
        implied = {};
        inblock = false;
        lookahead = [];
        jsonmode = false;
        warnings = 0;
        lines = [];
        unuseds = [];

        if (!isString(s) && !Array.isArray(s)) {
            errorAt("Input is neither a string nor an array of strings.", 0);
            return false;
        }

        if (isString(s) && /^\s*$/g.test(s)) {
            errorAt("Input is an empty string.", 0);
            return false;
        }

        if (s.length === 0) {
            errorAt("Input is an empty array.", 0);
            return false;
        }

        lex.init(s);

        prereg = true;
        directive = {};

        prevtoken = token = nexttoken = syntax["(begin)"];

        // Check options
        for (var name in o) {
            if (is_own(o, name)) {
                checkOption(name, token);
            }
        }

        assume();

        // combine the passed globals after we've assumed all our options
        combine(predefined, g || {});

        //reset values
        comma.first = true;
        quotmark = undefined;

        try {
            advance();
            switch (nexttoken.id) {
            case "{":
            case "[":
                option.laxbreak = true;
                jsonmode = true;
                jsonValue();
                break;
            default:
                directives();
                if (directive["use strict"] && !option.globalstrict) {
                    warning("Use the function form of \"use strict\".", prevtoken);
                }

                statements();
            }
            advance((nexttoken && nexttoken.value !== ".")  ? "(end)" : undefined);

            var markDefined = function (name, context) {
                do {
                    if (typeof context[name] === "string") {
                        // JSHINT marks unused variables as 'unused' and
                        // unused function declaration as 'unction'. This
                        // code changes such instances back 'var' and
                        // 'closure' so that the code in JSHINT.data()
                        // doesn't think they're unused.

                        if (context[name] === "unused")
                            context[name] = "var";
                        else if (context[name] === "unction")
                            context[name] = "closure";

                        return true;
                    }

                    context = context["(context)"];
                } while (context);

                return false;
            };

            var clearImplied = function (name, line) {
                if (!implied[name])
                    return;

                var newImplied = [];
                for (var i = 0; i < implied[name].length; i += 1) {
                    if (implied[name][i] !== line)
                        newImplied.push(implied[name][i]);
                }

                if (newImplied.length === 0)
                    delete implied[name];
                else
                    implied[name] = newImplied;
            };

            var warnUnused = function (name, token) {
                var line = token.line;
                var chr  = token.character;

                if (option.unused)
                    warningAt("'{a}' is defined but never used.", line, chr, name);

                unuseds.push({
                    name: name,
                    line: line,
                    character: chr
                });
            };

            var checkUnused = function (func, key) {
                var type = func[key];
                var token = func["(tokens)"][key];

                if (key.charAt(0) === "(")
                    return;

                if (type !== "unused" && type !== "unction")
                    return;

                // Params are checked separately from other variables.
                if (func["(params)"] && func["(params)"].indexOf(key) !== -1)
                    return;

                warnUnused(key, token);
            };

            // Check queued 'x is not defined' instances to see if they're still undefined.
            for (i = 0; i < JSHINT.undefs.length; i += 1) {
                k = JSHINT.undefs[i].slice(0);

                if (markDefined(k[2].value, k[0])) {
                    clearImplied(k[2].value, k[2].line);
                } else {
                    warning.apply(warning, k.slice(1));
                }
            }

            functions.forEach(function (func) {
                for (var key in func) {
                    if (is_own(func, key)) {
                        checkUnused(func, key);
                    }
                }

                if (!func["(params)"])
                    return;

                var params = func["(params)"].slice();
                var param  = params.pop();
                var type;

                while (param) {
                    type = func[param];

                    // 'undefined' is a special case for (function (window, undefined) { ... })();
                    // patterns.

                    if (param === "undefined")
                        return;

                    if (type !== "unused" && type !== "unction")
                        return;

                    warnUnused(param, func["(tokens)"][param]);
                    param = params.pop();
                }
            });

            for (var key in declared) {
                if (is_own(declared, key) && !is_own(global, key)) {
                    warnUnused(key, declared[key]);
                }
            }
        } catch (e) {
            if (e) {
                var nt = nexttoken || {};
                JSHINT.errors.push({
                    raw       : e.raw,
                    reason    : e.message,
                    line      : e.line || nt.line,
                    character : e.character || nt.from
                }, null);
            }
        }

        // Loop over the listed "internals", and check them as well.

        if (JSHINT.scope === "(main)") {
            o = o || {};

            for (i = 0; i < JSHINT.internals.length; i += 1) {
                k = JSHINT.internals[i];
                o.scope = k.elem;
                itself(k.value, o, g);
            }
        }

        return JSHINT.errors.length === 0;
    };

    // Data summary.
    itself.data = function () {
        var data = {
            functions: [],
            options: option
        };
        var implieds = [];
        var members = [];
        var fu, f, i, j, n, globals;

        if (itself.errors.length) {
            data.errors = itself.errors;
        }

        if (jsonmode) {
            data.json = true;
        }

        for (n in implied) {
            if (is_own(implied, n)) {
                implieds.push({
                    name: n,
                    line: implied[n]
                });
            }
        }

        if (implieds.length > 0) {
            data.implieds = implieds;
        }

        if (urls.length > 0) {
            data.urls = urls;
        }

        globals = Object.keys(scope);
        if (globals.length > 0) {
            data.globals = globals;
        }

        for (i = 1; i < functions.length; i += 1) {
            f = functions[i];
            fu = {};

            for (j = 0; j < functionicity.length; j += 1) {
                fu[functionicity[j]] = [];
            }

            for (j = 0; j < functionicity.length; j += 1) {
                if (fu[functionicity[j]].length === 0) {
                    delete fu[functionicity[j]];
                }
            }

            fu.name = f["(name)"];
            fu.param = f["(params)"];
            fu.line = f["(line)"];
            fu.character = f["(character)"];
            fu.last = f["(last)"];
            fu.lastcharacter = f["(lastcharacter)"];
            data.functions.push(fu);
        }

        if (unuseds.length > 0) {
            data.unused = unuseds;
        }

        members = [];
        for (n in member) {
            if (typeof member[n] === "number") {
                data.member = member;
                break;
            }
        }

        return data;
    };

    itself.jshint = itself;

    return itself;
}());

// Make JSHINT a Node module, if possible.
if (typeof exports === "object" && exports) {
    exports.JSHINT = JSHINT;
};// CodeMirror version 3.1
//
// CodeMirror is the only global var we claim
window.CodeMirror = (function() {
  "use strict";

  // BROWSER SNIFFING

  // Crude, but necessary to handle a number of hard-to-feature-detect
  // bugs and behavior differences.
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);

  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version) opera_version = Number(opera_version[1]);
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || (ie && !ie_lt9);

  // Optimize some code when these features are not used
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // CONSTRUCTOR

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
      options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);

    var docStart = typeof options.value == "string" ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile) focusInput(this);

    this.state = {keyMaps: [],
                  overlays: [],
                  modeGen: 0,
                  overwrite: false, focused: false,
                  suppressEdits: false, pasteIncoming: false,
                  draggingText: false,
                  highlight: new Delayed()};

    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie) setTimeout(bind(resetInput, this, true), 20);

    registerEventHandlers(this);
    // IE throws unspecified error in certain cases, when
    // trying to access activeElement before onload
    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }
    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);
    else onBlur(this);

    operation(this, function() {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    })();
  }

  // DISPLAY CONSTRUCTOR

  function makeDisplay(place, docStart) {
    var d = {};
    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none;");
    if (webkit) input.style.width = "1000px";
    else input.setAttribute("wrap", "off");
    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off");
    // Wraps and hides input textarea
    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The actual fake scrollbars.
    d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");
    d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    // DIVs containing the selection and the actual code
    d.lineDiv = elt("div");
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    // Blinky cursor, and element used to ensure cursor fits at the end of a line
    d.cursor = elt("div", "\u00a0", "CodeMirror-cursor");
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    d.otherCursor = elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");
    // Used to measure text size
    d.measure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],
                         null, "position: relative; outline: none");
    // Moved around its parent to cover visible view
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the text, causes scrolling
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers
    d.heightForcer = elt("div", "\u00a0", null, "position: absolute; height: " + scrollerCutOff + "px");
    // Will contain the gutters, if any
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Helper element to properly size the gutter backgrounds
    var scrollerInner = elt("div", [d.sizer, d.heightForcer, d.gutters], null, "position: relative; min-height: 100%");
    // Provides scrolling
    d.scroller = elt("div", [scrollerInner], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,
                            d.scrollbarFiller, d.scroller], "CodeMirror");
    // Work around IE7 z-index bug
    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);

    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";

    // Current visible range (may be bigger than the view window).
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = "";
    // Set to true when a non-horizontal-scrolling widget is added. As
    // an optimization, widget aligning is skipped when d is false.
    d.alignWidgets = false;
    // Flag that indicates whether we currently expect input to appear
    // (after some event like 'keypress' or 'input') and are polling
    // intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();
    // True when a drag from the editor is active
    d.draggingText = false;

    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;

    // Tracks when resetInput has punted to just putting a short
    // string instead of the (large) selection.
    d.inaccurateSelection = false;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    return d;
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += " CodeMirror-wrap";
      cm.display.sizer.style.minWidth = "";
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm.display, cm.doc.height);}, 100);
  }

  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function keyMapChanged(cm) {
    var style = keyMap[cm.options.keyMap].style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
      (style ? " cm-keymap-" + style : "");
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
  }

  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
  }

  function lineLength(doc, line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == "CodeMirror-linenumbers") {
        if (options.lineNumbers) found = true;
        else options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push("CodeMirror-linenumbers");
  }

  // SCROLLBARS

  // Re-synchronize the fake scrollbars with the actual size of the
  // content. Optionally force a scrollTop.
  function updateScrollbars(d /* display */, docHeight) {
    var totalHeight = docHeight + 2 * paddingTop(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth;
    var needsV = scrollHeight > d.scroller.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = "block";
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarV.firstChild.style.height =
        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + "px";
    } else d.scrollbarV.style.display = "";
    if (needsH) {
      d.scrollbarH.style.display = "block";
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarH.firstChild.style.width =
        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + "px";
    } else d.scrollbarH.style.display = "";
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
    } else d.scrollbarFiller.style.display = "";

    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";
  }

  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == "number") top = viewPort;
    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};
  }

  // LINE NUMBERS

  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + "px";
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {
      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }

  // DISPLAY DRAWING

  function updateDisplay(cm, changes, viewPort) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo;
    var updated = updateDisplayInner(cm, changes, viewPort);
    if (updated) {
      signalLater(cm, "update", cm);
      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
        signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);
    }
    updateSelection(cm);
    updateScrollbars(cm.display, cm.doc.height);

    return updated;
  }

  // Uses a set of changes plus the current scroll position to
  // determine which DOM updates have to be made, and makes the
  // updates.
  function updateDisplayInner(cm, changes, viewPort) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }

    // Compute the new visible window
    // If scrollTop is specified, use that to determine which lines
    // to render instead of the current scrollbar position.
    var visible = visibleLines(display, doc, viewPort);
    // Bail out if the visible area is already rendered and nothing changed.
    if (changes.length == 0 &&
        visible.from > display.showingFrom && visible.to < display.showingTo)
      return;

    if (maybeUpdateLineNumberWidth(cm))
      changes = [{from: doc.first, to: doc.first + doc.size}];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";

    // Used to determine which lines need their line numbers updated
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) { positionsChangedFrom = changes[i].from; break; }

    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;
    }

    // Create a range of theoretically intact lines, and punch holes
    // in that using the change info.
    var intact = [{from: Math.max(display.showingFrom, doc.first),
                   to: Math.min(display.showingTo, end)}];
    if (intact[0].from >= intact[0].to) intact = [];
    else intact = computeIntact(intact, changes);
    // When merged lines are present, we might have to reduce the
    // intact ranges because changes in continued fragments of the
    // intact lines do require the lines to be redrawn.
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from) range.to = newTo;
          else { intact.splice(i--, 1); break; }
        }
      }

    // Clip off the parts that won't be visible
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from) range.from = from;
      if (range.to > to) range.to = to;
      if (range.from >= range.to) intact.splice(i--, 1);
      else intactLines += range.to - range.from;
    }
    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function(a, b) {return a.from - b.from;});

    var focused = document.activeElement;
    if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = "";
    if (document.activeElement != focused && focused.offsetHeight) focused.focus();

    var different = from != display.showingFrom || to != display.showingTo ||
      display.lastSizeC != display.wrapper.clientHeight;
    // This is just a bogus formula that detects when the editor is
    // resized or the font size changes.
    if (different) display.lastSizeC = display.wrapper.clientHeight;
    display.showingFrom = from; display.showingTo = to;
    startWorker(cm, 100);

    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {
      if (ie_lt8) {
        var bot = node.offsetTop + node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = getRect(node);
        height = box.bottom - box.top;
      }
      var diff = node.lineObj.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(node.lineObj, height);
        var widgets = node.lineObj.widgets;
        if (widgets) for (var i = 0; i < widgets.length; ++i)
          widgets[i].height = widgets[i].node.offsetHeight;
      }
    }
    updateViewOffset(cm);

    if (visibleLines(display, doc, viewPort).to > to)
      updateDisplayInner(cm, [], viewPort);
    return true;
  }

  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    // Position the mover div to align with the current virtual scroll position
    cm.display.mover.style.top = off + "px";
  }

  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({from: range.from + diff, to: range.to + diff});
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({from: range.from, to: change.from});
          if (change.to < range.to)
            intact2.push({from: change.to + diff, to: range.to + diff});
        }
      }
      intact = intact2;
    }
    return intact;
  }

  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }

    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function(line) {
      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0) updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i)
          if (line.widgets[i].showIfHidden) {
            var prev = cur.previousSibling;
            if (/pre/i.test(prev.nodeName)) {
              var wrap = elt("div", null, null, "position: relative");
              prev.parentNode.replaceChild(wrap, prev);
              wrap.appendChild(prev);
              prev = wrap;
            }
            var wnode = prev.appendChild(elt("div", [line.widgets[i].node], "CodeMirror-linewidget"));
            positionLineWidget(line.widgets[i], wnode, prev, dims);
          }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        // This line is intact. Skip to the actual node. Update its
        // line number if needed.
        while (cur.lineObj != line) cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        // For lines with widgets, make an attempt to find and reuse
        // the existing element, so that widgets aren't needlessly
        // removed and re-inserted into the dom
        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }
        // This line needs to be generated.
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse) cur = rm(cur);
          cur = cur.nextSibling;
        }

        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur) cur = rm(cur);
  }

  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;

    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;

    // Lines with gutter elements, widgets or a background class need
    // to be wrapped again, and have the extra elements added to the
    // wrapper div

    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0, first = true; i < line.widgets.length; ++i) {
            var widget = line.widgets[i], isFirst = false;
            if (!widget.above) { isFirst = first; first = false; }
            if (widget.node == n.firstChild) {
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              if (isFirst) reuse.insertBefore(lineElement, n);
              break;
            }
          }
          if (i == line.widgets.length) { isOk = false; break; }
        }
      }
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || "";
      }
    }
    if (!wrap) {
      wrap = elt("div", null, line.wrapClass, "position: relative");
      wrap.appendChild(lineElement);
    }
    // Kludge to make sure the styled element lies behind the selection (by z-index)
    if (line.bgClass)
      wrap.insertBefore(elt("div", "\u00a0", line.bgClass + " CodeMirror-linebackground"), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt("div", null, null, "position: absolute; left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),
                                         wrap.firstChild);
      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        wrap.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineNo),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + display.lineNumInnerWidth + "px"));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
        }
    }
    if (ie_lt8) wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      positionLineWidget(widget, node, wrap, dims);
      if (widget.above)
        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
    return wrap;
  }

  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // SELECTION / CURSOR

  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = "none";
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = "none";

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    var headPos = cursorCoords(cm, cm.doc.sel.head, "div");
    var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
    display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                                      headPos.top + lineOff.top - wrapOff.top)) + "px";
    display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                                       headPos.left + lineOff.left - wrapOff.left)) + "px";
  }

  // No selection, plain cursor
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, "div");
    display.cursor.style.left = pos.left + "px";
    display.cursor.style.top = pos.top + "px";
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
    display.cursor.style.display = "";

    if (pos.other) {
      display.otherCursor.style.display = "";
      display.otherCursor.style.left = pos.other.left + "px";
      display.otherCursor.style.top = pos.other.top + "px";
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    } else { display.otherCursor.style.display = "none"; }
  }

  // Highlight selection
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg, retTop) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length, rVal = retTop ? Infinity : -Infinity;
      function coords(ch) {
        return charCoords(cm, Pos(line, ch), "div", lineObj);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(dir == "rtl" ? to - 1 : from);
        var rightPos = coords(dir == "rtl" ? from : to - 1);
        var left = leftPos.left, right = rightPos.right;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = clientWidth;
        if (fromArg == null && from == 0) left = pl;
        rVal = retTop ? Math.min(rightPos.top, rVal) : Math.max(rightPos.bottom, rVal);
        if (left < pl + 1) left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return rVal;
    }

    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromObj = getLine(doc, sel.from.line);
      var cur = fromObj, merged, path = [sel.from.line, sel.from.ch], singleLine;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found = merged.find();
        path.push(found.from.ch, found.to.line, found.to.ch);
        if (found.to.line == sel.to.line) {
          path.push(sel.to.ch);
          singleLine = true;
          break;
        }
        cur = getLine(doc, found.to.line);
      }

      // This is a single, merged line
      if (singleLine) {
        for (var i = 0; i < path.length; i += 3)
          drawForLine(path[i], path[i+1], path[i+2]);
      } else {
        var middleTop, middleBot, toObj = getLine(doc, sel.to.line);
        if (sel.from.ch)
          // Draw the first line of selection.
          middleTop = drawForLine(sel.from.line, sel.from.ch, null, false);
        else
          // Simply include it in the middle block.
          middleTop = heightAtLine(cm, fromObj) - display.viewOffset;

        if (!sel.to.ch)
          middleBot = heightAtLine(cm, toObj) - display.viewOffset;
        else
          middleBot = drawForLine(sel.to.line, collapsedSpanAtStart(toObj) ? null : 0, sel.to.ch, true);

        if (middleTop < middleBot) add(pl, middleTop, null, middleBot);
      }
    }

    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = "";
  }

  // Cursor-blinking
  function restartBlink(cm) {
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = "";
    display.blinker = setInterval(function() {
      if (!display.cursor.offsetHeight) return;
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";
    }, cm.options.cursorBlinkRate);
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {
      if (doc.frontier >= cm.display.showingFrom) { // Visible
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;
          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function() {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n) {
    var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));
    return e.offsetLeft;
  }

  function measureChar(cm, line, ch, data) {
    var dir = -1;
    data = data || measureLine(cm, line);

    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r) break;
      if (dir < 0 && pos == 0) dir = 1;
    }
    return {left: pos < ch ? r.right : r.left,
            right: pos > ch ? r.left : r.right,
            top: r.top, bottom: r.bottom};
  }

  function measureLine(cm, line) {
    // First look in the cache
    var display = cm.display, cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&
          display.scroller.clientWidth == memo.width &&
          memo.classes == line.textClass + "|" + line.bgClass + "|" + line.wrapClass)
        return memo.measure;
    }

    var measure = measureLineInner(cm, line);
    // Store result in the cache
    var memo = {text: line.text, width: display.scroller.clientWidth,
                markedSpans: line.markedSpans, measure: measure,
                classes: line.textClass + "|" + line.bgClass + "|" + line.wrapClass};
    if (cache.length == 16) cache[++display.measureLineCachePos % 16] = memo;
    else cache.push(memo);
    return measure;
  }

  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure);

    // IE does not cache element positions of inline elements between
    // calls to getBoundingClientRect. This makes the loop below,
    // which gathers the positions of all the characters on the line,
    // do an amount of layout work quadratic to the number of
    // characters. When line wrapping is off, we try to improve things
    // by first subdividing the line into a bunch of inline blocks, so
    // that IE can reuse most of the layout information from caches
    // for those blocks. This does interfere with line wrapping, so it
    // doesn't work when wrapping is on, but in that case the
    // situation is slightly better, since IE does cache line-wrapping
    // information and only recomputes per-line.
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt("div", null, null, "display: inline-block");
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }

    removeChildrenAndAdd(display.measure, pre);

    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    // Work around an IE7/8 bug where it will sometimes have randomly
    // replaced our pre with a clone at this point.
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);

    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {
      var size = getRect(cur);
      var top = Math.max(0, size.top - outer.top), bot = Math.min(size.bottom - outer.top, maxBot);
      for (var j = 0; j < vranges.length; j += 2) {
        var rtop = vranges[j], rbot = vranges[j+1];
        if (rtop > bot || rbot < top) continue;
        if (rtop <= top && rbot >= bot ||
            top <= rtop && bot >= rbot ||
            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {
          vranges[j] = Math.min(top, rtop);
          vranges[j+1] = Math.max(bot, rbot);
          break;
        }
      }
      if (j == vranges.length) vranges.push(top, bot);
      var right = size.right;
      if (cur.measureRight) right = getRect(cur.measureRight).left;
      data[i] = {left: size.left - outer.left, right: right - outer.left, top: j};
    }
    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {
      var vr = cur.top;
      cur.top = vranges[vr]; cur.bottom = vranges[vr+1];
    }
    if (!cm.options.lineWrapping) {
      var last = pre.lastChild;
      if (last.nodeType == 3) last = pre.appendChild(elt("span", "\u200b"));
      data.width = getRect(last).right - outer.left;
    }

    return data;
  }

  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(cm, lineObj);
    if (context != "local") yOff -= cm.display.viewOffset;
    if (context == "page") {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      var xOff = lOff.left + (window.pageXOffset || (document.documentElement || document.body).scrollLeft);
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  function charCoords(cm, pos, context, lineObj) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch), context);
  }

  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement) measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var main, other, linedir = order[0].level;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i], rtl = part.level % 2, nb, here;
      if (part.from < ch && part.to > ch) return get(ch, rtl);
      var left = rtl ? part.to : part.from, right = rtl ? part.from : part.to;
      if (left == ch) {
        // IE returns bogus offsets and widths for edges where the
        // direction flips, but only for the side with the lower
        // level. So we try to use the side with the higher level.
        if (i && part.level < (nb = order[i-1]).level) here = get(nb.level % 2 ? nb.from : nb.to - 1, true);
        else here = get(rtl && part.from != part.to ? ch - 1 : ch);
        if (rtl == linedir) main = here; else other = here;
      } else if (right == ch) {
        var nb = i < order.length - 1 && order[i+1];
        if (!rtl && nb && nb.from == nb.to) continue;
        if (nb && part.level < nb.level) here = get(nb.level % 2 ? nb.to - 1 : nb.from);
        else here = get(rtl ? ch : ch - 1, true);
        if (rtl == linedir) main = here; else other = here;
      }
    }
    if (linedir && !ch) other = get(order[0].to - 1);
    if (!main) return other;
    if (other) main.other = other;
    return main;
  }

  function PosMaybeOutside(line, ch, outside) {
    var pos = new Pos(line, ch);
    if (outside) pos.outside = true;
    return pos;
  }

  // Coords must be lineSpace-local
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosMaybeOutside(doc.first, 0, true);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosMaybeOutside(doc.first + doc.size - 1, getLine(doc, last).text.length, true);
    if (x < 0) x = 0;

    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && found.ch >= mergedPos.from.ch)
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, cWidth = cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line",
                            lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom) return Math.max(0, sp.left - cWidth);
      else if (innerOff < sp.top) return sp.left + cWidth;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosMaybeOutside(lineNo, to, toOutside);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var after = x - fromX < toX - x, ch = after ? from : to;
        while (isExtendingChar.test(lineObj.text.charAt(ch))) ++ch;
        var pos = PosMaybeOutside(lineNo, ch, after ? fromOutside : toOutside);
        pos.after = after;
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist -= step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist = step;}
    }
  }

  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "x");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap changes in such a way that each
  // change won't have to update the cursor and display (which would
  // be awkward, slow, and error-prone), but instead updates are
  // batched and then all combined and executed at once.

  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      // An array of ranges of lines that have to be updated. See
      // updateDisplay.
      changes: [],
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++) delayedCallbacks = [];
  }

  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;

    if (op.updateMaxLine) computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      var width = measureLine(cm, display.maxLine).width;
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null)
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);
    if (!updated && op.selectionChanged) updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);

    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, "change", cm, op.textChanged);
    if (op.selectionChanged) signal(cm, "cursorActivity", cm);
    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm1, f) {
    return function() {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp) startOperation(cm);
      try { var result = f.apply(cm, arguments); }
      finally { if (withOp) endOperation(cm); }
      return result;
    };
  }
  function docOperation(f) {
    return function() {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp) startOperation(this.cm);
      try { result = f.apply(this, arguments); }
      finally { if (withOp) endOperation(this.cm); }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp) startOperation(cm);
    try { result = f(); }
    finally { if (withOp) endOperation(cm); }
    return result;
  }

  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({from: from, to: to, diff: lendiff});
  }

  // INPUT HANDLING

  function slowPoll(cm) {
    if (cm.display.pollingFast) return;
    cm.display.poll.set(cm.options.pollInterval, function() {
      readInput(cm);
      if (cm.state.focused) slowPoll(cm);
    });
  }

  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
      else {cm.display.pollingFast = false; slowPoll(cm);}
    }
    cm.display.poll.set(20, p);
  }

  // prevInput is a hack to work with IME. If we reset the textarea
  // on every change, that breaks IME. So we look for changes
  // compared to the previous content instead. (Modern browsers have
  // events that indicate IME taking place, but these are not widely
  // supported or compatible enough yet to rely on.)
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm)) return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to)) return false;
    // IE enjoys randomly deselecting our input's text when
    // re-focusing. If the selection is gone but the cursor is at the
    // start of the input, that's probably what happened.
    if (ie && text && input.selectionStart === 0) {
      resetInput(cm, true);
      return false;
    }
    var withOp = !cm.curOp;
    if (withOp) startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput[same] == text[same]) ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));
    var updateInput = cm.curOp.updateInput;
    makeChange(cm.doc, {from: from, to: to, text: splitLines(text.slice(same)),
                        origin: cm.state.pasteIncoming ? "paste" : "+input"}, "end");

    cm.curOp.updateInput = updateInput;
    if (text.length > 1000) input.value = cm.display.prevInput = "";
    else cm.display.prevInput = text;
    if (withOp) endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }

  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = "";
      minimal = hasCopyEvent &&
        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      if (minimal) cm.display.input.value = "-";
      else cm.display.input.value = selected || cm.getSelection();
      if (cm.state.focused) selectInput(cm.display.input);
    } else if (user) cm.display.prevInput = cm.display.input.value = "";
    cm.display.inaccurateSelection = minimal;
  }

  function focusInput(cm) {
    if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // EVENT HANDLERS

  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    on(d.scroller, "dblclick", operation(cm, e_preventDefault));
    on(d.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(d, e)) e_preventDefault(e);
    });
    // Gecko browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for Gecko.
    if (!captureMiddleClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    on(d.scroller, "scroll", function() {
      setScrollTop(cm, d.scroller.scrollTop);
      setScrollLeft(cm, d.scroller.scrollLeft, true);
      signal(cm, "scroll", cm);
    });
    on(d.scrollbarV, "scroll", function() {
      setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, "scroll", function() {
      setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });

    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }
    on(d.scrollbarH, "mousedown", reFocus);
    on(d.scrollbarV, "mousedown", reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    function onResize() {
      // Might be a text scaling operation, clear size caches.
      d.cachedCharWidth = d.cachedTextHeight = null;
      clearCaches(cm);
      runInOp(cm, bind(regChange, cm));
    }
    on(window, "resize", onResize);
    // Above handler holds on to the editor and its data structures.
    // Here we poll to unregister it when the editor is no longer in
    // the document, so that it can be garbage-collected.
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}
      if (p) setTimeout(unregister, 5000);
      else off(window, "resize", onResize);
    }
    setTimeout(unregister, 5000);

    on(d.input, "keyup", operation(cm, function(e) {
      if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
      if (e.keyCode == 16) cm.doc.sel.shift = false;
    }));
    on(d.input, "input", bind(fastPoll, cm));
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));

    function drag_(e) {
      if (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }
    on(d.scroller, "paste", function(e){
      if (eventInWidget(d, e)) return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, "paste", function() {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });

    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = "";
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, "cut", prepareCopy);
    on(d.input, "copy", prepareCopy);

    // Needed to handle Tab key in KHTML
    if (khtml) on(d.sizer, "mouseup", function() {
        if (document.activeElement == d.input) d.input.blur();
        focusInput(cm);
    });
  }

  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n) return true;
      if (/\bCodeMirror-(?:line)?widget\b/.test(n.className) ||
          n.parentNode == display.sizer && n != display.mover) return true;
    }
  }

  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||
          target == display.scrollbarV || target == display.scrollbarV.firstChild ||
          target == display.scrollbarFiller) return null;
    }
    var x, y, space = getRect(display.lineSpace);
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }
    return coordsChar(cm, x - space.left, y - space.top);
  }

  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);

    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick) onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start) extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    // For button 1, if it was clicked inside the editor
    // (posFromMouse returning non-null), we have to adjust the
    // selection.
    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}

    if (!cm.state.focused) onFocus(cm);

    var now = +new Date, type = "single";
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = "triple";
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else { lastClick = {time: now, pos: start}; }

    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&
        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {
      var dragEnd = operation(cm, function(e2) {
        if (webkit) display.scroller.draggable = false;
        cm.state.draggingText = false;
        off(document, "mouseup", dragEnd);
        off(display.scroller, "drop", dragEnd);
        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
          e_preventDefault(e2);
          extendSelection(cm.doc, start);
          focusInput(cm);
        }
      });
      // Let the drag handler handle this.
      if (webkit) display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      // IE's approach to draggable
      if (display.scroller.dragDrop) display.scroller.dragDrop();
      on(document, "mouseup", dragEnd);
      on(display.scroller, "drop", dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == "single") extendSelection(cm.doc, clipPos(doc, start));

    var startstart = sel.from, startend = sel.to;

    function doSelect(cur) {
      if (type == "single") {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }

      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == "double") {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);
        else extendSelection(cm.doc, startstart, word.to);
      } else if (type == "triple") {
        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }

    var editorSize = getRect(display.wrapper);
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur) return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused) onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      var cur = posFromMouse(cm, e);
      if (cur) doSelect(cur);
      e_preventDefault(e);
      focusInput(cm);
      off(document, "mousemove", move);
      off(document, "mouseup", up);
    }

    var move = operation(cm, function(e) {
      if (!ie && !e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  function onDrop(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))
      return;
    e_preventDefault(e);
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            replaceRange(cm.doc, text.join(""), pos, "around", "paste");
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else {
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");
          cm.replaceSelection(text, null, "paste");
          focusInput(cm);
          onFocus(cm);
        }
      }
      catch(e){}
    }
  }

  function clickInGutter(cm, e) {
    var display = cm.display;
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }

    if (mX >= Math.floor(getRect(display.gutters).right)) return false;
    e_preventDefault(e);
    if (!hasHandler(cm, "gutterClick")) return true;

    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom) return true;
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, "gutterClick", cm, line, gutter, e);
        break;
      }
    }
    return true;
  }

  function onDragStart(cm, e) {
    if (eventInWidget(cm.display, e)) return;

    var txt = cm.getSelection();
    e.dataTransfer.setData("Text", txt);

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera) img.parentNode.removeChild(img);
    }
  }

  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
    if (gecko) updateDisplay(cm, []);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }

    var display = cm.display, scroll = display.scroller;
    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    maps.push(cm.options.keyMap);
    if (cm.options.extraKeys) maps.unshift(cm.options.extraKeys);
    return maps;
  }

  var maybeTransition;
  function handleKeyBinding(cm, e) {
    // Handle auto keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
      if (getKeyMap(cm.options.keyMap) == startMap)
        cm.options.keyMap = (next.call ? next.call(null, cm) : next);
    }, 50);

    var name = keyName(e, true), handled = false;
    if (!name) return false;
    var keymaps = allKeyMaps(cm);

    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})
             || lookupKey(name, keymaps, function(b) {
                  if (typeof b == "string" && /^go[A-Z]/.test(b)) return doHandleBinding(cm, b);
                });
    } else {
      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });
    }
    if (handled == "stop") handled = false;

    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }
    }
    return handled;
  }

  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                            function(b) { return doHandleBinding(cm, b, true); });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return handled;
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused) onFocus(cm);
    if (ie && e.keyCode == 27) { e.returnValue = false; }
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
    var code = e.keyCode;
    // IE does strange things with escape.
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    // First give onKeyEvent option a chance to handle this.
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("");
    }
  }

  function onKeyPress(e) {
    var cm = this;
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars &&
        this.options.smartIndent && !isReadOnly(this) &&
        this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function() {indentLine(cm, cm.doc.sel.to.line, "smart");}), 75);
    if (handleCharBinding(cm, e, ch)) return;
    fastPoll(cm);
  }

  function onFocus(cm) {
    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += " CodeMirror-focused";
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);
  }

  var detectingSelectAll;
  function onContextMenu(cm, e) {
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e)) return;

    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera) return; // Opera is difficult.
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);

    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = "absolute";
    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; outline: none;" +
      "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";
    focusInput(cm);
    resetInput(cm, true);
    // Adds "Select all" to context menu in FF
    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";

    function rehide() {
      display.inputDiv.style.position = "relative";
      display.input.style.cssText = oldCSS;
      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);

      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null && (!ie || ie_lt9)) {
        clearTimeout(detectingSelectAll);
        var extval = display.input.value = " " + (posEq(sel.from, sel.to) ? "" : display.input.value), i = 0;
        display.prevInput = " ";
        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
        var poll = function(){
          if (display.prevInput == " " && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);
          else resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }

  // UPDATING

  function changeEnd(change) {
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }

  // Make sure a position will be valid after the given change.
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos)) return clipPos(doc, pos);
    var diff = (change.text.length - 1) - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +
                       getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }

  // Hint can be null|"end"|"start"|"around"|{anchor,head}
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == "object") // Assumed to be {anchor, head} object
      return {anchor: clipPostChange(doc, change, hint.anchor),
              head: clipPostChange(doc, change, hint.head)};

    if (hint == "start") return {anchor: change.from, head: change.from};

    var end = changeEnd(change);
    if (hint == "around") return {anchor: change.from, head: end};
    if (hint == "end") return {anchor: end, head: end};

    // hint is null, leave the selection alone as much as possible
    var adjustPos = function(pos) {
      if (posLess(pos, change.from)) return pos;
      if (!posLess(change.to, pos)) return end;

      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};
  }

  function filterChange(doc, change) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      update: function(from, to, text, origin) {
        if (from) this.from = clipPos(doc, from);
        if (to) this.to = clipPos(doc, to);
        if (text) this.text = text;
        if (origin !== undefined) this.origin = origin;
      },
      cancel: function() { this.canceled = true; }
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Replace the range from from to to by the strings in replacement.
  // change is a {from, to, text [, origin]} object
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [""]});
      if (split.length)
        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }

  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  function makeChangeFromHistory(doc, type) {
    var hist = doc.history;
    var event = (type == "undo" ? hist.done : hist.undone).pop();
    if (!event) return;
    hist.dirtyCounter += type == "undo" ? -1 : 1;

    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,
                anchorAfter: event.anchorBefore, headAfter: event.headBefore};
    (type == "undo" ? hist.undone : hist.done).push(anti);

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      anti.changes.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change, null)
                    : {anchor: event.anchorBefore, head: event.headBefore};
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];

      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  function shiftDoc(doc, distance) {
    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}
    doc.first += distance;
    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);
  }

  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else updateDoc(doc, change, spans, selAfter);
  }

  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    regChange(cm, from.line, to.line + 1, lendiff);
    if (hasHandler(cm, "change")) {
      var changeObj = {from: from, to: to, text: change.text, origin: change.origin};
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}
        cur.next = changeObj;
      } else cm.curOp.textChanged = changeObj;
    }
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);
  }

  // POSITION OBJECT

  function Pos(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  }
  CodeMirror.Pos = Pos;

  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}
  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}
  function copyPos(x) {return Pos(x.line, x.ch);}

  // SELECTION

  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}

  // If shift is held, this will move the selection anchor. Otherwise,
  // it'll set the whole selection.
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm) doc.cm.curOp.userSelChange = true;
  }

  function filterSelectionChange(doc, anchor, head) {
    var obj = {anchor: anchor, head: head};
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);
    return obj;
  }

  // Update the selection. Last two args are only used by
  // updateDoc, since they have to be expressed in the line
  // numbers before the update.
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }

    var sel = doc.sel;
    sel.goalColumn = null;
    // Skip over atomic spans.
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != "push");

    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;

    sel.anchor = anchor; sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;

    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;

    signalLater(doc, "cursorActivity", doc);
  }

  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");
  }

  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line), toClear;
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear && m.clearOnEnter) {
              (toClear || (toClear = [])).push(m);
              continue;
            } else if (!m.atomic) continue;
            var newPos = m.find()[dir < 0 ? "from" : "to"];
            if (posEq(newPos, curPos)) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
        if (toClear) for (var i = 0; i < toClear.length; ++i) toClear[i].clear();
      }
      return curPos;
    }
  }

  // SCROLLING

  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head);
    if (!cm.state.focused) return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == "none";
      if (hidden) {
        display.cursor.style.display = "";
        display.cursor.style.left = coords.left + "px";
        display.cursor.style.top = (coords.top - display.viewOffset) + "px";
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden) display.cursor.style.display = "none";
    }
  }

  function scrollPosIntoView(cm, pos) {
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) return coords;
    }
  }

  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, pt = paddingTop(display);
    y1 += pt; y2 += pt;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + 2 * pt;
    var atTop = y1 < pt + 10, atBottom = y2 + pt > docBottom - 10;
    if (y1 < screentop) result.scrollTop = atTop ? 0 : Math.max(0, y1);
    else if (y2 > screentop + screen) result.scrollTop = (atBottom ? docBottom : y2) - screen;

    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft) x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }

  // API UTILITIES

  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (!how) how = "add";
    if (how == "smart") {
      if (!cm.doc.mode.indent) how = "prev";
      else var state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == "smart") {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    line.stateAfter = null;
  }

  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no)) regChange(cm, no, no + 1);
    else return null;
    return line;
  }

  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word") {
      var sawWord = false;
      for (;;) {
        if (dir < 0) if (!moveOnce()) break;
        if (isWordChar(lineObj.text.charAt(ch))) sawWord = true;
        else if (sawWord) {if (dir < 0) {dir = 1; moveOnce();} break;}
        if (dir > 0) if (!moveOnce()) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), dir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * pageSize;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if (pos.after === false || end == line.length) --start; else ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar :
        /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);} :
      function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
      while (start > 0 && check(line.charAt(start - 1))) --start;
      while (end < line.length && check(line.charAt(end))) ++end;
    }
    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};
  }

  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }

  // PROTOTYPE

  // The publicly visible API. Note that operation(null, f) means
  // 'wrap f in an operation, performed on its `this` parameter'

  CodeMirror.prototype = {
    focus: function(){window.focus(); focusInput(this); onFocus(this); fastPoll(this);},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map) {
      this.state.keyMaps.push(map);
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if ((typeof map == "string" ? maps[i].name : maps[i]) == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: operation(null, function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        if (overlays[i].modeSpec == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: operation(null, function(n, dir, aggressive) {
      if (typeof dir != "string") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function(how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {start: stream.start,
              end: stream.pos,
              string: stream.current(),
              className: style || null, // Deprecated, use 'type' instead
              type: style || null,
              state: state};
    },

    getStateAfter: function(line) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1);
    },

    cursorCoords: function(start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null) pos = sel.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords) {
      var off = getRect(this.display.lineSpace);
      var scrollY = window.pageYOffset || (document.documentElement || document.body).scrollTop;
      var scrollX = window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      return coordsChar(this, coords.left - off.left - scrollX, coords.top - off.top - scrollY);
    },

    defaultTextHeight: function() { return textHeight(this.display); },

    setGutterMarker: operation(null, function(line, gutterID, value) {
      return changeLine(this, line, function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: operation(null, function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    addLineClass: operation(null, function(handle, where, cls) {
      return changeLine(this, handle, function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (new RegExp("\\b" + cls + "\\b").test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),

    removeLineClass: operation(null, function(handle, where, cls) {
      return changeLine(this, handle, function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var upd = cur.replace(new RegExp("^" + cls + "\\b\\s*|\\s*\\b" + cls + "\\b"), "");
          if (upd == cur) return false;
          line[prop] = upd || null;
        }
        return true;
      });
    }),

    addLineWidget: operation(null, function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),

    removeLineWidget: function(widget) { widget.clear(); },

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = (top + paddingTop(display)) + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: operation(null, onKeyDown),

    execCommand: function(cmd) {return commands[cmd](this);},

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: operation(null, function(dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),

    deleteH: operation(null, function(dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");
      else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");
      this.curOp.userSelChange = true;
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: operation(null, function(dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, "div");
      if (sel.goalColumn != null) pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);

      if (unit == "page")
        this.display.scrollbarV.scrollTop += charCoords(this, target, "div").top - pos.top;
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),

    toggleOverwrite: function() {
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += " CodeMirror-overwrite";
      else
        this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");
    },

    scrollTo: operation(null, function(x, y) {
      this.curOp.updateScrollPos = {scrollLeft: x, scrollTop: y};
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};
    },

    scrollIntoView: function(pos) {
      if (typeof pos == "number") pos = Pos(pos, 0);
      if (!pos || pos.line != null) {
        pos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        scrollPosIntoView(this, pos);
      } else {
        scrollIntoView(this, pos.left, pos.top, pos.right, pos.bottom);
      }
    },

    setSize: function(width, height) {
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) this.display.wrapper.style.width = interpret(width);
      if (height != null) this.display.wrapper.style.height = interpret(height);
      this.refresh();
    },

    on: function(type, f) {on(this, type, f);},
    off: function(type, f) {off(this, type, f);},

    operation: function(f){return runInOp(this, f);},

    refresh: operation(null, function() {
      clearCaches(this);
      this.curOp.updateScrollPos = {scrollTop: this.doc.scrollTop, scrollLeft: this.doc.scrollLeft};
      regChange(this);
    }),

    swapDoc: operation(null, function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.curOp.updateScrollPos = {scrollTop: doc.scrollTop, scrollLeft: doc.scrollLeft};
      return old;
    }),

    getInputField: function(){return this.display.input;},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };

  // OPTION DEFAULTS

  var optionHandlers = CodeMirror.optionHandlers = {};

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("electricChars", true);
  option("rtlMoveVisually", !windows);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", keyMapChanged);
  option("extraKeys", null);

  option("onKeyEvent", null);
  option("onDragEvent", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {onBlur(cm); cm.display.input.blur();}
    else if (!val) resetInput(cm, true);
  });
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorHeight", 1);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true);
  option("pollInterval", 100);
  option("undoDepth", 40, function(cm, val){cm.doc.history.undoDepth = val;});
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);

  option("tabindex", null, function(cm, val) {
    cm.display.input.tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec))
      spec = mimeModes[spec];
    else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
      return CodeMirror.resolveMode("application/xml");
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  CodeMirror.getMode = function(options, spec) {
    spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    return modeObj;
  };

  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };

  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because modes
  // sometimes need to do this.
  function copyState(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;

  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},
    killLine: function(cm) {
      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
      if (!sel && cm.getLine(from.line).length == from.ch)
        cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");
      else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");
    },
    deleteLine: function(cm) {
      var l = cm.getCursor().line;
      cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelection(lineStart(cm, cm.getCursor().line));
    },
    goLineStartSmart: function(cm) {
      var cur = cm.getCursor(), start = lineStart(cm, cur.line);
      var line = cm.getLineHandle(start.line);
      var order = getOrder(line);
      if (!order || order[0].level == 0) {
        var firstNonWS = Math.max(0, line.text.search(/\S/));
        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
      } else cm.extendSelection(start);
    },
    goLineEnd: function(cm) {
      cm.extendSelection(lineEnd(cm, cm.getCursor().line));
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t", "end", "+input");},
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.replaceSelection("\t", "end", "+input");
    },
    transposeChars: function(cm) {
      var cur = cm.getCursor(), line = cm.getLine(cur.line);
      if (cur.ch > 0 && cur.ch < line.length - 1)
        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),
                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
    },
    newlineAndIndent: function(cm) {
      operation(cm, function() {
        cm.replaceSelection("\n", "end", "+input");
        cm.indentLine(cm.getCursor().line, null, true);
      })();
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };

  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"
  };
  // Note that the save and find-related commands aren't defined by
  // default. Unknown commands are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
    "Ctrl-Left": "goWordLeft", "Ctrl-Right": "goWordRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delWordBefore", "Ctrl-Delete": "delWordAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    fallthrough: "basic"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goWordLeft",
    "Alt-Right": "goWordRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delWordBefore",
    "Ctrl-Alt-Backspace": "delWordAfter", "Alt-Delete": "delWordAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };

  // KEYMAP DISPATCH

  function getKeyMap(val) {
    if (typeof val == "string") return keyMap[val];
    else return val;
  }

  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false) return "stop";
      if (found != null && handle(found)) return true;
      if (map.nofallthrough) return "stop";

      var fallthrough = map.fallthrough;
      if (fallthrough == null) return false;
      if (Object.prototype.toString.call(fallthrough) != "[object Array]")
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done) return done;
      }
      return false;
    }

    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done) return done;
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }
  function keyName(event, noShift) {
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) return false;
    if (event.altKey) name = "Alt-" + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
    if (!noShift && event.shiftKey) name = "Shift-" + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = document.body;
      // doc.activeElement occasionally throws on IE
      try { hasFocus = document.activeElement; } catch(e) {}
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      // Deplorable hack to make the submit method do the right thing.
      on(textarea.form, "submit", save);
      var form = textarea.form, realSubmit = form.submit;
      try {
        var wrappedSubmit = form.submit = function() {
          save();
          form.submit = realSubmit;
          form.submit();
          form.submit = wrappedSubmit;
        };
      } catch(e) {}
    }

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    cm.save = save;
    cm.getTextArea = function() { return textarea; };
    cm.toTextArea = function() {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  // The character stream used by a mode's parser.
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
  }

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == 0;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {return countColumn(this.string, this.start, this.tabSize);},
    indentation: function() {return countColumn(this.string, null, this.tabSize);},
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);}
  };
  CodeMirror.StringStream = StringStream;

  // TEXTMARKERS

  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;

  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null) max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.collapsed && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm);
    }
    if (withOp) endOperation(cm);
    signalLater(this, "clear");
  };

  TextMarker.prototype.find = function() {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null) from = Pos(found, span.from);
        if (span.to != null) to = Pos(found, span.to);
      }
    }
    if (this.type == "bookmark") return from;
    return from && {from: from, to: to};
  };

  TextMarker.prototype.getOptions = function(copyWidget) {
    var repl = this.replacedWith;
    return {className: this.className,
            inclusiveLeft: this.inclusiveLeft, inclusiveRight: this.inclusiveRight,
            atomic: this.atomic,
            collapsed: this.collapsed,
            clearOnEnter: this.clearOnEnter,
            replacedWith: copyWidget ? repl && repl.cloneNode(true) : repl,
            readOnly: this.readOnly,
            startStyle: this.startStyle, endStyle: this.endStyle};
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  function markText(doc, from, to, options, type) {
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type);
    if (type == "range" && !posLess(from, to)) return marker;
    if (options) copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");
    }
    if (marker.collapsed) sawCollapsedSpans = true;

    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {from: null, to: null, marker: marker};
      size += line.text.length;
      if (curLine == from.line) {span.from = from.ch; size -= from.ch;}
      if (curLine == to.line) {span.to = to.ch; size -= line.text.length - to.ch;}
      if (marker.collapsed) {
        if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);
        else updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error("Inserting collapsed marker overlapping an existing one");
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic) reCheckSelection(cm);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], "clear", function(){me.clear();});
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function() {
    return this.primary.find();
  };
  SharedTextMarker.prototype.getOptions = function(copyWidget) {
    var inner = this.primary.getOptions(copyWidget);
    inner.shared = true;
    return inner;
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    linkedDocs(doc, function(doc) {
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  // TEXTMARKER SPANS

  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || marker.type == "bookmark" && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push({from: span.from,
                                to: endsAfter ? null : span.to,
                                marker: marker});
      }
    }
    return nw;
  }

  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || marker.type == "bookmark" && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,
                                to: span.to == null ? null : span.to - endCh,
                                marker: marker});
      }
    }
    return nw;
  }

  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;
        var newParts = [j, 1];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({from: p.from, to: m.from});
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if ((sp.from == null || sp.from < ch) &&
          (sp.to == null || sp.to > ch) &&
          (!found || found.width < sp.marker.width))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAt(line, -1); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAt(line, line.text.length + 1); }

  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }

  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && sp.from == span.to &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }

  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // LINE WIDGETS

  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
    for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.cm = cm;
    this.node = node;
  };
  function widgetOperation(f) {
    return function() {
      var withOp = !this.cm.curOp;
      if (withOp) startOperation(this.cm);
      try {var result = f.apply(this, arguments);}
      finally {if (withOp) endOperation(this.cm);}
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function() {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) this.line.widgets = null;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function() {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(cm, handle, function(line) {
      (line.widgets || (line.widgets = [])).push(widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.display.scroller.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible)
          cm.curOp.updateScrollPos = {scrollTop: cm.doc.scrollTop + widget.height,
                                      scrollLeft: cm.doc.scrollLeft};
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  function makeLine(text, markedSpans, estimateHeight) {
    var line = {text: text};
    attachMarkedSpans(line, markedSpans);
    line.height = estimateHeight ? estimateHeight(line) : 1;
    return line;
  }

  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
    signalLater(line, "change");
  }

  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Run the given mode's parser over a line, update the styles
  // array, which contains alternating fragments of text and CSS
  // classes.
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = cm.options.flattenSpans;
    var curText = "", curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize);
    if (text == "" && mode.blankLine) mode.blankLine(state);
    while (!stream.eol()) {
      var style = mode.token(stream, state);
      if (stream.pos > 5000) {
        flattenSpans = false;
        // Webkit seems to refuse to render text nodes longer than 57444 characters
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      }
      var substr = stream.current();
      stream.start = stream.pos;
      if (!flattenSpans || curStyle != style) {
        if (curText) f(curText, curStyle);
        curText = substr; curStyle = style;
      } else curText = curText + substr;
    }
    if (curText) f(curText, curStyle);
  }

  function highlightLine(cm, line, state) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen];
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(txt, style) {st.push(txt, style);});

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1;
      runMode(cm, line.text, overlay.mode, true, function(txt, style) {
        var start = i, len = txt.length;
        // Ensure there's a token end at the current position, and that i points at it
        while (len) {
          var cur = st[i], len_ = cur.length;
          if (len_ <= len) {
            len -= len_;
          } else {
            st.splice(i, 1, cur.slice(0, len), st[i+1], cur.slice(len));
            len = 0;
          }
          i += 2;
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, txt, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = cur ? cur + " " + style : style;
          }
        }
      });
    }

    return st;
  }

  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array.
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == "" && mode.blankLine) mode.blankLine(state);
    while (!stream.eol() && stream.pos <= 5000) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }

  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style) return null;
    return styleToClassCache[style] ||
      (styleToClassCache[style] = "cm-" + style.replace(/ +/g, " cm-"));
  }

  function lineContent(cm, realLine, measure) {
    var merged, line = realLine, lineBefore, sawBefore, simple = true;
    while (merged = collapsedSpanAtStart(line)) {
      simple = false;
      line = getLine(cm.doc, merged.find().from.line);
      if (!lineBefore) lineBefore = line;
    }

    var builder = {pre: elt("pre"), col: 0, pos: 0, display: !measure,
                   measure: null, addedOne: false, cm: cm};
    if (line.textClass) builder.pre.className = line.textClass;

    do {
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if (measure && sawBefore && line != realLine && !builder.addedOne) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.addedOne = true;
      }
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      sawBefore = line == lineBefore;
      if (next) {
        line = getLine(cm.doc, next.to.line);
        simple = false;
      }
    } while (next);

    if (measure && !builder.addedOne)
      measure[0] = builder.pre.appendChild(simple ? elt("span", "\u00a0") : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode("\u00a0"));

    var order;
    // Work around problem with the reported dimensions of single-char
    // direction spans on IE (issue #1129). See also the comment in
    // cursorCoords.
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to) --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),
                                               span.nextSibling);
      }
    }

    return builder.pre;
  }

  var tokenSpecialChars = /[\t\u0000-\u0019\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle) {
    if (!text) return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          builder.col += tabWidth;
        } else {
          var token = elt("span", "\u2022", "cm-invalidchar");
          token.title = "\\u" + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      return builder.pre.appendChild(elt("span", [content], fullStyle));
    }
    builder.pre.appendChild(content);
  }

  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= "\ud800" && ch < "\udbff" && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && builder.cm.options.lineWrapping &&
                 spanAffectsWrapping.test(text.slice(i - 1, i + 1))) {
        builder.pre.appendChild(elt("wbr"));
      }
      builder.measure[builder.pos] =
        buildToken(builder, ch, style,
                   start && startStyle, i == text.length - 1 && endStyle);
      builder.pos += ch.length;
    }
    if (text.length) builder.addedOne = true;
  }

  function buildCollapsedSpan(builder, size, widget) {
    if (widget) {
      if (!builder.display) widget = widget.cloneNode(true);
      builder.pre.appendChild(widget);
      if (builder.measure && size) {
        builder.measure[builder.pos] = widget;
        builder.addedOne = true;
      }
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, styles[i], styleToClass(styles[i+1]));
      return;
    }

    var allText = line.text, len = allText.length;
    var pos = 0, i = 1, text = "", style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.collapsed && (!collapsed || collapsed.marker.width < m.width))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.replacedWith)
            foundBookmark = m.replacedWith;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,
                             collapsed.from != null && collapsed.marker.replacedWith);
          if (collapsed.to == null) return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed) buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "");
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = styles[i++]; style = styleToClass(styles[i++]);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // First adjust the line structure
    if (from.ch == 0 && to.ch == 0 && lastText == "") {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      updateLine(lastLine, lastLine.text, lastSpans, estimateHeight);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        updateLine(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch),
                   lastSpans, estimateHeight);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(makeLine(text[i], spansFor(i), estimateHeight));
        added.push(makeLine(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        updateLine(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0), estimateHeight);
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      updateLine(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch),
                 spansFor(0), estimateHeight);
      doc.remove(from.line + 1, nlines);
    } else {
      updateLine(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0), estimateHeight);
      updateLine(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans, estimateHeight);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    collapse: function(lines) {
      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));
    },
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;
    },
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([makeLine("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.history = makeHistory();
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    insert: function(at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue"},
                 {head: top, anchor: top}, true);
    },
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},
    setLine: function(line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function(line) {
      if (isLine(this, line))
        replaceRange(this, "", Pos(line, 0), clipPos(this, Pos(line + 1, 0)));
    },

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var sel = this.sel, pos;
      if (start == null || start == "head") pos = sel.head;
      else if (start == "anchor") pos = sel.anchor;
      else if (start == "end" || start === false) pos = sel.to;
      else pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},

    setCursor: docOperation(function(line, ch, extend) {
      var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);
      if (extend) extendSelection(this, pos);
      else setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function(anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function(from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),

    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},
    replaceSelection: function(code, collapse, origin) {
      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || "around");
    },
    undo: docOperation(function() {makeChangeFromHistory(this, "undo");}),
    redo: docOperation(function() {makeChangeFromHistory(this, "redo");}),

    setExtending: function(val) {this.sel.extend = val;},

    historySize: function() {
      var hist = this.history;
      return {undo: hist.done.length, redo: hist.undone.length};
    },
    clearHistory: function() {this.history = makeHistory();},

    markClean: function() {
      this.history.dirtyCounter = 0;
      this.history.lastOp = this.history.lastOrigin = null;
    },
    isClean: function () {return this.history.dirtyCounter == 0;},

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = makeHistory();
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,
                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  Doc.prototype.eachLine = Doc.prototype.iter;

  // The Doc methods that should be available on CodeMirror instances
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent) n.height += diff;
  }

  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0, e = chunk.children.length; i < e; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }

  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function makeHistory() {
    return {
      // Arrays of history events. Doing something adds an event to
      // done and clears undo. Undoing moves events from done to
      // undone, redoing moves them in the other direction.
      done: [], undone: [], undoDepth: Infinity,
      // Used to track when changes can be merged into a single undo
      // event
      lastTime: 0, lastOp: null, lastOrigin: null,
      // Used by the isClean() method
      dirtyCounter: 0
    };
  }

  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  function historyChangeFromChange(doc, change) {
    var histChange = {from: change.from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur = lst(hist.done);

    if (cur &&
        (hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastTime > time - 600) || change.origin.charAt(0) == "*"))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;
    } else {
      // Can not be merged, start a new event.
      cur = {changes: [historyChangeFromChange(doc, change)],
             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,
             anchorAfter: selAfter.anchor, headAfter: selAfter.head};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
      if (hist.dirtyCounter < 0)
        // The user has made a change after undoing past the last clean state.
        // We can never get back to a clean state now until markClean() is called.
        hist.dirtyCounter = NaN;
      else
        hist.dirtyCounter++;
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }

  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,
                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT OPERATORS

  function stopMethod() {e_stop(this);}
  // Ensure an event has a stop method.
  function addStop(event) {
    if (!event.stop) event.stop = stopMethod;
    return event;
  }

  function e_preventDefault(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  }

  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }

  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  function Delayed() {this.id = null;}
  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = 0, n = 0; i < end; ++i) {
      if (string.charAt(i) == "\t") n += tabSize - (n % tabSize);
      else ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  function selectInput(node) {
    if (ios) { // Mobile Safari apparently has a bug where select() is broken.
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else node.select();
  }

  function indexOf(collection, elt) {
    if (collection.indexOf) return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt) return i;
    return -1;
  }

  function createObj(base, props) {
    function Obj() {}
    Obj.prototype = base;
    var inst = new Obj();
    if (props) copyObj(props, inst);
    return inst;
  }

  function copyObj(obj, target) {
    if (!target) target = {};
    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
    return target;
  }

  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i) a.push(undefined);
    return a;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") setTextContent(e, content);
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  function removeChildren(e) {
    // IE will break all parent-child relations in subnodes when setting innerHTML
    if (!ie) e.innerHTML = "";
    else while (e.firstChild) e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = "";
      e.appendChild(document.createTextNode(str));
    } else e.textContent = str;
  }

  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function(f) { getRect = f; };

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie_lt9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  // For a reason I have yet to figure out, some browsers disallow
  // word wrapping between certain characters *only* if a new inline
  // element is started between them. This makes it hard to reliably
  // measure the position of things, since that requires inserting an
  // extra span. This terribly fragile set of regexps matches the
  // character combinations that suffer from this phenomenon on the
  // various browsers.
  var spanAffectsWrapping = /^$/; // Won't match any two-character string
  if (gecko) spanAffectsWrapping = /$'/;
  else if (safari) spanAffectsWrapping = /\-[^ \-?]|\?[^ !'\"\),.\-\/:;\?\]\}]/;
  else if (chrome) spanAffectsWrapping = /\-[^ \-\.?]|\?[^ \-\.?\]\}:;!'\"\),\/]|[\.!\"#&%\)*+,:;=>\]|\}~][\(\{\[<]|\$'/;

  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null) return knownScrollbarWidth;
    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported) return elt("span", "\u200b");
    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};
  CodeMirror.splitLines = splitLines;

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == 'function';
  })();

  // KEY NAMING

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 91: "Mod", 92: "Mod", 93: "Mod", 109: "-", 107: "=", 127: "Delete",
                  186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63276: "PageUp", 63277: "PageDown", 63275: "End", 63273: "Home",
                  63234: "Left", 63232: "Up", 63235: "Right", 63233: "Down", 63302: "Insert", 63272: "Delete"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from)
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
    }
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }

  // This is somewhat involved. It is needed in order to move
  // 'visually' through bi-directional text -- i.e., pressing left
  // should make the cursor go left, even when in RTL text. The
  // tricky part is the 'jumps', where RTL and LTR text touch each
  // other. This often requires the cursor offset to move more than
  // one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var moveOneUnit = byUnit ? function(pos, dir) {
      do pos += dir;
      while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
      return pos;
    } : function(pos, dir) { return pos + dir; };
    var linedir = bidi[0].level;
    for (var i = 0; i < bidi.length; ++i) {
      var part = bidi[i], sticky = part.level % 2 == linedir;
      if ((part.from < start && part.to > start) ||
          (sticky && (part.from == start || part.to == start))) break;
    }
    var target = moveOneUnit(start, part.level % 2 ? -dir : dir);

    while (target != null) {
      if (part.level % 2 == linedir) {
        if (target < part.from || target > part.to) {
          part = bidi[i += dir];
          target = part && (dir > 0 == part.level % 2 ? moveOneUnit(part.to, -1) : moveOneUnit(part.from, 1));
        } else break;
      } else {
        if (target == bidiLeft(part)) {
          part = bidi[--i];
          target = part && bidiRight(part);
        } else if (target == bidiRight(part)) {
          part = bidi[++i];
          target = part && bidiLeft(part);
        } else break;
      }
    }

    return target < 0 || target > line.text.length ? null : target;
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";
    function charType(code) {
      if (code <= 0xff) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);
      else if (0x700 <= code && code <= 0x8ac) return "r";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len - 1 && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len - 1 ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push({from: start, to: i, level: 0});
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, {from: nstart, to: j, level: 2});
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift({from: 0, to: m[0].length, level: 0});
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push({from: len - m[0].length, to: len, level: 0});
      }
      if (order[0].level != lst(order).level)
        order.push({from: len, to: len, level: order[0].level});

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "3.1";

  return CodeMirror;
})();
;CodeMirror.defineMode("xml", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var Kludges = parserConfig.htmlMode ? {
    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                      'track': true, 'wbr': true},
    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                       'th': true, 'tr': true},
    contextGrabbers: {
      'dd': {'dd': true, 'dt': true},
      'dt': {'dd': true, 'dt': true},
      'li': {'li': true},
      'option': {'option': true, 'optgroup': true},
      'optgroup': {'optgroup': true},
      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
      'rp': {'rp': true, 'rt': true},
      'rt': {'rp': true, 'rt': true},
      'tbody': {'tbody': true, 'tfoot': true},
      'td': {'td': true, 'th': true},
      'tfoot': {'tbody': true},
      'th': {'td': true, 'th': true},
      'thead': {'tbody': true, 'tfoot': true},
      'tr': {'tr': true}
    },
    doNotIndent: {"pre": true},
    allowUnquoted: true,
    allowMissing: true
  } : {
    autoSelfClosers: {},
    implicitlyClosed: {},
    contextGrabbers: {},
    doNotIndent: {},
    allowUnquoted: false,
    allowMissing: false
  };
  var alignCDATA = parserConfig.alignCDATA;

  // Return variables for tokenizers
  var tagName, type;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        }
        else if (stream.match("--")) return chain(inBlock("comment", "-->"));
        else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        }
        else return null;
      }
      else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      }
      else {
        var isClose = stream.eat("/");
        tagName = "";
        var c;
        while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;
        if (!tagName) return "error";
        type = isClose ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag";
      }
    }
    else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    }
    else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag";
    }
    else if (ch == "=") {
      type = "equals";
      return null;
    }
    else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      return state.tokenize(stream, state);
    }
    else {
      stream.eatWhile(/[^\s\u00a0=<>\"\']/);
      return "word";
    }
  }

  function inAttribute(quote) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  var curState, setStyle;
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }

  function pushContext(tagName, startOfLine) {
    var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || (curState.context && curState.context.noIndent);
    curState.context = {
      prev: curState.context,
      tagName: tagName,
      indent: curState.indented,
      startOfLine: startOfLine,
      noIndent: noIndent
    };
  }
  function popContext() {
    if (curState.context) curState.context = curState.context.prev;
  }

  function element(type) {
    if (type == "openTag") {
      curState.tagName = tagName;
      return cont(attributes, endtag(curState.startOfLine));
    } else if (type == "closeTag") {
      var err = false;
      if (curState.context) {
        if (curState.context.tagName != tagName) {
          if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
            popContext();
          }
          err = !curState.context || curState.context.tagName != tagName;
        }
      } else {
        err = true;
      }
      if (err) setStyle = "error";
      return cont(endclosetag(err));
    }
    return cont();
  }
  function endtag(startOfLine) {
    return function(type) {
      var tagName = curState.tagName;
      curState.tagName = null;
      if (type == "selfcloseTag" ||
          (type == "endTag" && Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase()))) {
        maybePopContext(tagName.toLowerCase());
        return cont();
      }
      if (type == "endTag") {
        maybePopContext(tagName.toLowerCase());
        pushContext(tagName, startOfLine);
        return cont();
      }
      return cont();
    };
  }
  function endclosetag(err) {
    return function(type) {
      if (err) setStyle = "error";
      if (type == "endTag") { popContext(); return cont(); }
      setStyle = "error";
      return cont(arguments.callee);
    };
  }
  function maybePopContext(nextTagName) {
    var parentTagName;
    while (true) {
      if (!curState.context) {
        return;
      }
      parentTagName = curState.context.tagName.toLowerCase();
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||
          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext();
    }
  }

  function attributes(type) {
    if (type == "word") {setStyle = "attribute"; return cont(attribute, attributes);}
    if (type == "endTag" || type == "selfcloseTag") return pass();
    setStyle = "error";
    return cont(attributes);
  }
  function attribute(type) {
    if (type == "equals") return cont(attvalue, attributes);
    if (!Kludges.allowMissing) setStyle = "error";
    else if (type == "word") setStyle = "attribute";
    return (type == "endTag" || type == "selfcloseTag") ? pass() : cont();
  }
  function attvalue(type) {
    if (type == "string") return cont(attvaluemaybe);
    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return cont();}
    setStyle = "error";
    return (type == "endTag" || type == "selfCloseTag") ? pass() : cont();
  }
  function attvaluemaybe(type) {
    if (type == "string") return cont(attvaluemaybe);
    else return pass();
  }

  return {
    startState: function() {
      return {tokenize: inText, cc: [], indented: 0, startOfLine: true, tagName: null, context: null};
    },

    token: function(stream, state) {
      if (stream.sol()) {
        state.startOfLine = true;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace()) return null;

      setStyle = type = tagName = null;
      var style = state.tokenize(stream, state);
      state.type = type;
      if ((style || type) && style != "comment") {
        curState = state;
        while (true) {
          var comb = state.cc.pop() || element;
          if (comb(type || style)) break;
        }
      }
      state.startOfLine = false;
      return setStyle || style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      if ((state.tokenize != inTag && state.tokenize != inText) ||
          context && context.noIndent)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      if (context && /^<\//.test(textAfter))
        context = context.prev;
      while (context && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return 0;
    },

    electricChars: "/",

    configuration: parserConfig.htmlMode ? "html" : "xml"
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});
;CodeMirror.defineMode("css", function(config) {
  var indentUnit = config.indentUnit, type;

  var atMediaTypes = keySet([
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ]);

  var atMediaFeatures = keySet([
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid"
  ]);

  var propertyKeywords = keySet([
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-iteration-count",
    "animation-name", "animation-play-state", "animation-timing-function",
    "appearance", "azimuth", "backface-visibility", "background",
    "background-attachment", "background-clip", "background-color",
    "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "font", "font-feature-settings", "font-family",
    "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid-cell", "grid-column", "grid-column-align",
    "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",
    "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",
    "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marker-offset", "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "rendering-intent",
    "resize", "rest", "rest-after", "rest-before", "richness", "right",
    "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-shadow",
    "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "word-break",
    "word-spacing", "word-wrap", "z-index"
  ]);

  var colorKeywords = keySet([
    "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia",
    "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua"
  ]);

  var valueKeywords = keySet([
    "above", "absolute", "activeborder", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "background",
    "backwards", "baseline", "below", "bidi-override", "binary", "bengali",
    "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break-all", "break-word", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "compact", "condensed", "contain", "content",
    "content-box", "context-menu", "continuous", "copy", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari",
    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",
    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",
    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "justify", "kannada", "katakana", "katakana-iroha", "khmer",
    "landscape", "lao", "large", "larger", "left", "level", "lighter",
    "line-through", "linear", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "malayalam", "match",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",
    "narrower", "navy", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "overlay", "overline", "padding", "padding-box", "painted",
    "paused", "persian", "plus-darker", "plus-lighter", "pointer", "portrait",
    "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",
    "radio", "read-only", "read-write", "read-write-plaintext-only", "relative",
    "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",
    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "single", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke",
    "sub", "subpixel-antialiased", "super", "sw-resize", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "white", "wider",
    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",
    "xx-large", "xx-small", "yellow"
  ]);

  function keySet(array) { var keys = {}; for (var i = 0; i < array.length; ++i) keys[array[i]] = true; return keys; }
  function ret(style, tp) {type = tp; return style;}

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == "@") {stream.eatWhile(/[\w\\\-]/); return ret("def", stream.current());}
    else if (ch == "/" && stream.eat("*")) {
      state.tokenize = tokenCComment;
      return tokenCComment(stream, state);
    }
    else if (ch == "<" && stream.eat("!")) {
      state.tokenize = tokenSGMLComment;
      return tokenSGMLComment(stream, state);
    }
    else if (ch == "=") ret(null, "compare");
    else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    }
    else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    }
    else if (/\d/.test(ch)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    }
    else if (ch === "-") {
      if (/\d/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^[^-]+-/)) {
        return ret("meta", "meta");
      }
    }
    else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    }
    else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    }
    else if (ch == ":") {
      return ret("operator", ch);
    }
    else if (/[;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    }
    else if (ch == "u" && stream.match("rl(")) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "variable");
    }
    else {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "variable");
    }
  }

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenSGMLComment(stream, state) {
    var dashes = 0, ch;
    while ((ch = stream.next()) != null) {
      if (dashes >= 2 && ch == ">") {
        state.tokenize = tokenBase;
        break;
      }
      dashes = (ch == "-") ? dashes + 1 : 0;
    }
    return ret("comment", "comment");
  }

  function tokenString(quote, nonInclusive) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped)
          break;
        escaped = !escaped && ch == "\\";
      }
      if (!escaped) {
        if (nonInclusive) stream.backUp(1);
        state.tokenize = tokenBase;
      }
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\']/, false))
      state.tokenize = tokenString(")", true);
    else
      state.tokenize = tokenBase;
    return ret(null, "(");
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              stack: []};
    },

    token: function(stream, state) {

      // Use these terms when applicable (see http://www.xanthir.com/blog/b4E50)
      //
      // rule** or **ruleset:
      // A selector + braces combo, or an at-rule.
      //
      // declaration block:
      // A sequence of declarations.
      //
      // declaration:
      // A property + colon + value combo.
      //
      // property value:
      // The entire value of a property.
      //
      // component value:
      // A single piece of a property value. Like the 5px in
      // text-shadow: 0 0 5px blue;. Can also refer to things that are
      // multiple terms, like the 1-4 terms that make up the background-size
      // portion of the background shorthand.
      //
      // term:
      // The basic unit of author-facing CSS, like a single number (5),
      // dimension (5px), string ("foo"), or function. Officially defined
      //  by the CSS 2.1 grammar (look for the 'term' production)
      //
      //
      // simple selector:
      // A single atomic selector, like a type selector, an attr selector, a
      // class selector, etc.
      //
      // compound selector:
      // One or more simple selectors without a combinator. div.example is
      // compound, div > .example is not.
      //
      // complex selector:
      // One or more compound selectors chained with combinators.
      //
      // combinator:
      // The parts of selectors that express relationships. There are four
      // currently - the space (descendant combinator), the greater-than
      // bracket (child combinator), the plus sign (next sibling combinator),
      // and the tilda (following sibling combinator).
      //
      // sequence of selectors:
      // One or more of the named type of selector chained with commas.

      if (state.tokenize == tokenBase && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);

      // Changing style returned based on context
      var context = state.stack[state.stack.length-1];
      if (style == "property") {
        if (context == "propertyValue"){
          if (valueKeywords[stream.current()]) {
            style = "string-2";
          } else if (colorKeywords[stream.current()]) {
            style = "keyword";
          } else {
            style = "variable-2";
          }
        } else if (context == "rule") {
          if (!propertyKeywords[stream.current()]) {
            style += " error";
          }
        } else if (!context || context == "@media{") {
          style = "tag";
        } else if (context == "@media") {
          if (atMediaTypes[stream.current()]) {
            style = "attribute"; // Known attribute
          } else if (/^(only|not)$/i.test(stream.current())) {
            style = "keyword";
          } else if (stream.current().toLowerCase() == "and") {
            style = "error"; // "and" is only allowed in @mediaType
          } else if (atMediaFeatures[stream.current()]) {
            style = "error"; // Known property, should be in @mediaType(
          } else {
            // Unknown, expecting keyword or attribute, assuming attribute
            style = "attribute error";
          }
        } else if (context == "@mediaType") {
          if (atMediaTypes[stream.current()]) {
            style = "attribute";
          } else if (stream.current().toLowerCase() == "and") {
            style = "operator";
          } else if (/^(only|not)$/i.test(stream.current())) {
            style = "error"; // Only allowed in @media
          } else if (atMediaFeatures[stream.current()]) {
            style = "error"; // Known property, should be in parentheses
          } else {
            // Unknown attribute or property, but expecting property (preceded
            // by "and"). Should be in parentheses
            style = "error";
          }
        } else if (context == "@mediaType(") {
          if (propertyKeywords[stream.current()]) {
            // do nothing, remains "property"
          } else if (atMediaTypes[stream.current()]) {
            style = "error"; // Known property, should be in parentheses
          } else if (stream.current().toLowerCase() == "and") {
            style = "operator";
          } else if (/^(only|not)$/i.test(stream.current())) {
            style = "error"; // Only allowed in @media
          } else {
            style += " error";
          }
        } else {
          style = "error";
        }
      } else if (style == "atom") {
        if(!context || context == "@media{") {
          style = "builtin";
        } else if (context == "propertyValue") {
          if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
            style += " error";
          }
        } else {
          style = "error";
        }
      } else if (context == "@media" && type == "{") {
        style = "error";
      }

      // Push/pop context stack
      if (type == "{") {
        if (context == "@media" || context == "@mediaType") {
          state.stack.pop();
          state.stack[state.stack.length-1] = "@media{";
        }
        else state.stack.push("rule");
      }
      else if (type == "}") {
        state.stack.pop();
        if (context == "propertyValue") state.stack.pop();
      }
      else if (type == "@media") state.stack.push("@media");
      else if (context == "@media" && /\b(keyword|attribute)\b/.test(style))
        state.stack.push("@mediaType");
      else if (context == "@mediaType" && stream.current() == ",") state.stack.pop();
      else if (context == "@mediaType" && type == "(") state.stack.push("@mediaType(");
      else if (context == "@mediaType(" && type == ")") state.stack.pop();
      else if (context == "rule" && type == ":") state.stack.push("propertyValue");
      else if (context == "propertyValue" && type == ";") state.stack.pop();
      return style;
    },

    indent: function(state, textAfter) {
      var n = state.stack.length;
      if (/^\}/.test(textAfter))
        n -= state.stack[state.stack.length-1] == "propertyValue" ? 2 : 1;
      return state.baseIndent + n * indentUnit;
    },

    electricChars: "}"
  };
});

CodeMirror.defineMIME("text/css", "css");
;// TODO actually recognize syntax of TypeScript constructs

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var jsonMode = parserConfig.json;
  var isTS = parserConfig.typescript;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": A, "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "class": kw("class"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        "super": kw("super"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end && !escaped)
        return false;
      escaped = !escaped && next == "\\";
    }
    return escaped;
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function jsTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'")
      return chain(stream, state, jsTokenString(ch));
    else if (/[\[\]{}\(\),;\:\.]/.test(ch))
      return ret(ch);
    else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    }
    else if (/\d/.test(ch) || ch == "-" && stream.eat(/\d/)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    }
    else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, jsTokenComment);
      }
      else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      }
      else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               /^[\[{}\(,;:]$/.test(state.lastType)) {
        nextUntilUnescaped(stream, "/");
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      }
      else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", null, stream.current());
      }
    }
    else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    }
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", null, stream.current());
    }
    else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function jsTokenString(quote) {
    return function(stream, state) {
      if (!nextUntilUnescaped(stream, quote))
        state.tokenize = jsTokenBase;
      return ret("string", "string");
    };
  }

  function jsTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = jsTokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state;
      state.lexical = new JSLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    return function(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(arguments.callee);
    };
  }

  function statement(type) {
    if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                                      poplex, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                         block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                        statement, poplex, popcontext);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);
    if (type == "function") return cont(functiondef);
    if (type == "keyword c") return cont(maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeoperator);
    if (type == "operator") return cont(expression);
    if (type == "[") return cont(pushlex("]"), commasep(expression, "]"), poplex, maybeoperator);
    if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeoperator);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperator(type, value) {
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(maybeoperator);
      if (value == "?") return cont(expression, expect(":"), expression);
      return cont(expression);
    }
    if (type == ";") return;
    if (type == "(") return cont(pushlex(")"), commasep(expression, ")"), poplex, maybeoperator);
    if (type == ".") return cont(property, maybeoperator);
    if (type == "[") return cont(pushlex("]"), expression, expect("]"), poplex, maybeoperator);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperator, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type) {
    if (type == "variable") cx.marked = "property";
    else if (type == "number" || type == "string") cx.marked = type + " property";
    if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expression);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") return cont(what, proceed);
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      else return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (type == ":") return cont(typedef);
    return pass();
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
    return pass();
  }
  function vardef1(type, value) {
    if (type == "variable") {
      register(value);
      return isTS ? cont(maybetype, vardef2) : cont(vardef2);
    }
    return pass();
  }
  function vardef2(type, value) {
    if (value == "=") return cont(expression, vardef2);
    if (type == ",") return cont(vardef1);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef1, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybein);
    return cont(forspec2);
  }
  function formaybein(_type, value) {
    if (value == "in") return cont(expression);
    return cont(maybeoperator, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in") return cont(expression);
    return cont(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type, value) {
    if (type == "variable") {register(value); return isTS ? cont(maybetype) : cont();}
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: jsTokenBase,
        lastType: null,
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        globalVars: parserConfig.globalVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == jsTokenComment) return CodeMirror.Pass;
      if (state.tokenize != jsTokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;
      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? 4 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? indentUnit : 0);
      else if (lexical.info == "switch" && !closing)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: ":{}",

    jsonMode: jsonMode
  };
});

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
;CodeMirror.defineMode("htmlmixed", function(config, parserConfig) {
  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});
  var cssMode = CodeMirror.getMode(config, "css");

  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;
  scriptTypes.push({matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i,
                    mode: CodeMirror.getMode(config, "javascript")});
  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {
    var conf = scriptTypesConf[i];
    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});
  }
  scriptTypes.push({matches: /./,
                    mode: CodeMirror.getMode(config, "text/plain")});

  function html(stream, state) {
    var tagName = state.htmlState.tagName;
    var style = htmlMode.token(stream, state.htmlState);
    if (tagName == "script" && /\btag\b/.test(style) && stream.current() == ">") {
      // Script block: mode to change to depends on type attribute
      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i);
      scriptType = scriptType ? scriptType[1] : "";
      if (scriptType && /[\"\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);
      for (var i = 0; i < scriptTypes.length; ++i) {
        var tp = scriptTypes[i];
        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {
          if (tp.mode) {
            state.token = script;
            state.localMode = tp.mode;
            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));
          }
          break;
        }
      }
    } else if (tagName == "style" && /\btag\b/.test(style) && stream.current() == ">") {
      state.token = css;
      state.localMode = cssMode;
      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));
    }
    return style;
  }
  function maybeBackup(stream, pat, style) {
    var cur = stream.current();
    var close = cur.search(pat), m;
    if (close > -1) stream.backUp(cur.length - close);
    else if (m = cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur[0]);
    }
    return style;
  }
  function script(stream, state) {
    if (stream.match(/^<\/\s*script\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*script\s*>/,
                       state.localMode.token(stream, state.localState));
  }
  function css(stream, state) {
    if (stream.match(/^<\/\s*style\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*style\s*>/,
                       cssMode.token(stream, state.localState));
  }

  return {
    startState: function() {
      var state = htmlMode.startState();
      return {token: html, localMode: null, localState: null, htmlState: state};
    },

    copyState: function(state) {
      if (state.localState)
        var local = CodeMirror.copyState(state.localMode, state.localState);
      return {token: state.token, localMode: state.localMode, localState: local,
              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
    },

    token: function(stream, state) {
      return state.token(stream, state);
    },

    indent: function(state, textAfter) {
      if (!state.localMode || /^\s*<\//.test(textAfter))
        return htmlMode.indent(state.htmlState, textAfter);
      else if (state.localMode.indent)
        return state.localMode.indent(state.localState, textAfter);
      else
        return CodeMirror.Pass;
    },

    electricChars: "/{}:",

    innerMode: function(state) {
      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
    }
  };
}, "xml", "javascript", "css");

CodeMirror.defineMIME("text/html", "htmlmixed");
;//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

var _ = (function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };
  return _;
}).call({});
/**
 * Core Emmet object, available in global scope
 */
var emmet = (function(global) {
  var defaultSyntax = 'html';
  var defaultProfile = 'plain';

  if (typeof _ == 'undefined') {
    try {
      // avoid collisions with RequireJS loader
      // also, JS obfuscators tends to translate
      // a["name"] to a.name, which also breaks RequireJS
      _ = global[['require'][0]]('underscore'); // node.js
    } catch (e) {}
  }

  if (typeof _ == 'undefined') {
    throw 'Cannot access to Underscore.js lib';
  }

  /** List of registered modules */
  var modules = {
    _ : _
  };

  /**
   * Shared empty constructor function to aid in prototype-chain creation.
   */
  var ctor = function(){};

  /**
   * Helper function to correctly set up the prototype chain, for subclasses.
   * Similar to `goog.inherits`, but uses a hash of prototype properties and
   * class properties to be extended.
   * Took it from Backbone.
   * @param {Object} parent
   * @param {Object} protoProps
   * @param {Object} staticProps
   * @returns {Object}
   */
  function inherits(parent, protoProps, staticProps) {
    var child;

    // The constructor function for the new subclass is either defined by
    // you (the "constructor" property in your `extend` definition), or
    // defaulted by us to simply call the parent's constructor.
    if (protoProps && protoProps.hasOwnProperty('constructor')) {
      child = protoProps.constructor;
    } else {
      child = function() {
        parent.apply(this, arguments);
      };
    }

    // Inherit class (static) properties from parent.
    _.extend(child, parent);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps)
      _.extend(child.prototype, protoProps);

    // Add static properties to the constructor function, if supplied.
    if (staticProps)
      _.extend(child, staticProps);

    // Correctly set child's `prototype.constructor`.
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  /**
   * @type Function Function that loads module definition if it's not defined
   */
  var moduleLoader = null;

  /**
   * Generic Emmet module loader (actually, it doesnâ€™t load anything, just
   * returns module reference). Not using `require` name to avoid conflicts
   * with Node.js and RequireJS
   */
  function r(name) {
    if (!(name in modules) && moduleLoader)
      moduleLoader(name);

    return modules[name];
  }

  return {
    /**
     * Simple, AMD-like module definition. The module will be added into
     * <code>emmet</code> object and will be available via
     * <code>emmet.require(name)</code> or <code>emmet[name]</code>
     * @param {String} name
     * @param {Function} factory
     * @memberOf emmet
     */
    define: function(name, factory) {
      // do not let redefine existing properties
      if (!(name in modules)) {
        modules[name] = _.isFunction(factory)
          ? this.exec(factory)
          : factory;
      }
    },

    /**
     * Returns reference to Emmet module
     * @param {String} name Module name
     */
    require: r,

    /**
     * Helper method that just executes passed function but with all
     * important arguments like 'require' and '_'
     * @param {Function} fn
     * @param {Object} context Execution context
     */
    exec: function(fn, context) {
      return fn.call(context || global, _.bind(r, this), _, this);
    },

    /**
     * The self-propagating extend function for classes.
     * Took it from Backbone
     * @param {Object} protoProps
     * @param {Object} classProps
     * @returns {Object}
     */
    extend: function(protoProps, classProps) {
      var child = inherits(this, protoProps, classProps);
      child.extend = this.extend;
      // a hack required to WSH inherit `toString` method
      if (protoProps.hasOwnProperty('toString'))
        child.prototype.toString = protoProps.toString;
      return child;
    },

    /**
     * The essential function that expands Emmet abbreviation
     * @param {String} abbr Abbreviation to parse
     * @param {String} syntax Abbreviation's context syntax
     * @param {String} profile Output profile (or its name)
     * @param {Object} contextNode Contextual node where abbreviation is
     * written
     * @return {String}
     */
    expandAbbreviation: function(abbr, syntax, profile, contextNode) {
      if (!abbr) return '';

      syntax = syntax || defaultSyntax;
//      profile = profile || defaultProfile;

      var filters = r('filters');
      var parser = r('abbreviationParser');

      profile = r('profile').get(profile, syntax);
      r('tabStops').resetTabstopIndex();

      var data = filters.extractFromAbbreviation(abbr);
      var outputTree = parser.parse(data[0], {
        syntax: syntax,
        contextNode: contextNode
      });

      var filtersList = filters.composeList(syntax, profile, data[1]);
      filters.apply(outputTree, filtersList, profile);
      return outputTree.toString();
    },

    /**
     * Returns default syntax name used in abbreviation engine
     * @returns {String}
     */
    defaultSyntax: function() {
      return defaultSyntax;
    },

    /**
     * Returns default profile name used in abbreviation engine
     * @returns {String}
     */
    defaultProfile: function() {
      return defaultProfile;
    },

    /**
     * Log message into console if it exists
     */
    log: function() {
      if (global.console && global.console.log)
        global.console.log.apply(global.console, arguments);
    },

    /**
     * Setups function that should synchronously load undefined modules
     * @param {Function} fn
     */
    setModuleLoader: function(fn) {
      moduleLoader = fn;
    }
  };
})(this);

// export core for Node.JS
if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = emmet;
  }
  exports.emmet = emmet;
}

// export as Require.js module
if (typeof define !== 'undefined') {
  define(emmet);
}/**
 * Emmet abbreviation parser.
 * Takes string abbreviation and recursively parses it into a tree. The parsed
 * tree can be transformed into a string representation with
 * <code>toString()</code> method. Note that string representation is defined
 * by custom processors (called <i>filters</i>), not by abbreviation parser
 * itself.
 *
 * This module can be extended with custom pre-/post-processors to shape-up
 * final tree or its representation. Actually, many features of abbreviation
 * engine are defined in other modules as tree processors
 *
 *
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 * @memberOf __abbreviationParser
 * @constructor
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('abbreviationParser', function(require, _) {
  var reValidName = /^[\w\-\$\:@\!%]+\+?$/i;
  var reWord = /[\w\-:\$@]/;

  var pairs = {
    '[': ']',
    '(': ')',
    '{': '}'
  };

  var spliceFn = Array.prototype.splice;

  var preprocessors = [];
  var postprocessors = [];
  var outputProcessors = [];

  /**
   * @type AbbreviationNode
   */
  function AbbreviationNode(parent) {
    /** @type AbbreviationNode */
    this.parent = null;
    this.children = [];
    this._attributes = [];

    /** @type String Raw abbreviation for current node */
    this.abbreviation = '';
    this.counter = 1;
    this._name = null;
    this._text = '';
    this.repeatCount = 1;
    this.hasImplicitRepeat = false;

    /** Custom data dictionary */
    this._data = {};

    // output properties
    this.start = '';
    this.end = '';
    this.content = '';
    this.padding = '';
  }

  AbbreviationNode.prototype = {
    /**
     * Adds passed node as child or creates new child
     * @param {AbbreviationNode} child
     * @param {Number} position Index in children array where child should
     * be inserted
     * @return {AbbreviationNode}
     */
    addChild: function(child, position) {
      child = child || new AbbreviationNode;
      child.parent = this;

      if (_.isUndefined(position)) {
        this.children.push(child);
      } else {
        this.children.splice(position, 0, child);
      }

      return child;
    },

    /**
     * Creates a deep copy of current node
     * @returns {AbbreviationNode}
     */
    clone: function() {
      var node = new AbbreviationNode();
      var attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];
      _.each(attrs, function(a) {
        node[a] = this[a];
      }, this);

      // clone attributes
      node._attributes = _.map(this._attributes, function(attr) {
        return _.clone(attr);
      });

      node._data = _.clone(this._data);

      // clone children
      node.children = _.map(this.children, function(child) {
        child = child.clone();
        child.parent = node;
        return child;
      });

      return node;
    },

    /**
     * Removes current node from parentâ€˜s child list
     * @returns {AbbreviationNode} Current node itself
     */
    remove: function() {
      if (this.parent) {
        this.parent.children = _.without(this.parent.children, this);
      }

      return this;
    },

    /**
     * Replaces current node in parentâ€˜s children list with passed nodes
     * @param {AbbreviationNode} node Replacement node or array of nodes
     */
    replace: function() {
      var parent = this.parent;
      var ix = _.indexOf(parent.children, this);
      var items = _.flatten(arguments);
      spliceFn.apply(parent.children, [ix, 1].concat(items));

      // update parent
      _.each(items, function(item) {
        item.parent = parent;
      });
    },

    /**
     * Recursively sets <code>property</code> to <code>value</code> of current
     * node and its children
     * @param {String} name Property to update
     * @param {Object} value New property value
     */
    updateProperty: function(name, value) {
      this[name] = value;
      _.each(this.children, function(child) {
        child.updateProperty(name, value);
      });

      return this;
    },

    /**
     * Finds first child node that matches truth test for passed
     * <code>fn</code> function
     * @param {Function} fn
     * @returns {AbbreviationNode}
     */
    find: function(fn) {
      return this.findAll(fn)[0];
//      if (!_.isFunction(fn)) {
//        var elemName = fn.toLowerCase();
//        fn = function(item) {return item.name().toLowerCase() == elemName;};
//      }
//
//      var result = null;
//      _.find(this.children, function(child) {
//        if (fn(child)) {
//          return result = child;
//        }
//
//        return result = child.find(fn);
//      });
//
//      return result;
    },

    /**
     * Finds all child nodes that matches truth test for passed
     * <code>fn</code> function
     * @param {Function} fn
     * @returns {Array}
     */
    findAll: function(fn) {
      if (!_.isFunction(fn)) {
        var elemName = fn.toLowerCase();
        fn = function(item) {return item.name().toLowerCase() == elemName;};
      }

      var result = [];
      _.each(this.children, function(child) {
        if (fn(child))
          result.push(child);

        result = result.concat(child.findAll(fn));
      });

      return _.compact(result);
    },

    /**
     * Sets/gets custom data
     * @param {String} name
     * @param {Object} value
     * @returns {Object}
     */
    data: function(name, value) {
      if (arguments.length == 2) {
        this._data[name] = value;

        if (name == 'resource' && require('elements').is(value, 'snippet')) {
          // setting snippet as matched resource: update `content`
          // property with snippet value
          this.content = value.data;
          if (this._text) {
            this.content = require('abbreviationUtils')
              .insertChildContent(value.data, this._text);
          }
        }
      }

      return this._data[name];
    },

    /**
     * Returns name of current node
     * @returns {String}
     */
    name: function() {
      var res = this.matchedResource();
      if (require('elements').is(res, 'element')) {
        return res.name;
      }

      return this._name;
    },

    /**
     * Returns list of attributes for current node
     * @returns {Array}
     */
    attributeList: function() {
      var attrs = [];

      var res = this.matchedResource();
      if (require('elements').is(res, 'element') && _.isArray(res.attributes)) {
        attrs = attrs.concat(res.attributes);
      }

      return optimizeAttributes(attrs.concat(this._attributes));
    },

    /**
     * Returns or sets attribute value
     * @param {String} name Attribute name
     * @param {String} value New attribute value
     * @returns {String}
     */
    attribute: function(name, value) {
      if (arguments.length == 2) {
        // modifying attribute
        var ix = _.indexOf(_.pluck(this._attributes, 'name'), name.toLowerCase());
        if (~ix) {
          this._attributes[ix].value = value;
        } else {
          this._attributes.push({
            name: name,
            value: value
          });
        }
      }

      return (_.find(this.attributeList(), function(attr) {
        return attr.name == name;
      }) || {}).value;
    },

    /**
     * Returns reference to the matched <code>element</code>, if any.
     * See {@link elements} module for a list of available elements
     * @returns {Object}
     */
    matchedResource: function() {
      return this.data('resource');
    },

    /**
     * Returns index of current node in parentâ€˜s children list
     * @returns {Number}
     */
    index: function() {
      return this.parent ? _.indexOf(this.parent.children, this) : -1;
    },

    /**
     * Sets how many times current element should be repeated
     * @private
     */
    _setRepeat: function(count) {
      if (count) {
        this.repeatCount = parseInt(count, 10) || 1;
      } else {
        this.hasImplicitRepeat = true;
      }
    },

    /**
     * Sets abbreviation that belongs to current node
     * @param {String} abbr
     */
    setAbbreviation: function(abbr) {
      abbr = abbr || '';

      var that = this;

      // find multiplier
      abbr = abbr.replace(/\*(\d+)?$/, function(str, repeatCount) {
        that._setRepeat(repeatCount);
        return '';
      });

      this.abbreviation = abbr;

      var abbrText = extractText(abbr);
      if (abbrText) {
        abbr = abbrText.element;
        this.content = this._text = abbrText.text;
      }

      var abbrAttrs = parseAttributes(abbr);
      if (abbrAttrs) {
        abbr = abbrAttrs.element;
        this._attributes = abbrAttrs.attributes;
      }

      this._name = abbr;

      // validate name
      if (this._name && !reValidName.test(this._name)) {
        throw 'Invalid abbreviation';
      }
    },

    /**
     * Returns string representation of current node
     * @return {String}
     */
    toString: function() {
      var utils = require('utils');

      var start = this.start;
      var end = this.end;
      var content = this.content;

      // apply output processors
      var node = this;
      _.each(outputProcessors, function(fn) {
        start = fn(start, node, 'start');
        content = fn(content, node, 'content');
        end = fn(end, node, 'end');
      });


      var innerContent = _.map(this.children, function(child) {
        return child.toString();
      }).join('');

      content = require('abbreviationUtils').insertChildContent(content, innerContent, {
        keepVariable: false
      });

      return start + utils.padString(content, this.padding) + end;
    },

    /**
     * Check if current node contains children with empty <code>expr</code>
     * property
     * @return {Boolean}
     */
    hasEmptyChildren: function() {
      return !!_.find(this.children, function(child) {
        return child.isEmpty();
      });
    },

    /**
     * Check if current node has implied name that should be resolved
     * @returns {Boolean}
     */
    hasImplicitName: function() {
      return !this._name && !this.isTextNode();
    },

    /**
     * Indicates that current element is a grouping one, e.g. has no
     * representation but serves as a container for other nodes
     * @returns {Boolean}
     */
    isGroup: function() {
      return !this.abbreviation;
    },

    /**
     * Indicates empty node (i.e. without abbreviation). It may be a
     * grouping node and should not be outputted
     * @return {Boolean}
     */
    isEmpty: function() {
      return !this.abbreviation && !this.children.length;
    },

    /**
     * Indicates that current node should be repeated
     * @returns {Boolean}
     */
    isRepeating: function() {
      return this.repeatCount > 1 || this.hasImplicitRepeat;
    },

    /**
     * Check if current node is a text-only node
     * @return {Boolean}
     */
    isTextNode: function() {
      return !this.name() && !this.attributeList().length;
    },

    /**
     * Indicates whether this node may be used to build elements or snippets
     * @returns {Boolean}
     */
    isElement: function() {
      return !this.isEmpty() && !this.isTextNode();
    },

    /**
     * Returns latest and deepest child of current tree
     * @returns {AbbreviationNode}
     */
    deepestChild: function() {
      if (!this.children.length)
        return null;

      var deepestChild = this;
      while (deepestChild.children.length) {
        deepestChild = _.last(deepestChild.children);
      }

      return deepestChild;
    }
  };

  /**
   * Returns stripped string: a string without first and last character.
   * Used for â€œunquotingâ€ strings
   * @param {String} str
   * @returns {String}
   */
  function stripped(str) {
    return str.substring(1, str.length - 1);
  }

  function consumeQuotedValue(stream, quote) {
    var ch;
    while (ch = stream.next()) {
      if (ch === quote)
        return true;

      if (ch == '\\')
        continue;
    }

    return false;
  }

  /**
   * Parses abbreviation into a tree
   * @param {String} abbr
   * @returns {AbbreviationNode}
   */
  function parseAbbreviation(abbr) {
    abbr = require('utils').trim(abbr);

    var root = new AbbreviationNode;
    var context = root.addChild(), ch;

    /** @type StringStream */
    var stream = require('stringStream').create(abbr);
    var loopProtector = 1000, multiplier;

    while (!stream.eol() && --loopProtector > 0) {
      ch = stream.peek();

      switch (ch) {
        case '(': // abbreviation group
          stream.start = stream.pos;
          if (stream.skipToPair('(', ')')) {
            var inner = parseAbbreviation(stripped(stream.current()));
            if (multiplier = stream.match(/^\*(\d+)?/, true)) {
              context._setRepeat(multiplier[1]);
            }

            _.each(inner.children, function(child) {
              context.addChild(child);
            });
          } else {
            throw 'Invalid abbreviation: mo matching ")" found for character at ' + stream.pos;
          }
          break;

        case '>': // child operator
          context = context.addChild();
          stream.next();
          break;

        case '+': // sibling operator
          context = context.parent.addChild();
          stream.next();
          break;

        case '^': // climb up operator
          var parent = context.parent || context;
          context = (parent.parent || parent).addChild();
          stream.next();
          break;

        default: // consume abbreviation
          stream.start = stream.pos;
          stream.eatWhile(function(c) {
            if (c == '[' || c == '{') {
              if (stream.skipToPair(c, pairs[c])) {
                stream.backUp(1);
                return true;
              }

              throw 'Invalid abbreviation: mo matching "' + pairs[c] + '" found for character at ' + stream.pos;
            }

            if (c == '+') {
              // let's see if this is an expando marker
              stream.next();
              var isMarker = stream.eol() ||  ~'+>^*'.indexOf(stream.peek());
              stream.backUp(1);
              return isMarker;
            }

            return c != '(' && isAllowedChar(c);
          });

          context.setAbbreviation(stream.current());
          stream.start = stream.pos;
      }
    }

    if (loopProtector < 1)
      throw 'Endless loop detected';

    return root;
  }

  /**
   * Extract attributes and their values from attribute set:
   * <code>[attr col=3 title="Quoted string"]</code>
   * @param {String} attrSet
   * @returns {Array}
   */
  function extractAttributes(attrSet, attrs) {
    attrSet = require('utils').trim(attrSet);
    var result = [];

    /** @type StringStream */
    var stream = require('stringStream').create(attrSet);
    stream.eatSpace();

    while (!stream.eol()) {
      stream.start = stream.pos;
      if (stream.eatWhile(reWord)) {
        var attrName = stream.current();
        var attrValue = '';
        if (stream.peek() == '=') {
          stream.next();
          stream.start = stream.pos;
          var quote = stream.peek();

          if (quote == '"' || quote == "'") {
            stream.next();
            if (consumeQuotedValue(stream, quote)) {
              attrValue = stream.current();
              // strip quotes
              attrValue = attrValue.substring(1, attrValue.length - 1);
            } else {
              throw 'Invalid attribute value';
            }
          } else if (stream.eatWhile(/[^\s\]]/)) {
            attrValue = stream.current();
          } else {
            throw 'Invalid attribute value';
          }
        }

        result.push({
          name: attrName,
          value: attrValue
        });
        stream.eatSpace();
      } else {
        break;
      }
    }

    return result;
  }

  /**
   * Parses tag attributes extracted from abbreviation. If attributes found,
   * returns object with <code>element</code> and <code>attributes</code>
   * properties
   * @param {String} abbr
   * @returns {Object} Returns <code>null</code> if no attributes found in
   * abbreviation
   */
  function parseAttributes(abbr) {
    /*
     * Example of incoming data:
     * #header
     * .some.data
     * .some.data#header
     * [attr]
     * #item[attr=Hello other="World"].class
     */
    var result = [];
    var attrMap = {'#': 'id', '.': 'class'};
    var nameEnd = null;

    /** @type StringStream */
    var stream = require('stringStream').create(abbr);
    while (!stream.eol()) {
      switch (stream.peek()) {
        case '#': // id
        case '.': // class
          if (nameEnd === null)
            nameEnd = stream.pos;

          var attrName = attrMap[stream.peek()];

          stream.next();
          stream.start = stream.pos;
          stream.eatWhile(reWord);
          result.push({
            name: attrName,
            value: stream.current()
          });
          break;
        case '[': //begin attribute set
          if (nameEnd === null)
            nameEnd = stream.pos;

          stream.start = stream.pos;
          if (!stream.skipToPair('[', ']'))
            throw 'Invalid attribute set definition';

          result = result.concat(
            extractAttributes(stripped(stream.current()))
          );
          break;
        default:
          stream.next();
      }
    }

    if (!result.length)
      return null;

    return {
      element: abbr.substring(0, nameEnd),
      attributes: optimizeAttributes(result)
    };
  }

  /**
   * Optimize attribute set: remove duplicates and merge class attributes
   * @param attrs
   */
  function optimizeAttributes(attrs) {
    // clone all attributes to make sure that original objects are
    // not modified
    attrs  = _.map(attrs, function(attr) {
      return _.clone(attr);
    });

    var lookup = {};
    return _.filter(attrs, function(attr) {
      if (!(attr.name in lookup)) {
        return lookup[attr.name] = attr;
      }

      var la = lookup[attr.name];

      if (attr.name.toLowerCase() == 'class') {
        la.value += (la.value.length ? ' ' : '') + attr.value;
      } else {
        la.value = attr.value;
      }

      return false;
    });
  }

  /**
   * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation
   * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.
   * If nothing found, returns <code>null</code>
   * @param {String} abbr
   *
   */
  function extractText(abbr) {
    if (!~abbr.indexOf('{'))
      return null;

    /** @type StringStream */
    var stream = require('stringStream').create(abbr);
    while (!stream.eol()) {
      switch (stream.peek()) {
        case '[':
        case '(':
          stream.skipToPair(stream.peek(), pairs[stream.peek()]); break;

        case '{':
          stream.start = stream.pos;
          stream.skipToPair('{', '}');
          return {
            element: abbr.substring(0, stream.start),
            text: stripped(stream.current())
          };

        default:
          stream.next();
      }
    }
  }

  /**
   * â€œUn-rollsâ€œ contents of current node: recursively replaces all repeating
   * children with their repeated clones
   * @param {AbbreviationNode} node
   * @returns {AbbreviationNode}
   */
  function unroll(node) {
    for (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {
      child = node.children[i];

      if (child.isRepeating()) {
        maxCount = j = child.repeatCount;
        child.repeatCount = 1;
        child.updateProperty('counter', 1);
        child.updateProperty('maxCount', maxCount);
        while (--j > 0) {
          child.parent.addChild(child.clone(), i + 1)
            .updateProperty('counter', j + 1)
            .updateProperty('maxCount', maxCount);
        }
      }
    }

    // to keep proper 'counter' property, we need to walk
    // on children once again
    _.each(node.children, unroll);

    return node;
  }

  /**
   * Optimizes tree node: replaces empty nodes with their children
   * @param {AbbreviationNode} node
   * @return {AbbreviationNode}
   */
  function squash(node) {
    for (var i = node.children.length - 1; i >= 0; i--) {
      /** @type AbbreviationNode */
      var n = node.children[i];
      if (n.isGroup()) {
        n.replace(squash(n).children);
      } else if (n.isEmpty()) {
        n.remove();
      }
    }

    _.each(node.children, squash);

    return node;
  }

  function isAllowedChar(ch) {
    var charCode = ch.charCodeAt(0);
    var specialChars = '#.*:$-_!@|%';

    return (charCode > 64 && charCode < 91)       // uppercase letter
        || (charCode > 96 && charCode < 123)  // lowercase letter
        || (charCode > 47 && charCode < 58)   // number
        || specialChars.indexOf(ch) != -1;    // special character
  }

  // XXX add counter replacer function as output processor
  outputProcessors.push(function(text, node) {
    return require('utils').replaceCounter(text, node.counter, node.maxCount);
  });

  return {
    /**
     * Parses abbreviation into tree with respect of groups,
     * text nodes and attributes. Each node of the tree is a single
     * abbreviation. Tree represents actual structure of the outputted
     * result
     * @memberOf abbreviationParser
     * @param {String} abbr Abbreviation to parse
     * @param {Object} options Additional options for parser and processors
     *
     * @return {AbbreviationNode}
     */
    parse: function(abbr, options) {
      options = options || {};

      var tree = parseAbbreviation(abbr);

      if (options.contextNode) {
        // add info about context node â€“
        // a parent XHTML node in editor inside which abbreviation is
        // expanded
        tree._name = options.contextNode.name;
        var attrLookup = {};
        _.each(tree._attributes, function(attr) {
          attrLookup[attr.name] = attr;
        });

        _.each(options.contextNode.attributes, function(attr) {
          if (attr.name in attrLookup) {
            attrLookup[attr.name].value = attr.value;
          } else {
            attr = _.clone(attr);
            tree._attributes.push(attr);
            attrLookup[attr.name] = attr;
          }
        });
      }


      // apply preprocessors
      _.each(preprocessors, function(fn) {
        fn(tree, options);
      });

      tree = squash(unroll(tree));

      // apply postprocessors
      _.each(postprocessors, function(fn) {
        fn(tree, options);
      });

      return tree;
    },

    AbbreviationNode: AbbreviationNode,

    /**
     * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function
     * that applies to a parsed abbreviation tree right after it get parsed.
     * The passed tree is in unoptimized state.
     * @param {Function} fn Preprocessor function. This function receives
     * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)
     * and <code>options</code> hash that was passed to <code>parse</code>
     * method
     */
    addPreprocessor: function(fn) {
      if (!_.include(preprocessors, fn))
        preprocessors.push(fn);
    },

    /**
     * Removes registered preprocessor
     */
    removeFilter: function(fn) {
      preprocessor = _.without(preprocessors, fn);
    },

    /**
     * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a
     * functinon that applies to <i>optimized</i> parsed abbreviation tree
     * right before it returns from <code>parse()</code> method
     * @param {Function} fn Postprocessor function. This function receives
     * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)
     * and <code>options</code> hash that was passed to <code>parse</code>
     * method
     */
    addPostprocessor: function(fn) {
      if (!_.include(postprocessors, fn))
        postprocessors.push(fn);
    },

    /**
     * Removes registered postprocessor function
     */
    removePostprocessor: function(fn) {
      postprocessors = _.without(postprocessors, fn);
    },

    /**
     * Registers output postprocessor. <i>Output processor</i> is a
     * function that applies to output part (<code>start</code>,
     * <code>end</code> and <code>content</code>) when
     * <code>AbbreviationNode.toString()</code> method is called
     */
    addOutputProcessor: function(fn) {
      if (!_.include(outputProcessors, fn))
        outputProcessors.push(fn);
    },

    /**
     * Removes registered output processor
     */
    removeOutputProcessor: function(fn) {
      outputProcessors = _.without(outputProcessors, fn);
    },

    /**
     * Check if passed symbol is valid symbol for abbreviation expression
     * @param {String} ch
     * @return {Boolean}
     */
    isAllowedChar: function(ch) {
      ch = String(ch); // convert Java object to JS
      return isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);
    }
  };
});/**
 * Processor function that matches parsed <code>AbbreviationNode</code>
 * against resources defined in <code>resource</code> module
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  /**
   * Finds matched resources for child nodes of passed <code>node</code>
   * element. A matched resource is a reference to <i>snippets.json</i> entry
   * that describes output of parsed node
   * @param {AbbreviationNode} node
   * @param {String} syntax
   */
  function matchResources(node, syntax) {
    var resources = require('resources');
    var elements = require('elements');
    var parser = require('abbreviationParser');

    // do a shallow copy because the children list can be modified during
    // resource matching
    _.each(_.clone(node.children), /** @param {AbbreviationNode} child */ function(child) {
      var r = resources.getMatchedResource(child, syntax);
      if (_.isString(r)) {
        child.data('resource', elements.create('snippet', r));
      } else if (elements.is(r, 'reference')) {
        // itâ€™s a reference to another abbreviation:
        // parse it and insert instead of current child
        /** @type AbbreviationNode */
        var subtree = parser.parse(r.data, {
          syntax: syntax
        });

        // if context element should be repeated, check if we need to
        // transfer repeated element to specific child node
        if (child.repeatCount > 1) {
          var repeatedChildren = subtree.findAll(function(node) {
            return node.hasImplicitRepeat;
          });

          _.each(repeatedChildren, function(node) {
            node.repeatCount = child.repeatCount;
            node.hasImplicitRepeat = false;
          });
        }

        // move childâ€˜s children into the deepest child of new subtree
        var deepestChild = subtree.deepestChild();
        if (deepestChild) {
          _.each(child.children, function(c) {
            deepestChild.addChild(c);
          });
        }

        // copy current attributes to children
        _.each(subtree.children, function(node) {
          _.each(child.attributeList(), function(attr) {
            node.attribute(attr.name, attr.value);
          });
        });

        child.replace(subtree.children);
      } else {
        child.data('resource', r);
      }

      matchResources(child, syntax);
    });
  }

  // XXX register abbreviation filter that creates references to resources
  // on abbreviation nodes
  /**
   * @param {AbbreviationNode} tree
   */
  require('abbreviationParser').addPreprocessor(function(tree, options) {
    var syntax = options.syntax || emmet.defaultSyntax();
    matchResources(tree, syntax);
  });

});/**
 * Pasted content abbreviation processor. A pasted content is a content that
 * should be inserted into implicitly repeated abbreviation nodes.
 * This processor powers â€œWrap With Abbreviationâ€ action
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  var parser = require('abbreviationParser');
  var outputPlaceholder = '$#';

  /**
   * Locates output placeholders inside text
   * @param {String} text
   * @returns {Array} Array of ranges of output placeholder in text
   */
  function locateOutputPlaceholder(text) {
    var range = require('range');
    var result = [];

    /** @type StringStream */
    var stream = require('stringStream').create(text);

    while (!stream.eol()) {
      if (stream.peek() == '\\') {
        stream.next();
      } else {
        stream.start = stream.pos;
        if (stream.match(outputPlaceholder, true)) {
          result.push(range.create(stream.start, outputPlaceholder));
          continue;
        }
      }
      stream.next();
    }

    return result;
  }

  /**
   * Replaces output placeholders inside <code>source</code> with
   * <code>value</code>
   * @param {String} source
   * @param {String} value
   * @returns {String}
   */
  function replaceOutputPlaceholders(source, value) {
    var utils = require('utils');
    var ranges = locateOutputPlaceholder(source);

    ranges.reverse();
    _.each(ranges, function(r) {
      source = utils.replaceSubstring(source, value, r);
    });

    return source;
  }

  /**
   * Check if parsed node contains output placeholder â€“ a target where
   * pasted content should be inserted
   * @param {AbbreviationNode} node
   * @returns {Boolean}
   */
  function hasOutputPlaceholder(node) {
    if (locateOutputPlaceholder(node.content).length)
      return true;

    // check if attributes contains placeholder
    return !!_.find(node.attributeList(), function(attr) {
      return !!locateOutputPlaceholder(attr.value).length;
    });
  }

  /**
   * Insert pasted content into correct positions of parsed node
   * @param {AbbreviationNode} node
   * @param {String} content
   * @param {Boolean} overwrite Overwrite node content if no value placeholders
   * found instead of appending to existing content
   */
  function insertPastedContent(node, content, overwrite) {
    var nodesWithPlaceholders = node.findAll(function(item) {
      return hasOutputPlaceholder(item);
    });

    if (hasOutputPlaceholder(node))
      nodesWithPlaceholders.unshift(node);

    if (nodesWithPlaceholders.length) {
      _.each(nodesWithPlaceholders, function(item) {
        item.content = replaceOutputPlaceholders(item.content, content);
        _.each(item._attributes, function(attr) {
          attr.value = replaceOutputPlaceholders(attr.value, content);
        });
      });
    } else {
      // on output placeholders in subtree, insert content in the deepest
      // child node
      var deepest = node.deepestChild() || node;
      if (overwrite) {
        deepest.content = content;
      } else {
        deepest.content = require('abbreviationUtils').insertChildContent(deepest.content, content);
      }
    }
  }

  /**
   * @param {AbbreviationNode} tree
   * @param {Object} options
   */
  parser.addPreprocessor(function(tree, options) {
    if (options.pastedContent) {
      var utils = require('utils');
      var lines = _.map(utils.splitByLines(options.pastedContent, true), utils.trim);

      // set repeat count for implicitly repeated elements before
      // tree is unrolled
      tree.findAll(function(item) {
        if (item.hasImplicitRepeat) {
          item.data('paste', lines);
          return item.repeatCount = lines.length;
        }
      });
    }
  });

  /**
   * @param {AbbreviationNode} tree
   * @param {Object} options
   */
  parser.addPostprocessor(function(tree, options) {
    // for each node with pasted content, update text data
    var targets = tree.findAll(function(item) {
      var pastedContentObj = item.data('paste');
      var pastedContent = '';
      if (_.isArray(pastedContentObj)) {
        pastedContent = pastedContentObj[item.counter - 1];
      } else if (_.isFunction(pastedContentObj)) {
        pastedContent = pastedContentObj(item.counter - 1, item.content);
      } else if (pastedContentObj) {
        pastedContent = pastedContentObj;
      }

      if (pastedContent) {
        insertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));
      }

      item.data('paste', null);
      return !!pastedContentObj;
    });

    if (!targets.length && options.pastedContent) {
      // no implicitly repeated elements, put pasted content in
      // the deepest child
      insertPastedContent(tree, options.pastedContent);
    }
  });
});/**
 * Resolves tag names in abbreviations with implied name
 */
emmet.exec(function(require, _) {
  /**
   * Resolves implicit node names in parsed tree
   * @param {AbbreviationNode} tree
   */
  function resolveNodeNames(tree) {
    var tagName = require('tagName');
    _.each(tree.children, function(node) {
      if (node.hasImplicitName() || node.data('forceNameResolving')) {
        node._name = tagName.resolve(node.parent.name());
      }
      resolveNodeNames(node);
    });

    return tree;
  }

  require('abbreviationParser').addPostprocessor(resolveNodeNames);
});/**
 * @author Stoyan Stefanov
 * @link https://github.com/stoyan/etc/tree/master/cssex
 */

emmet.define('cssParser', function(require, _) {
var walker, tokens = [], isOp, isNameChar, isDigit;

    // walks around the source
    walker = {
        lines: null,
        total_lines: 0,
        linenum: -1,
        line: '',
        ch: '',
        chnum: -1,
        init: function (source) {
            var me = walker;

            // source, yumm
            me.lines = source
                .replace(/\r\n/g, '\n')
                .replace(/\r/g, '\n')
                .split('\n');
            me.total_lines = me.lines.length;

            // reset
            me.chnum = -1;
            me.linenum = -1;
            me.ch = '';
            me.line = '';

            // advance
            me.nextLine();
            me.nextChar();
        },
        nextLine: function () {
            var me = this;
            me.linenum += 1;
            if (me.total_lines <= me.linenum) {
                me.line = false;
            } else {
                me.line = me.lines[me.linenum];
            }
            if (me.chnum !== -1) {
                me.chnum = 0;
            }
            return me.line;
        },
        nextChar: function () {
            var me = this;
            me.chnum += 1;
            while (me.line.charAt(me.chnum) === '') {
                if (this.nextLine() === false) {
                    me.ch = false;
                    return false; // end of source
                }
                me.chnum = -1;
                me.ch = '\n';
                return '\n';
            }
            me.ch = me.line.charAt(me.chnum);
            return me.ch;
        },
        peek: function() {
            return this.line.charAt(this.chnum + 1);
        }
    };

    // utility helpers
    isNameChar = function (c) {
      // be more tolerate for name tokens: allow & character for LESS syntax
        return (c == '&' || c === '_' || c === '-' || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));
    };

    isDigit = function (ch) {
        return (ch !== false && ch >= '0' && ch <= '9');
    };

    isOp = (function () {
        var opsa = "{}[]()+*=.,;:>~|\\%$#@^!".split(''),
            opsmatcha = "*^|$~".split(''),
            ops = {},
            opsmatch = {},
            i = 0;
        for (; i < opsa.length; i += 1) {
            ops[opsa[i]] = true;
        }
        for (i = 0; i < opsmatcha.length; i += 1) {
            opsmatch[opsmatcha[i]] = true;
        }
        return function (ch, matchattr) {
            if (matchattr) {
                return !!opsmatch[ch];
            }
            return !!ops[ch];
        };
    }());

    // shorthands
    function isset(v) {
        return typeof v !== 'undefined';
    }
    function getConf() {
        return {
            'char': walker.chnum,
            line: walker.linenum
        };
    }


    // creates token objects and pushes them to a list
    function tokener(value, type, conf) {
        var w = walker, c = conf || {};
        tokens.push({
            charstart: isset(c['char']) ? c['char'] : w.chnum,
            charend:   isset(c.charend) ? c.charend : w.chnum,
            linestart: isset(c.line)    ? c.line    : w.linenum,
            lineend:   isset(c.lineend) ? c.lineend : w.linenum,
            value:     value,
            type:      type || value
        });
    }

    // oops
    function error(m, config) {
        var w = walker,
            conf = config || {},
            c = isset(conf['char']) ? conf['char'] : w.chnum,
            l = isset(conf.line) ? conf.line : w.linenum;
        return {
            name: "ParseError",
            message: m + " at line " + (l + 1) + ' char ' + (c + 1),
            walker: w,
            tokens: tokens
        };
    }


    // token handlers follow for:
    // white space, comment, string, identifier, number, operator
    function white() {

        var c = walker.ch,
            token = '',
            conf = getConf();

        while (c === " " || c === "\t") {
            token += c;
            c = walker.nextChar();
        }

        tokener(token, 'white', conf);

    }

    function comment() {

        var w = walker,
            c = w.ch,
            token = c,
            cnext,
            conf = getConf();

        cnext = w.nextChar();

        if (cnext !== '*') {
            // oops, not a comment, just a /
            conf.charend = conf['char'];
            conf.lineend = conf.line;
            return tokener(token, token, conf);
        }

        while (!(c === "*" && cnext === "/")) {
            token += cnext;
            c = cnext;
            cnext = w.nextChar();
        }
        token += cnext;
        w.nextChar();
        tokener(token, 'comment', conf);
    }

    function str() {
        var w = walker,
            c = w.ch,
            q = c,
            token = c,
            cnext,
            conf = getConf();

        c = w.nextChar();

        while (c !== q) {

            if (c === '\n') {
                cnext = w.nextChar();
                if (cnext === "\\") {
                    token += c + cnext;
                } else {
                    // end of line with no \ escape = bad
                    throw error("Unterminated string", conf);
                }
            } else {
                if (c === "\\") {
                    token += c + w.nextChar();
                } else {
                    token += c;
                }
            }

            c = w.nextChar();

        }
        token += c;
        w.nextChar();
        tokener(token, 'string', conf);
    }

    function brace() {
        var w = walker,
            c = w.ch,
            depth = 0,
            token = c,
            conf = getConf();

        c = w.nextChar();

        while (c !== ')' && !depth) {
          if (c === '(') {
            depth++;
          } else if (c === ')') {
            depth--;
          } else if (c === false) {
            throw error("Unterminated brace", conf);
          }

          token += c;
            c = w.nextChar();
        }

        token += c;
        w.nextChar();
        tokener(token, 'brace', conf);
    }

    function identifier(pre) {
        var w = walker,
            c = w.ch,
            conf = getConf(),
            token = (pre) ? pre + c : c;

        c = w.nextChar();

        if (pre) { // adjust token position
          conf['char'] -= pre.length;
        }

        while (isNameChar(c) || isDigit(c)) {
            token += c;
            c = w.nextChar();
        }

        tokener(token, 'identifier', conf);
    }

    function num() {
        var w = walker,
            c = w.ch,
            conf = getConf(),
            token = c,
            point = token === '.',
            nondigit;

        c = w.nextChar();
        nondigit = !isDigit(c);

        // .2px or .classname?
        if (point && nondigit) {
            // meh, NaN, could be a class name, so it's an operator for now
            conf.charend = conf['char'];
            conf.lineend = conf.line;
            return tokener(token, '.', conf);
        }

        // -2px or -moz-something
        if (token === '-' && nondigit) {
            return identifier('-');
        }

        while (c !== false && (isDigit(c) || (!point && c === '.'))) { // not end of source && digit or first instance of .
            if (c === '.') {
                point = true;
            }
            token += c;
            c = w.nextChar();
        }

        tokener(token, 'number', conf);

    }

    function op() {
        var w = walker,
            c = w.ch,
            conf = getConf(),
            token = c,
            next = w.nextChar();

        if (next === "=" && isOp(token, true)) {
            token += next;
            tokener(token, 'match', conf);
            w.nextChar();
            return;
        }

        conf.charend = conf['char'] + 1;
        conf.lineend = conf.line;
        tokener(token, token, conf);
    }


    // call the appropriate handler based on the first character in a token suspect
    function tokenize() {

        var ch = walker.ch;

        if (ch === " " || ch === "\t") {
            return white();
        }

        if (ch === '/') {
            return comment();
        }

        if (ch === '"' || ch === "'") {
            return str();
        }

        if (ch === '(') {
            return brace();
        }

        if (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)
            return num();
        }

        if (isNameChar(ch)) {
            return identifier();
        }

        if (isOp(ch)) {
            return op();
        }

        if (ch === "\n") {
            tokener("line");
            walker.nextChar();
            return;
        }

        throw error("Unrecognized character");
    }

    /**
   * Returns newline character at specified position in content
   * @param {String} content
   * @param {Number} pos
   * @return {String}
   */
  function getNewline(content, pos) {
    return content.charAt(pos) == '\r' && content.charAt(pos + 1) == '\n'
      ? '\r\n'
      : content.charAt(pos);
  }

    return {
      /**
       * @param source
       * @returns
       * @memberOf emmet.cssParser
       */
        lex: function (source) {
            walker.init(source);
            tokens = [];
            while (walker.ch !== false) {
                tokenize();
            }
            return tokens;
        },

        /**
         * Tokenizes CSS source
         * @param {String} source
         * @returns {Array}
         */
        parse: function(source) {
          // transform tokens
       var pos = 0;
       return _.map(this.lex(source), function(token) {
         if (token.type == 'line') {
           token.value = getNewline(source, pos);
         }

         return {
           type: token.type,
           start: pos,
           end: (pos += token.value.length)
         };
      });
    },

        toSource: function (toks) {
            var i = 0, max = toks.length, t, src = '';
            for (; i < max; i += 1) {
                t = toks[i];
                if (t.type === 'line') {
                    src += '\n';
                } else {
                    src += t.value;
                }
            }
            return src;
        }
    };
});/**
 * HTML tokenizer by Marijn Haverbeke
 * http://codemirror.net/
 * @constructor
 * @memberOf __xmlParseDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('xmlParser', function(require, _) {
  var Kludges = {
    autoSelfClosers : {},
    implicitlyClosed : {},
    contextGrabbers : {},
    doNotIndent : {},
    allowUnquoted : true,
    allowMissing : true
  };

  // Return variables for tokenizers
  var tagName = null, type = null;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA["))
            return chain(inBlock("atom", "]]>"));
          else
            return null;
        } else if (stream.match("--"))
          return chain(inBlock("comment", "-->"));
        else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else
          return null;
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        stream.eatSpace();
        tagName = "";
        var c;
        while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/)))
          tagName += c;
        state.tokenize = inTag;
        return "tag";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return "text";
    }
  }

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      return state.tokenize(stream, state);
    } else {
      stream.eatWhile(/[^\s\u00a0=<>\"\'\/?]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }

  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  var curState = null, setStyle;
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--)
      curState.cc.push(arguments[i]);
  }

  function cont() {
    pass.apply(null, arguments);
    return true;
  }

  function pushContext(tagName, startOfLine) {
    var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName)
      || (curState.context && curState.context.noIndent);
    curState.context = {
      prev : curState.context,
      tagName : tagName,
      indent : curState.indented,
      startOfLine : startOfLine,
      noIndent : noIndent
    };
  }

  function popContext() {
    if (curState.context)
      curState.context = curState.context.prev;
  }

  function element(type) {
    if (type == "openTag") {
      curState.tagName = tagName;
      return cont(attributes, endtag(curState.startOfLine));
    } else if (type == "closeTag") {
      var err = false;
      if (curState.context) {
        if (curState.context.tagName != tagName) {
          if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
            popContext();
          }
          err = !curState.context || curState.context.tagName != tagName;
        }
      } else {
        err = true;
      }

      if (err)
        setStyle = "error";
      return cont(endclosetag(err));
    }
    return cont();
  }

  function endtag(startOfLine) {
    return function(type) {
      if (type == "selfcloseTag"
          || (type == "endTag" && Kludges.autoSelfClosers
              .hasOwnProperty(curState.tagName
                  .toLowerCase()))) {
        maybePopContext(curState.tagName.toLowerCase());
        return cont();
      }
      if (type == "endTag") {
        maybePopContext(curState.tagName.toLowerCase());
        pushContext(curState.tagName, startOfLine);
        return cont();
      }
      return cont();
    };
  }

  function endclosetag(err) {
    return function(type) {
      if (err)
        setStyle = "error";
      if (type == "endTag") {
        popContext();
        return cont();
      }
      setStyle = "error";
      return cont(arguments.callee);
    };
  }

  function maybePopContext(nextTagName) {
    var parentTagName;
    while (true) {
      if (!curState.context) {
        return;
      }
      parentTagName = curState.context.tagName.toLowerCase();
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName)
          || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext();
    }
  }

  function attributes(type) {
    if (type == "word") {
      setStyle = "attribute";
      return cont(attribute, attributes);
    }
    if (type == "endTag" || type == "selfcloseTag")
      return pass();
    setStyle = "error";
    return cont(attributes);
  }

  function attribute(type) {
    if (type == "equals")
      return cont(attvalue, attributes);
    if (!Kludges.allowMissing)
      setStyle = "error";
    return (type == "endTag" || type == "selfcloseTag") ? pass()
        : cont();
  }

  function attvalue(type) {
    if (type == "string")
      return cont(attvaluemaybe);
    if (type == "word" && Kludges.allowUnquoted) {
      setStyle = "string";
      return cont();
    }
    setStyle = "error";
    return (type == "endTag" || type == "selfCloseTag") ? pass()
        : cont();
  }

  function attvaluemaybe(type) {
    if (type == "string")
      return cont(attvaluemaybe);
    else
      return pass();
  }

  function startState() {
    return {
      tokenize : inText,
      cc : [],
      indented : 0,
      startOfLine : true,
      tagName : null,
      context : null
    };
  }

  function token(stream, state) {
    if (stream.sol()) {
      state.startOfLine = true;
      state.indented = 0;
    }

    if (stream.eatSpace())
      return null;

    setStyle = type = tagName = null;
    var style = state.tokenize(stream, state);
    state.type = type;
    if ((style || type) && style != "comment") {
      curState = state;
      while (true) {
        var comb = state.cc.pop() || element;
        if (comb(type || style))
          break;
      }
    }
    state.startOfLine = false;
    return setStyle || style;
  }

  return {
    /**
     * @memberOf emmet.xmlParser
     * @returns
     */
    parse: function(data, offset) {
      offset = offset || 0;
      var state = startState();
      var stream = require('stringStream').create(data);
      var tokens = [];
      while (!stream.eol()) {
        tokens.push({
          type: token(stream, state),
          start: stream.start + offset,
          end: stream.pos + offset
        });
        stream.start = stream.pos;
      }

      return tokens;
    }
  };
});
/*!
 * string_score.js: String Scoring Algorithm 0.1.10
 *
 * http://joshaven.com/string_score
 * https://github.com/joshaven/string_score
 *
 * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>
 * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score
 * MIT license: http://www.opensource.org/licenses/mit-license.php
 *
 * Date: Tue Mar 1 2011
*/

/**
 * Scores a string against another string.
 *  'Hello World'.score('he');     //=> 0.5931818181818181
 *  'Hello World'.score('Hello');  //=> 0.7318181818181818
 */
emmet.define('string-score', function(require, _) {
  return {
    score: function(string, abbreviation, fuzziness) {
      // If the string is equal to the abbreviation, perfect match.
        if (string == abbreviation) {return 1;}
        //if it's not a perfect match and is empty return 0
        if(abbreviation == "") {return 0;}

        var total_character_score = 0,
            abbreviation_length = abbreviation.length,
            string_length = string.length,
            start_of_string_bonus,
            abbreviation_score,
            fuzzies=1,
            final_score;

        // Walk through abbreviation and add up scores.
        for (var i = 0,
               character_score/* = 0*/,
               index_in_string/* = 0*/,
               c/* = ''*/,
               index_c_lowercase/* = 0*/,
               index_c_uppercase/* = 0*/,
               min_index/* = 0*/;
           i < abbreviation_length;
           ++i) {

          // Find the first case-insensitive match of a character.
          c = abbreviation.charAt(i);

          index_c_lowercase = string.indexOf(c.toLowerCase());
          index_c_uppercase = string.indexOf(c.toUpperCase());
          min_index = Math.min(index_c_lowercase, index_c_uppercase);
          index_in_string = (min_index > -1) ? min_index : Math.max(index_c_lowercase, index_c_uppercase);

          if (index_in_string === -1) {
            if (fuzziness) {
              fuzzies += 1-fuzziness;
              continue;
            } else {
              return 0;
            }
          } else {
            character_score = 0.1;
          }

          // Set base score for matching 'c'.

          // Same case bonus.
          if (string[index_in_string] === c) {
            character_score += 0.1;
          }

          // Consecutive letter & start-of-string Bonus
          if (index_in_string === 0) {
            // Increase the score when matching first character of the remainder of the string
            character_score += 0.6;
            if (i === 0) {
              // If match is the first character of the string
              // & the first character of abbreviation, add a
              // start-of-string match bonus.
              start_of_string_bonus = 1; //true;
            }
          }
          else {
        // Acronym Bonus
        // Weighing Logic: Typing the first character of an acronym is as if you
        // preceded it with two perfect character matches.
        if (string.charAt(index_in_string - 1) === ' ') {
          character_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5
        }
          }

          // Left trim the already matched part of the string
          // (forces sequential matching).
          string = string.substring(index_in_string + 1, string_length);

          total_character_score += character_score;
        } // end of for loop

        // Uncomment to weigh smaller words higher.
        // return total_character_score / string_length;

        abbreviation_score = total_character_score / abbreviation_length;
        //percentage_of_matched_string = abbreviation_length / string_length;
        //word_score = abbreviation_score * percentage_of_matched_string;

        // Reduce penalty for longer strings.
        //final_score = (word_score + abbreviation_score) / 2;
        final_score = ((abbreviation_score * (abbreviation_length / string_length)) + abbreviation_score) / 2;

        final_score = final_score / fuzzies;

        if (start_of_string_bonus && (final_score + 0.15 < 1)) {
          final_score += 0.15;
        }

        return final_score;
    }
  };
});/**
 * Utility module for Emmet
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('utils', function(require, _) {
  /**
   * Special token used as a placeholder for caret positions inside
   * generated output
   */
  var caretPlaceholder = '${0}';

  /**
   * A simple string builder, optimized for faster text concatenation
   * @param {String} value Initial value
   */
  function StringBuilder(value) {
    this._data = [];
    this.length = 0;

    if (value)
      this.append(value);
  }

  StringBuilder.prototype = {
    /**
     * Append string
     * @param {String} text
     */
    append: function(text) {
      this._data.push(text);
      this.length += text.length;
    },

    /**
     * @returns {String}
     */
    toString: function() {
      return this._data.join('');
    },

    /**
     * @returns {String}
     */
    valueOf: function() {
      return this.toString();
    }
  };

  return {
    /** @memberOf utils */
    reTag: /<\/?[\w:\-]+(?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*\s*(\/?)>$/,

    /**
     * Test if passed string ends with XHTML tag. This method is used for testing
     * '>' character: it belongs to tag or it's a part of abbreviation?
     * @param {String} str
     * @return {Boolean}
     */
    endsWithTag: function(str) {
      return this.reTag.test(str);
    },

    /**
     * Check if passed symbol is a number
     * @param {String} ch
     * @returns {Boolean}
     */
    isNumeric: function(ch) {
      if (typeof(ch) == 'string')
        ch = ch.charCodeAt(0);

      return (ch && ch > 47 && ch < 58);
    },

    /**
     * Trim whitespace from string
     * @param {String} text
     * @return {String}
     */
    trim: function(text) {
      return (text || "").replace(/^\s+|\s+$/g, "");
    },

    /**
     * Returns newline character
     * @returns {String}
     */
    getNewline: function() {
      var res = require('resources');
      if (!res) {
        return '\n';
      }

      var nl = res.getVariable('newline');
      return _.isString(nl) ? nl : '\n';
    },

    /**
     * Sets new newline character that will be used in output
     * @param {String} str
     */
    setNewline: function(str) {
      var res = require('resources');
      res.setVariable('newline', str);
      res.setVariable('nl', str);
    },

    /**
     * Split text into lines. Set <code>remove_empty</code> to true to filter
     * empty lines
     * @param {String} text Text to split
     * @param {Boolean} removeEmpty Remove empty lines from result
     * @return {Array}
     */
    splitByLines: function(text, removeEmpty) {
      // IE fails to split string by regexp,
      // need to normalize newlines first
      // Also, Mozilla's Rhiho JS engine has a weird newline bug
      var nl = this.getNewline();
      var lines = (text || '')
        .replace(/\r\n/g, '\n')
        .replace(/\n\r/g, '\n')
        .replace(/\r/g, '\n')
        .replace(/\n/g, nl)
        .split(nl);

      if (removeEmpty) {
        lines = _.filter(lines, function(line) {
          return line.length && !!this.trim(line);
        }, this);
      }

      return lines;
    },

    /**
     * Normalizes newline character: replaces newlines in <code>text</code>
     * with newline defined in preferences
     * @param {String} text
     * @returns {String}
     */
    normalizeNewline: function(text) {
      return this.splitByLines(text).join(this.getNewline());
    },

    /**
     * Repeats string <code>howMany</code> times
     * @param {String} str
     * @param {Number} how_many
     * @return {String}
     */
    repeatString: function(str, howMany) {
      var result = [];

      for (var i = 0; i < howMany; i++)
        result.push(str);

      return result.join('');
    },

    /**
     * Returns list of paddings that should be used to align passed string
     * @param {Array} strings
     * @returns {Array}
     */
    getStringsPads: function(strings) {
      var lengths = _.map(strings, function(s) {
        return _.isString(s) ? s.length : +s;
      });

      var max = _.max(lengths);
      return _.map(lengths, function(l) {
        var pad = max - l;
        return pad ? this.repeatString(' ', pad) : '';
      }, this);
    },

    /**
     * Indents text with padding
     * @param {String} text Text to indent
     * @param {String} pad Padding size (number) or padding itself (string)
     * @return {String}
     */
    padString: function(text, pad) {
      var padStr = (_.isNumber(pad))
        ? this.repeatString(require('resources').getVariable('indentation') || '\t', pad)
        : pad;

      var result = [];

      var lines = this.splitByLines(text);
      var nl = this.getNewline();

      result.push(lines[0]);
      for (var j = 1; j < lines.length; j++)
        result.push(nl + padStr + lines[j]);

      return result.join('');
    },

    /**
     * Pad string with zeroes
     * @param {String} str String to pad
     * @param {Number} pad Desired string length
     * @return {String}
     */
    zeroPadString: function(str, pad) {
      var padding = '';
      var il = str.length;

      while (pad > il++) padding += '0';
      return padding + str;
    },

    /**
     * Removes padding at the beginning of each text's line
     * @param {String} text
     * @param {String} pad
     */
    unindentString: function(text, pad) {
      var lines = this.splitByLines(text);
      for (var i = 0; i < lines.length; i++) {
        if (lines[i].search(pad) == 0)
          lines[i] = lines[i].substr(pad.length);
      }

      return lines.join(this.getNewline());
    },

    /**
     * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol
     * will be replaced in 'item$count', but not in 'item\$count'.
     * @param {String} str Original string
     * @param {String} symbol Symbol to replace
     * @param {String} replace Symbol replacement. Might be a function that
     * returns new value
     * @return {String}
     */
    replaceUnescapedSymbol: function(str, symbol, replace) {
      var i = 0;
      var il = str.length;
      var sl = symbol.length;
      var matchCount = 0;

      while (i < il) {
        if (str.charAt(i) == '\\') {
          // escaped symbol, skip next character
          i += sl + 1;
        } else if (str.substr(i, sl) == symbol) {
          // have match
          var curSl = sl;
          matchCount++;
          var newValue = replace;
          if (_.isFunction(replace)) {
            var replaceData = replace(str, symbol, i, matchCount);
            if (replaceData) {
              curSl = replaceData[0].length;
              newValue = replaceData[1];
            } else {
              newValue = false;
            }
          }

          if (newValue === false) { // skip replacement
            i++;
            continue;
          }

          str = str.substring(0, i) + newValue + str.substring(i + curSl);
          // adjust indexes
          il = str.length;
          i += newValue.length;
        } else {
          i++;
        }
      }

      return str;
    },

    /**
     * Replace variables like ${var} in string
     * @param {String} str
     * @param {Object} vars Variable set (defaults to variables defined in
     * <code>snippets.json</code>) or variable resolver (<code>Function</code>)
     * @return {String}
     */
    replaceVariables: function(str, vars) {
      vars = vars || {};
      var resolver = _.isFunction(vars) ? vars : function(str, p1) {
        return p1 in vars ? vars[p1] : null;
      };

      var res = require('resources');
      return require('tabStops').processText(str, {
        variable: function(data) {
          var newValue = resolver(data.token, data.name, data);
          if (newValue === null) {
            // try to find variable in resources
            newValue = res.getVariable(data.name);
          }

          if (newValue === null || _.isUndefined(newValue))
            // nothing found, return token itself
            newValue = data.token;
          return newValue;
        }
      });
    },

    /**
     * Replaces '$' character in string assuming it might be escaped with '\'
     * @param {String} str String where character should be replaced
     * @param {String} value New value
     * @return {String}
     */
    replaceCounter: function(str, value, total) {
      var symbol = '$';
      // in case we received strings from Java, convert the to native strings
      str = String(str);
      value = String(value);

      if (/^\-?\d+$/.test(value)) {
        value = +value;
      }

      var that = this;

      return this.replaceUnescapedSymbol(str, symbol, function(str, symbol, pos, matchNum){
        if (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1)) ) {
          // it's a variable, skip it
          return false;
        }

        // replace sequense of $ symbols with padded number
        var j = pos + 1;
        while(str.charAt(j) == '$' && str.charAt(j + 1) != '{') j++;
        var pad = j - pos;

        // get counter base
        var base = 0, decrement = false, m;
        if (m = str.substr(j).match(/^@(\-?)(\d*)/)) {
          j += m[0].length;

          if (m[1]) {
            decrement = true;
          }

          base = parseInt(m[2] || 1) - 1;
        }

        if (decrement && total && _.isNumber(value)) {
          value = total - value + 1;
        }

        value += base;

        return [str.substring(pos, j), that.zeroPadString(value + '', pad)];
      });
    },

    /**
     * Check if string matches against <code>reTag</code> regexp. This
     * function may be used to test if provided string contains HTML tags
     * @param {String} str
     * @returns {Boolean}
     */
    matchesTag: function(str) {
      return this.reTag.test(str || '');
    },

    /**
     * Escapes special characters used in Emmet, like '$', '|', etc.
     * Use this method before passing to actions like "Wrap with Abbreviation"
     * to make sure that existing special characters won't be altered
     * @param {String} text
     * @return {String}
     */
    escapeText: function(text) {
      return text.replace(/([\$\\])/g, '\\$1');
    },

    /**
     * Unescapes special characters used in Emmet, like '$', '|', etc.
     * @param {String} text
     * @return {String}
     */
    unescapeText: function(text) {
      return text.replace(/\\(.)/g, '$1');
    },

    /**
     * Returns caret placeholder
     * @returns {String}
     */
    getCaretPlaceholder: function() {
      return _.isFunction(caretPlaceholder)
        ? caretPlaceholder.apply(this, arguments)
        : caretPlaceholder;
    },

    /**
     * Sets new representation for carets in generated output
     * @param {String} value New caret placeholder. Might be a
     * <code>Function</code>
     */
    setCaretPlaceholder: function(value) {
      caretPlaceholder = value;
    },

    /**
     * Returns line padding
     * @param {String} line
     * @return {String}
     */
    getLinePadding: function(line) {
      return (line.match(/^(\s+)/) || [''])[0];
    },

    /**
     * Helper function that returns padding of line of <code>pos</code>
     * position in <code>content</code>
     * @param {String} content
     * @param {Number} pos
     * @returns {String}
     */
    getLinePaddingFromPosition: function(content, pos) {
      var lineRange = this.findNewlineBounds(content, pos);
      return this.getLinePadding(lineRange.substring(content));
    },

    /**
     * Escape special regexp chars in string, making it usable for creating dynamic
     * regular expressions
     * @param {String} str
     * @return {String}
     */
    escapeForRegexp: function(str) {
      var specials = new RegExp("[.*+?|()\\[\\]{}\\\\]", "g"); // .*+?|()[]{}\
      return str.replace(specials, "\\$&");
    },

    /**
     * Make decimal number look good: convert it to fixed precision end remove
     * traling zeroes
     * @param {Number} num
     * @param {Number} fracion Fraction numbers (default is 2)
     * @return {String}
     */
    prettifyNumber: function(num, fraction) {
      return num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\.?0+$/, '');
    },

    /**
     * A simple mutable string shim, optimized for faster text concatenation
     * @param {String} value Initial value
     * @returns {StringBuilder}
     */
    stringBuilder: function(value) {
      return new StringBuilder(value);
    },

    /**
     * Replace substring of <code>str</code> with <code>value</code>
     * @param {String} str String where to replace substring
     * @param {String} value New substring value
     * @param {Number} start Start index of substring to replace. May also
     * be a <code>Range</code> object: in this case, the <code>end</code>
     * argument is not required
     * @param {Number} end End index of substring to replace. If ommited,
     * <code>start</code> argument is used
     */
    replaceSubstring: function(str, value, start, end) {
      if (_.isObject(start) && 'end' in start) {
        end = start.end;
        start = start.start;
      }

      if (_.isString(end))
        end = start + end.length;

      if (_.isUndefined(end))
        end = start;

      if (start < 0 || start > str.length)
        return str;

      return str.substring(0, start) + value + str.substring(end);
    },

    /**
     * Narrows down text range, adjusting selection to non-space characters
     * @param {String} text
     * @param {Number} start Starting range in <code>text</code> where
     * slection should be adjusted. Can also be any object that is accepted
     * by <code>Range</code> class
     * @return {Range}
     */
    narrowToNonSpace: function(text, start, end) {
      var range = require('range').create(start, end);

      var reSpace = /[\s\n\r\u00a0]/;
      // narrow down selection until first non-space character
      while (range.start < range.end) {
        if (!reSpace.test(text.charAt(range.start)))
          break;

        range.start++;
      }

      while (range.end > range.start) {
        range.end--;
        if (!reSpace.test(text.charAt(range.end))) {
          range.end++;
          break;
        }
      }

      return range;
    },

    /**
     * Find start and end index of text line for <code>from</code> index
     * @param {String} text
     * @param {Number} from
     */
    findNewlineBounds: function(text, from) {
      var len = text.length,
        start = 0,
        end = len - 1;

      // search left
      for (var i = from - 1; i > 0; i--) {
        var ch = text.charAt(i);
        if (ch == '\n' || ch == '\r') {
          start = i + 1;
          break;
        }
      }
      // search right
      for (var j = from; j < len; j++) {
        var ch = text.charAt(j);
        if (ch == '\n' || ch == '\r') {
          end = j;
          break;
        }
      }

      return require('range').create(start, end - start);
    },

    /**
     * Deep merge of two or more objects. Taken from jQuery.extend()
     */
    deepMerge: function() {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length;


      // Handle case when target is a string or something (possible in deep copy)
      if (!_.isObject(target) && !_.isFunction(target)) {
        target = {};
      }

      for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
          // Extend the base object
          for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            if ( target === copy ) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( copy && ( _.isObject(copy) || (copyIsArray = _.isArray(copy)) ) ) {
              if ( copyIsArray ) {
                copyIsArray = false;
                clone = src && _.isArray(src) ? src : [];

              } else {
                clone = src && _.isObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[ name ] = this.deepMerge(clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
              target[ name ] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    }
  };
});
/**
 * Helper module to work with ranges
 * @constructor
 * @memberOf __rangeDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('range', function(require, _) {
  function cmp(a, b, op) {
    switch (op) {
      case 'eq':
      case '==':
        return a === b;
      case 'lt':
      case '<':
        return a < b;
      case 'lte':
      case '<=':
        return a <= b;
      case 'gt':
      case '>':
        return a > b;
      case 'gte':
      case '>=':
        return a >= b;
    }
  }


  /**
   * @type Range
   * @constructor
   * @param {Object} start
   * @param {Number} len
   */
  function Range(start, len) {
    if (_.isObject(start) && 'start' in start) {
      // create range from object stub
      this.start = Math.min(start.start, start.end);
      this.end = Math.max(start.start, start.end);
    } else if (_.isArray(start)) {
      this.start = start[0];
      this.end = start[1];
    } else {
      len = _.isString(len) ? len.length : +len;
      this.start = start;
      this.end = start + len;
    }
  }

  Range.prototype = {
    length: function() {
      return Math.abs(this.end - this.start);
    },

    /**
     * Returns <code>true</code> if passed range is equals to current one
     * @param {Range} range
     * @returns {Boolean}
     */
    equal: function(range) {
      return this.cmp(range, 'eq', 'eq');
//      return this.start === range.start && this.end === range.end;
    },

    /**
     * Shifts indexes position with passed <code>delat</code>
     * @param {Number} delta
     * @returns {Range} range itself
     */
    shift: function(delta) {
      this.start += delta;
      this.end += delta;
      return this;
    },

    /**
     * Check if two ranges are overlapped
     * @param {Range} range
     * @returns {Boolean}
     */
    overlap: function(range) {
      return range.start <= this.end && range.end >= this.start;
    },

    /**
     * Finds intersection of two ranges
     * @param {Range} range
     * @returns {Range} <code>null</code> if ranges does not overlap
     */
    intersection: function(range) {
      if (this.overlap(range)) {
        var start = Math.max(range.start, this.start);
        var end = Math.min(range.end, this.end);
        return new Range(start, end - start);
      }

      return null;
    },

    /**
     * Returns the union of the thow ranges.
     * @param {Range} range
     * @returns {Range} <code>null</code> if ranges are not overlapped
     */
    union: function(range) {
      if (this.overlap(range)) {
        var start = Math.min(range.start, this.start);
        var end = Math.max(range.end, this.end);
        return new Range(start, end - start);
      }

      return null;
    },

    /**
     * Returns a Boolean value that indicates whether a specified position
     * is in a given range.
     * @param {Number} loc
     */
    inside: function(loc) {
      return this.cmp(loc, 'lte', 'gt');
//      return this.start <= loc && this.end > loc;
    },

    /**
     * Returns a Boolean value that indicates whether a specified position
     * is in a given range, but not equals bounds.
     * @param {Number} loc
     */
    contains: function(loc) {
      return this.cmp(loc, 'lt', 'gt');
    },

    /**
     * Check if current range completely includes specified one
     * @param {Range} r
     * @returns {Boolean}
     */
    include: function(r) {
      return this.cmp(loc, 'lte', 'gte');
//      return this.start <= r.start && this.end >= r.end;
    },

    /**
     * Low-level comparision method
     * @param {Number} loc
     * @param {String} left Left comparison operator
     * @param {String} right Right comaprison operator
     */
    cmp: function(loc, left, right) {
      var a, b;
      if (loc instanceof Range) {
        a = loc.start;
        b = loc.end;
      } else {
        a = b = loc;
      }

      return cmp(this.start, a, left || '<=') && cmp(this.end, b, right || '>');
    },

    /**
     * Returns substring of specified <code>str</code> for current range
     * @param {String} str
     * @returns {String}
     */
    substring: function(str) {
      return this.length() > 0
        ? str.substring(this.start, this.end)
        : '';
    },

    /**
     * Creates copy of current range
     * @returns {Range}
     */
    clone: function() {
      return new Range(this.start, this.length());
    },

    /**
     * @returns {Array}
     */
    toArray: function() {
      return [this.start, this.end];
    },

    toString: function() {
      return '{' + this.start + ', ' + this.length() + '}';
    }
  };

  return {
    /**
     * Creates new range object instance
     * @param {Object} start Range start or array with 'start' and 'end'
     * as two first indexes or object with 'start' and 'end' properties
     * @param {Number} len Range length or string to produce range from
     * @returns {Range}
     * @memberOf emmet.range
     */
    create: function(start, len) {
      if (_.isUndefined(start) || start === null)
        return null;

      if (start instanceof Range)
        return start;

      if (_.isObject(start) && 'start' in start && 'end' in start) {
        len = start.end - start.start;
        start = start.start;
      }

      return new Range(start, len);
    },

    /**
     * <code>Range</code> object factory, the same as <code>this.create()</code>
     * but last argument represents end of range, not length
     * @returns {Range}
     */
    create2: function(start, end) {
      if (_.isNumber(start) && _.isNumber(end)) {
        end -= start;
      }

      return this.create(start, end);
    }
  };
});/**
 * Utility module that provides ordered storage of function handlers.
 * Many Emmet modules' functionality can be extended/overridden by custom
 * function. This modules provides unified storage of handler functions, their
 * management and execution
 *
 * @constructor
 * @memberOf __handlerListDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('handlerList', function(require, _) {
  /**
   * @type HandlerList
   * @constructor
   */
  function HandlerList() {
    this._list = [];
  }

  HandlerList.prototype = {
    /**
     * Adds function handler
     * @param {Function} fn Handler
     * @param {Object} options Handler options. Possible values are:<br><br>
     * <b>order</b> : (<code>Number</code>) â€“ order in handler list. Handlers
     * with higher order value will be executed earlier.
     */
    add: function(fn, options) {
      this._list.push(_.extend({order: 0}, options || {}, {fn: fn}));
    },

    /**
     * Removes handler from list
     * @param {Function} fn
     */
    remove: function(fn) {
      this._list = _.without(this._list, _.find(this._list, function(item) {
        return item.fn === fn;
      }));
    },

    /**
     * Returns ordered list of handlers. By default, handlers
     * with the same <code>order</code> option returned in reverse order,
     * i.e. the latter function was added into the handlers list, the higher
     * it will be in the returned array
     * @returns {Array}
     */
    list: function() {
      return _.sortBy(this._list, 'order').reverse();
    },

    /**
     * Returns ordered list of handler functions
     * @returns {Array}
     */
    listFn: function() {
      return _.pluck(this.list(), 'fn');
    },

    /**
     * Executes handler functions in their designated order. If function
     * returns <code>skipVal</code>, meaning that function was unable to
     * handle passed <code>args</code>, the next function will be executed
     * and so on.
     * @param {Object} skipValue If function returns this value, execute
     * next handler.
     * @param {Array} args Arguments to pass to handler function
     * @returns {Boolean} Whether any of registered handlers performed
     * successfully
     */
    exec: function(skipValue, args) {
      args = args || [];
      var result = null;
      _.find(this.list(), function(h) {
        result = h.fn.apply(h, args);
        if (result !== skipValue)
          return true;
      });

      return result;
    }
  };

  return {
    /**
     * Factory method that produces <code>HandlerList</code> instance
     * @returns {HandlerList}
     * @memberOf handlerList
     */
    create: function() {
      return new HandlerList();
    }
  };
});/**
 * Helper class for convenient token iteration
 */
emmet.define('tokenIterator', function(require, _) {
  /**
   * @type TokenIterator
   * @param {Array} tokens
   * @type TokenIterator
   * @constructor
   */
  function TokenIterator(tokens) {
    /** @type Array */
    this.tokens = tokens;
    this._position = 0;
    this.reset();
  }

  TokenIterator.prototype = {
    next: function() {
      if (this.hasNext()) {
        var token = this.tokens[++this._i];
        this._position = token.start;
        return token;
      }

      return null;
    },

    current: function() {
      return this.tokens[this._i];
    },

    position: function() {
      return this._position;
    },

    hasNext: function() {
      return this._i < this._il - 1;
    },

    reset: function() {
      this._i = -1;
      this._il = this.tokens.length;
    },

    item: function() {
      return this.tokens[this._i];
    },

    itemNext: function() {
      return this.tokens[this._i + 1];
    },

    itemPrev: function() {
      return this.tokens[this._i - 1];
    },

    nextUntil: function(type, callback) {
      var token;
      var test = _.isString(type)
        ? function(t){return t.type == type;}
        : type;

      while (token = this.next()) {
        if (callback)
          callback.call(this, token);
        if (test.call(this, token))
          break;
      }
    }
  };

  return {
    create: function(tokens) {
      return new TokenIterator(tokens);
    }
  };
});/**
 * A trimmed version of CodeMirror's StringStream module for string parsing
 */
emmet.define('stringStream', function(require, _) {
  /**
   * @type StringStream
   * @constructor
   * @param {String} string
   */
  function StringStream(string) {
    this.pos = this.start = 0;
    this.string = string;
  }

  StringStream.prototype = {
    /**
     * Returns true only if the stream is at the end of the line.
     * @returns {Boolean}
     */
    eol: function() {
      return this.pos >= this.string.length;
    },

    /**
     * Returns true only if the stream is at the start of the line
     * @returns {Boolean}
     */
    sol: function() {
      return this.pos == 0;
    },

    /**
     * Returns the next character in the stream without advancing it.
     * Will return <code>undefined</code> at the end of the line.
     * @returns {String}
     */
    peek: function() {
      return this.string.charAt(this.pos);
    },

    /**
     * Returns the next character in the stream and advances it.
     * Also returns <code>undefined</code> when no more characters are available.
     * @returns {String}
     */
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },

    /**
     * match can be a character, a regular expression, or a function that
     * takes a character and returns a boolean. If the next character in the
     * stream 'matches' the given argument, it is consumed and returned.
     * Otherwise, undefined is returned.
     * @param {Object} match
     * @returns {String}
     */
    eat: function(match) {
      var ch = this.string.charAt(this.pos), ok;
      if (typeof match == "string")
        ok = ch == match;
      else
        ok = ch && (match.test ? match.test(ch) : match(ch));

      if (ok) {
        ++this.pos;
        return ch;
      }
    },

    /**
     * Repeatedly calls <code>eat</code> with the given argument, until it
     * fails. Returns <code>true</code> if any characters were eaten.
     * @param {Object} match
     * @returns {Boolean}
     */
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)) {}
      return this.pos > start;
    },

    /**
     * Shortcut for <code>eatWhile</code> when matching white-space.
     * @returns {Boolean}
     */
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
        ++this.pos;
      return this.pos > start;
    },

    /**
     * Moves the position to the end of the line.
     */
    skipToEnd: function() {
      this.pos = this.string.length;
    },

    /**
     * Skips to the next occurrence of the given character, if found on the
     * current line (doesn't advance the stream if the character does not
     * occur on the line). Returns true if the character was found.
     * @param {String} ch
     * @returns {Boolean}
     */
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    },

    /**
     * Skips to <code>close</code> character which is pair to <code>open</code>
     * character, considering possible pair nesting. This function is used
     * to consume pair of characters, like opening and closing braces
     * @param {String} open
     * @param {String} close
     * @returns {Boolean} Returns <code>true</code> if pair was successfully
     * consumed
     */
    skipToPair: function(open, close) {
      var braceCount = 0, ch;
      var pos = this.pos, len = this.string.length;
      while (pos < len) {
        ch = this.string.charAt(pos++);
        if (ch == open) {
          braceCount++;
        } else if (ch == close) {
          braceCount--;
          if (braceCount < 1) {
            this.pos = pos;
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Backs up the stream n characters. Backing it up further than the
     * start of the current token will cause things to break, so be careful.
     * @param {Number} n
     */
    backUp : function(n) {
      this.pos -= n;
    },

    /**
     * Act like a multi-character <code>eat</code>â€”if <code>consume</code> is true or
     * not givenâ€”or a look-ahead that doesn't update the stream positionâ€”if
     * it is false. <code>pattern</code> can be either a string or a
     * regular expression starting with ^. When it is a string,
     * <code>caseInsensitive</code> can be set to true to make the match
     * case-insensitive. When successfully matching a regular expression,
     * the returned value will be the array returned by <code>match</code>,
     * in case you need to extract matched groups.
     *
     * @param {RegExp} pattern
     * @param {Boolean} consume
     * @param {Boolean} caseInsensitive
     * @returns
     */
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = caseInsensitive
          ? function(str) {return str.toLowerCase();}
          : function(str) {return str;};

        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {
          if (consume !== false)
            this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && consume !== false)
          this.pos += match[0].length;
        return match;
      }
    },

    /**
     * Get the string between the start of the current token and the
     * current stream position.
     * @returns {String}
     */
    current: function() {
      return this.string.slice(this.start, this.pos);
    }
  };

  return {
    create: function(string) {
      return new StringStream(string);
    }
  };
});/**
 * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.
 * Contains convenient method to get access for snippets with respect of
 * inheritance. Also provides ability to store data in different vocabularies
 * ('system' and 'user') for fast and safe resource update
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 *
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('resources', function(require, _) {
  var VOC_SYSTEM = 'system';
  var VOC_USER = 'user';

  var cache = {};

  /** Regular expression for XML tag matching */
  var reTag = /^<(\w+\:?[\w\-]*)((?:\s+[\w\:\-]+\s*=\s*(['"]).*?\3)*)\s*(\/?)>/;

  var systemSettings = {};
  var userSettings = {};

  /** @type HandlerList List of registered abbreviation resolvers */
  var resolvers = require('handlerList').create();

  /**
   * Normalizes caret plceholder in passed text: replaces | character with
   * default caret placeholder
   * @param {String} text
   * @returns {String}
   */
  function normalizeCaretPlaceholder(text) {
    var utils = require('utils');
    return utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());
  }

  function parseItem(name, value, type) {
    value = normalizeCaretPlaceholder(value);

    if (type == 'snippets') {
      return require('elements').create('snippet', value);
    }

    if (type == 'abbreviations') {
      return parseAbbreviation(name, value);
    }
  }

  /**
   * Parses single abbreviation
   * @param {String} key Abbreviation name
   * @param {String} value Abbreviation value
   * @return {Object}
   */
  function parseAbbreviation(key, value) {
    key = require('utils').trim(key);
    var elements = require('elements');
    var m;
    if (m = reTag.exec(value)) {
      return elements.create('element', m[1], m[2], m[4] == '/');
    } else {
      // assume it's reference to another abbreviation
      return elements.create('reference', value);
    }
  }

  /**
   * Normalizes snippet key name for better fuzzy search
   * @param {String} str
   * @returns {String}
   */
  function normalizeName(str) {
    return str.replace(/:$/, '').replace(/:/g, '-');
  }

  return {
    /**
     * Sets new unparsed data for specified settings vocabulary
     * @param {Object} data
     * @param {String} type Vocabulary type ('system' or 'user')
     * @memberOf resources
     */
    setVocabulary: function(data, type) {
      cache = {};
      if (type == VOC_SYSTEM)
        systemSettings = data;
      else
        userSettings = data;
    },

    /**
     * Returns resource vocabulary by its name
     * @param {String} name Vocabulary name ('system' or 'user')
     * @return {Object}
     */
    getVocabulary: function(name) {
      return name == VOC_SYSTEM ? systemSettings : userSettings;
    },

    /**
     * Returns resource (abbreviation, snippet, etc.) matched for passed
     * abbreviation
     * @param {TreeNode} node
     * @param {String} syntax
     * @returns {Object}
     */
    getMatchedResource: function(node, syntax) {
      return resolvers.exec(null, _.toArray(arguments))
        || this.findSnippet(syntax, node.name());
    },

    /**
     * Returns variable value
     * @return {String}
     */
    getVariable: function(name) {
      return (this.getSection('variables') || {})[name];
    },

    /**
     * Store runtime variable in user storage
     * @param {String} name Variable name
     * @param {String} value Variable value
     */
    setVariable: function(name, value){
      var voc = this.getVocabulary('user') || {};
      if (!('variables' in voc))
        voc.variables = {};

      voc.variables[name] = value;
      this.setVocabulary(voc, 'user');
    },

    /**
     * Check if there are resources for specified syntax
     * @param {String} syntax
     * @return {Boolean}
     */
    hasSyntax: function(syntax) {
      return syntax in this.getVocabulary(VOC_USER)
        || syntax in this.getVocabulary(VOC_SYSTEM);
    },

    /**
     * Registers new abbreviation resolver.
     * @param {Function} fn Abbreviation resolver which will receive
     * abbreviation as first argument and should return parsed abbreviation
     * object if abbreviation has handled successfully, <code>null</code>
     * otherwise
     * @param {Object} options Options list as described in
     * {@link HandlerList#add()} method
     */
    addResolver: function(fn, options) {
      resolvers.add(fn, options);
    },

    removeResolver: function(fn) {
      resolvers.remove(fn);
    },

    /**
     * Returns actual section data, merged from both
     * system and user data
     * @param {String} name Section name (syntax)
     * @param {String} ...args Subsections
     * @returns
     */
    getSection: function(name) {
      if (!name)
        return null;

      if (!(name in cache)) {
        cache[name] = require('utils').deepMerge({}, systemSettings[name], userSettings[name]);
      }

      var data = cache[name], subsections = _.rest(arguments), key;
      while (data && (key = subsections.shift())) {
        if (key in data) {
          data = data[key];
        } else {
          return null;
        }
      }

      return data;
    },

    /**
     * Recursively searches for a item inside top level sections (syntaxes)
     * with respect of `extends` attribute
     * @param {String} topSection Top section name (syntax)
     * @param {String} subsection Inner section name
     * @returns {Object}
     */
    findItem: function(topSection, subsection) {
      var data = this.getSection(topSection);
      while (data) {
        if (subsection in data)
          return data[subsection];

        data = this.getSection(data['extends']);
      }
    },

    /**
     * Recursively searches for a snippet definition inside syntax section.
     * Definition is searched inside `snippets` and `abbreviations`
     * subsections
     * @param {String} syntax Top-level section name (syntax)
     * @param {String} name Snippet name
     * @returns {Object}
     */
    findSnippet: function(syntax, name, memo) {
      if (!syntax || !name)
        return null;

      memo = memo || [];

      var names = [name];
      // create automatic aliases to properties with colons,
      // e.g. pos-a == pos:a
      if (~name.indexOf('-'))
        names.push(name.replace(/\-/g, ':'));

      var data = this.getSection(syntax), matchedItem = null;
      _.find(['snippets', 'abbreviations'], function(sectionName) {
        var data = this.getSection(syntax, sectionName);
        if (data) {
          return _.find(names, function(n) {
            if (data[n])
              return matchedItem = parseItem(n, data[n], sectionName);
          });
        }
      }, this);

      memo.push(syntax);
      if (!matchedItem && data['extends'] && !_.include(memo, data['extends'])) {
        // try to find item in parent syntax section
        return this.findSnippet(data['extends'], name, memo);
      }

      return matchedItem;
    },

    /**
     * Performs fuzzy search of snippet definition
     * @param {String} syntax Top-level section name (syntax)
     * @param {String} name Snippet name
     * @returns
     */
    fuzzyFindSnippet: function(syntax, name, minScore) {
      minScore = minScore || 0.3;

      var payload = this.getAllSnippets(syntax);
      var sc = require('string-score');

      name = normalizeName(name);
      var scores = _.map(payload, function(value, key) {
        return {
          key: key,
          score: sc.score(value.nk, name, 0.1)
        };
      });

      var result = _.last(_.sortBy(scores, 'score'));
      if (result && result.score >= minScore) {
        var k = result.key;
        return payload[k].parsedValue;
//        return parseItem(k, payload[k].value, payload[k].type);
      }
    },

    /**
     * Returns plain dictionary of all available abbreviations and snippets
     * for specified syntax with respect of inheritance
     * @param {String} syntax
     * @returns {Object}
     */
    getAllSnippets: function(syntax) {
      var cacheKey = 'all-' + syntax;
      if (!cache[cacheKey]) {
        var stack = [], sectionKey = syntax;
        var memo = [];

        do {
          var section = this.getSection(sectionKey);
          if (!section)
            break;

          _.each(['snippets', 'abbreviations'], function(sectionName) {
            var stackItem = {};
            _.each(section[sectionName] || null, function(v, k) {
              stackItem[k] = {
                nk: normalizeName(k),
                value: v,
                parsedValue: parseItem(k, v, sectionName),
                type: sectionName
              };
            });

            stack.push(stackItem);
          });

          memo.push(sectionKey);
          sectionKey = section['extends'];
        } while (sectionKey && !_.include(memo, sectionKey));


        cache[cacheKey] = _.extend.apply(_, stack.reverse());
      }

      return cache[cacheKey];
    }
  };
});/**
 * Module describes and performs Emmet actions. The actions themselves are
 * defined in <i>actions</i> folder
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('actions', function(require, _, zc) {
  var actions = {};

  /**
   * â€œHumanizesâ€ action name, makes it more readable for people
   * @param {String} name Action name (like 'expand_abbreviation')
   * @return Humanized name (like 'Expand Abbreviation')
   */
  function humanizeActionName(name) {
    return require('utils').trim(name.charAt(0).toUpperCase()
      + name.substring(1).replace(/_[a-z]/g, function(str) {
        return ' ' + str.charAt(1).toUpperCase();
      }));
  }

  return {
    /**
     * Registers new action
     * @param {String} name Action name
     * @param {Function} fn Action function
     * @param {Object} options Custom action options:<br>
     * <b>label</b> : (<code>String</code>) â€“ Human-readable action name.
     * May contain '/' symbols as submenu separators<br>
     * <b>hidden</b> : (<code>Boolean</code>) â€“ Indicates whether action
     * should be displayed in menu (<code>getMenu()</code> method)
     *
     * @memberOf actions
     */
    add: function(name, fn, options) {
      name = name.toLowerCase();
      options = options || {};
      if (!options.label) {
        options.label = humanizeActionName(name);
      }

      actions[name] = {
        name: name,
        fn: fn,
        options: options
      };
    },

    /**
     * Returns action object
     * @param {String} name Action name
     * @returns {Object}
     */
    get: function(name) {
      return actions[name.toLowerCase()];
    },

    /**
     * Runs Emmet action. For list of available actions and their
     * arguments see <i>actions</i> folder.
     * @param {String} name Action name
     * @param {Array} args Additional arguments. It may be array of arguments
     * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance
     * @returns {Boolean} Status of performed operation, <code>true</code>
     * means action was performed successfully.
     * @example
     * emmet.require('actions').run('expand_abbreviation', editor);
     * emmet.require('actions').run('wrap_with_abbreviation', [editor, 'div']);
     */
    run: function(name, args) {
      if (!_.isArray(args)) {
        args = _.rest(arguments);
      }

      var action = this.get(name);
      if (action) {
        return action.fn.apply(emmet, args);
      } else {
        emmet.log('Action "%s" is not defined', name);
        return false;
      }
    },

    /**
     * Returns all registered actions as object
     * @returns {Object}
     */
    getAll: function() {
      return actions;
    },

    /**
     * Returns all registered actions as array
     * @returns {Array}
     */
    getList: function() {
      return _.values(this.getAll());
    },

    /**
     * Returns actions list as structured menu. If action has <i>label</i>,
     * it will be splitted by '/' symbol into submenus (for example:
     * CSS/Reflect Value) and grouped with other items
     * @param {Array} skipActions List of action identifiers that should be
     * skipped from menu
     * @returns {Array}
     */
    getMenu: function(skipActions) {
      var result = [];
      skipActions = skipActions || [];
      _.each(this.getList(), function(action) {
        if (action.options.hidden || _.include(skipActions, action.name))
          return;

        var actionName = humanizeActionName(action.name);
        var ctx = result;
        if (action.options.label) {
          var parts = action.options.label.split('/');
          actionName = parts.pop();

          // create submenus, if needed
          var menuName, submenu;
          while (menuName = parts.shift()) {
            submenu = _.find(ctx, function(item) {
              return item.type == 'submenu' && item.name == menuName;
            });

            if (!submenu) {
              submenu = {
                name: menuName,
                type: 'submenu',
                items: []
              };
              ctx.push(submenu);
            }

            ctx = submenu.items;
          }
        }

        ctx.push({
          type: 'action',
          name: action.name,
          label: actionName
        });
      });

      return result;
    },

    /**
     * Returns action name associated with menu item title
     * @param {String} title
     * @returns {String}
     */
    getActionNameForMenuTitle: function(title, menu) {
      var item = null;
      _.find(menu || this.getMenu(), function(val) {
        if (val.type == 'action') {
          if (val.label == title || val.name == title) {
            return item = val.name;
          }
        } else {
          return item = this.getActionNameForMenuTitle(title, val.items);
        }
      }, this);

      return item || null;
    }
  };
});/**
 * Output profile module.
 * Profile defines how XHTML output data should look like
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('profile', function(require, _) {
  var profiles = {};

  var defaultProfile = {
    tag_case: 'asis',
    attr_case: 'asis',
    attr_quotes: 'double',

    // each tag on new line
    tag_nl: 'decide',

    // with tag_nl === true, defines if leaf node (e.g. node with no children)
    // should have formatted line breaks
    tag_nl_leaf: false,

    place_cursor: true,

    // indent tags
    indent: true,

    // how many inline elements should be to force line break
    // (set to 0 to disable)
    inline_break: 3,

    // use self-closing style for writing empty elements, e.g. <br /> or <br>
    self_closing_tag: 'xhtml',

    // Profile-level output filters, re-defines syntax filters
    filters: '',

    // Additional filters applied to abbreviation.
    // Unlike "filters", this preference doesn't override default filters
    // but add the instead every time given profile is chosen
    extraFilters: ''
  };

  /**
   * @constructor
   * @type OutputProfile
   * @param {Object} options
   */
  function OutputProfile(options) {
    _.extend(this, defaultProfile, options);
  }

  OutputProfile.prototype = {
    /**
     * Transforms tag name case depending on current profile settings
     * @param {String} name String to transform
     * @returns {String}
     */
    tagName: function(name) {
      return stringCase(name, this.tag_case);
    },

    /**
     * Transforms attribute name case depending on current profile settings
     * @param {String} name String to transform
     * @returns {String}
     */
    attributeName: function(name) {
      return stringCase(name, this.attr_case);
    },

    /**
     * Returns quote character for current profile
     * @returns {String}
     */
    attributeQuote: function() {
      return this.attr_quotes == 'single' ? "'" : '"';
    },

    /**
     * Returns self-closing tag symbol for current profile
     * @param {String} param
     * @returns {String}
     */
    selfClosing: function(param) {
      if (this.self_closing_tag == 'xhtml')
        return ' /';

      if (this.self_closing_tag === true)
        return '/';

      return '';
    },

    /**
     * Returns cursor token based on current profile settings
     * @returns {String}
     */
    cursor: function() {
      return this.place_cursor ? require('utils').getCaretPlaceholder() : '';
    }
  };

  /**
   * Helper function that converts string case depending on
   * <code>caseValue</code>
   * @param {String} str String to transform
   * @param {String} caseValue Case value: can be <i>lower</i>,
   * <i>upper</i> and <i>leave</i>
   * @returns {String}
   */
  function stringCase(str, caseValue) {
    switch (String(caseValue || '').toLowerCase()) {
      case 'lower':
        return str.toLowerCase();
      case 'upper':
        return str.toUpperCase();
    }

    return str;
  }

  /**
   * Creates new output profile
   * @param {String} name Profile name
   * @param {Object} options Profile options
   */
  function createProfile(name, options) {
    return profiles[name.toLowerCase()] = new OutputProfile(options);
  }

  function createDefaultProfiles() {
    createProfile('xhtml');
    createProfile('html', {self_closing_tag: false});
    createProfile('xml', {self_closing_tag: true, tag_nl: true});
    createProfile('plain', {tag_nl: false, indent: false, place_cursor: false});
    createProfile('line', {tag_nl: false, indent: false, extraFilters: 's'});
  }

  createDefaultProfiles();

  return  {
    /**
     * Creates new output profile and adds it into internal dictionary
     * @param {String} name Profile name
     * @param {Object} options Profile options
     * @memberOf emmet.profile
     * @returns {Object} New profile
     */
    create: function(name, options) {
      if (arguments.length == 2)
        return createProfile(name, options);
      else
        // create profile object only
        return new OutputProfile(_.defaults(name || {}, defaultProfile));
    },

    /**
     * Returns profile by its name. If profile wasn't found, returns
     * 'plain' profile
     * @param {String} name Profile name. Might be profile itself
     * @param {String} syntax. Optional. Current editor syntax. If defined,
     * profile is searched in resources first, then in predefined profiles
     * @returns {Object}
     */
    get: function(name, syntax) {
      if (!name && syntax) {
        // search in user resources first
        var profile = require('resources').findItem(syntax, 'profile');
        if (profile) {
          name = profile;
        }
      }

      if (!name) {
        return profiles.plain;
      }

      if (name instanceof OutputProfile) {
        return name;
      }

      if (_.isString(name) && name.toLowerCase() in profiles) {
        return profiles[name.toLowerCase()];
      }

      return this.create(name);
    },

    /**
     * Deletes profile with specified name
     * @param {String} name Profile name
     */
    remove: function(name) {
      name = (name || '').toLowerCase();
      if (name in profiles)
        delete profiles[name];
    },

    /**
     * Resets all user-defined profiles
     */
    reset: function() {
      profiles = {};
      createDefaultProfiles();
    },

    /**
     * Helper function that converts string case depending on
     * <code>caseValue</code>
     * @param {String} str String to transform
     * @param {String} caseValue Case value: can be <i>lower</i>,
     * <i>upper</i> and <i>leave</i>
     * @returns {String}
     */
    stringCase: stringCase
  };
});/**
 * Utility module used to prepare text for pasting into back-end editor
 * @param {Function} require
 * @param {Underscore} _
 * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>
 */
emmet.define('editorUtils', function(require, _) {
  return  {
    /**
     * Check if cursor is placed inside XHTML tag
     * @param {String} html Contents of the document
     * @param {Number} caretPos Current caret position inside tag
     * @return {Boolean}
     */
    isInsideTag: function(html, caretPos) {
      var reTag = /^<\/?\w[\w\:\-]*.*?>/;

      // search left to find opening brace
      var pos = caretPos;
      while (pos > -1) {
        if (html.charAt(pos) == '<')
          break;
        pos--;
      }

      if (pos != -1) {
        var m = reTag.exec(html.substring(pos));
        if (m && caretPos > pos && caretPos < pos + m[0].length)
          return true;
      }

      return false;
    },

    /**
     * Sanitizes incoming editor data and provides default values for
     * output-specific info
     * @param {IEmmetEditor} editor
     * @param {String} syntax
     * @param {String} profile
     */
    outputInfo: function(editor, syntax, profile) {
      // most of this code makes sense for Java/Rhino environment
      // because string that comes from Java are not actually JS string
      // but Java String object so the have to be explicitly converted
      // to native string
      profile = profile || editor.getProfileName();
      return  {
        /** @memberOf outputInfo */
        syntax: String(syntax || editor.getSyntax()),
        profile: profile ? String(profile) : null,
        content: String(editor.getContent())
      };
    },

    /**
     * Unindent content, thus preparing text for tag wrapping
     * @param {IEmmetEditor} editor Editor instance
     * @param {String} text
     * @return {String}
     */
    unindent: function(editor, text) {
      return require('utils').unindentString(text, this.getCurrentLinePadding(editor));
    },

    /**
     * Returns padding of current editor's line
     * @param {IEmmetEditor} Editor instance
     * @return {String}
     */
    getCurrentLinePadding: function(editor) {
      return require('utils').getLinePadding(editor.getCurrentLine());
    }
  };
});
/**
 * Utility methods for Emmet actions
 * @param {Function} require
 * @param {Underscore} _
 * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>
 */
emmet.define('actionUtils', function(require, _) {
  return {
    mimeTypes: {
      'gif' : 'image/gif',
      'png' : 'image/png',
      'jpg' : 'image/jpeg',
      'jpeg': 'image/jpeg',
      'svg' : 'image/svg+xml',
      'html': 'text/html',
      'htm' : 'text/html'
    },

    /**
     * Extracts abbreviations from text stream, starting from the end
     * @param {String} str
     * @return {String} Abbreviation or empty string
     * @memberOf emmet.actionUtils
     */
    extractAbbreviation: function(str) {
      var curOffset = str.length;
      var startIndex = -1;
      var groupCount = 0;
      var braceCount = 0;
      var textCount = 0;

      var utils = require('utils');
      var parser = require('abbreviationParser');

      while (true) {
        curOffset--;
        if (curOffset < 0) {
          // moved to the beginning of the line
          startIndex = 0;
          break;
        }

        var ch = str.charAt(curOffset);

        if (ch == ']') {
          braceCount++;
        } else if (ch == '[') {
          if (!braceCount) { // unexpected brace
            startIndex = curOffset + 1;
            break;
          }
          braceCount--;
        } else if (ch == '}') {
          textCount++;
        } else if (ch == '{') {
          if (!textCount) { // unexpected brace
            startIndex = curOffset + 1;
            break;
          }
          textCount--;
        } else if (ch == ')') {
          groupCount++;
        } else if (ch == '(') {
          if (!groupCount) { // unexpected brace
            startIndex = curOffset + 1;
            break;
          }
          groupCount--;
        } else {
          if (braceCount || textCount)
            // respect all characters inside attribute sets or text nodes
            continue;
          else if (!parser.isAllowedChar(ch) || (ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1)))) {
            // found stop symbol
            startIndex = curOffset + 1;
            break;
          }
        }
      }

      if (startIndex != -1 && !textCount && !braceCount && !groupCount)
        // found something, remove some invalid symbols from the
        // beginning and return abbreviation
        return str.substring(startIndex).replace(/^[\*\+\>\^]+/, '');
      else
        return '';
    },

    /**
     * Gets image size from image byte stream.
     * @author http://romeda.org/rePublish/
     * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)
     * @return {Object} Object with <code>width</code> and <code>height</code> properties
     */
    getImageSize: function(stream) {
      var pngMagicNum = "\211PNG\r\n\032\n",
        jpgMagicNum = "\377\330",
        gifMagicNum = "GIF8",
        nextByte = function() {
          return stream.charCodeAt(pos++);
        };

      if (stream.substr(0, 8) === pngMagicNum) {
        // PNG. Easy peasy.
        var pos = stream.indexOf('IHDR') + 4;

        return { width:  (nextByte() << 24) | (nextByte() << 16) |
                 (nextByte() <<  8) | nextByte(),
             height: (nextByte() << 24) | (nextByte() << 16) |
                 (nextByte() <<  8) | nextByte() };

      } else if (stream.substr(0, 4) === gifMagicNum) {
        pos = 6;

        return {
          width:  nextByte() | (nextByte() << 8),
          height: nextByte() | (nextByte() << 8)
        };

      } else if (stream.substr(0, 2) === jpgMagicNum) {
        pos = 2;

        var l = stream.length;
        while (pos < l) {
          if (nextByte() != 0xFF) return;

          var marker = nextByte();
          if (marker == 0xDA) break;

          var size = (nextByte() << 8) | nextByte();

          if (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {
            pos += 1;
            return { height:  (nextByte() << 8) | nextByte(),
                 width: (nextByte() << 8) | nextByte() };

          } else {
            pos += size - 2;
          }
        }
      }
    },

    /**
     * Captures context XHTML element from editor under current caret position.
     * This node can be used as a helper for abbreviation extraction
     * @param {IEmmetEditor} editor
     * @returns {Object}
     */
    captureContext: function(editor) {
      var allowedSyntaxes = {'html': 1, 'xml': 1, 'xsl': 1};
      var syntax = String(editor.getSyntax());
      if (syntax in allowedSyntaxes) {
        var content = String(editor.getContent());
        var tag = require('htmlMatcher').find(content, editor.getCaretPos());

        if (tag && tag.type == 'tag') {
          var reAttr = /([\w\-:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;
          var startTag = tag.open;
          var tagAttrs = startTag.range.substring(content).replace(/^<[\w\-\:]+/, '');
//          var tagAttrs = startTag.full_tag.replace(/^<[\w\-\:]+/, '');
          var contextNode = {
            name: startTag.name,
            attributes: []
          };

          // parse attributes
          var m;
          while (m = reAttr.exec(tagAttrs)) {
            contextNode.attributes.push({
              name: m[1],
              value: m[2]
            });
          }

          return contextNode;
        }
      }

      return null;
    },

    /**
     * Find expression bounds in current editor at caret position.
     * On each character a <code>fn</code> function will be called and must
     * return <code>true</code> if current character meets requirements,
     * <code>false</code> otherwise
     * @param {IEmmetEditor} editor
     * @param {Function} fn Function to test each character of expression
     * @return {Range}
     */
    findExpressionBounds: function(editor, fn) {
      var content = String(editor.getContent());
      var il = content.length;
      var exprStart = editor.getCaretPos() - 1;
      var exprEnd = exprStart + 1;

      // start by searching left
      while (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;

      // then search right
      while (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;

      if (exprEnd > exprStart) {
        return require('range').create([++exprStart, exprEnd]);
      }
    },

    /**
     * @param {IEmmetEditor} editor
     * @param {Object} data
     * @returns {Boolean}
     */
    compoundUpdate: function(editor, data) {
      if (data) {
        var sel = editor.getSelectionRange();
        editor.replaceContent(data.data, data.start, data.end, true);
        editor.createSelection(data.caret, data.caret + sel.end - sel.start);
        return true;
      }

      return false;
    },

    /**
     * Common syntax detection method for editors that doesnâ€™t provide any
     * info about current syntax scope.
     * @param {IEmmetEditor} editor Current editor
     * @param {String} hint Any syntax hint that editor can provide
     * for syntax detection. Default is 'html'
     * @returns {String}
     */
    detectSyntax: function(editor, hint) {
      var syntax = hint || 'html';

      if (!require('resources').hasSyntax(syntax)) {
        syntax = 'html';
      }

      if (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {
        syntax = 'css';
      }

      return syntax;
    },

    /**
     * Common method for detecting output profile
     * @param {IEmmetEditor} editor
     * @returns {String}
     */
    detectProfile: function(editor) {
      var syntax = editor.getSyntax();

      // get profile from syntax definition
      var profile = require('resources').findItem(syntax, 'profile');
      if (profile) {
        return profile;
      }

      switch(syntax) {
        case 'xml':
        case 'xsl':
          return 'xml';
        case 'css':
          if (this.isInlineCSS(editor)) {
            return 'line';
          }
          break;
        case 'html':
          var profile = require('resources').getVariable('profile');
          if (!profile) { // no forced profile, guess from content
            // html or xhtml?
            profile = this.isXHTML(editor) ? 'xhtml': 'html';
          }

          return profile;
      }

      return 'xhtml';
    },

    /**
     * Tries to detect if current document is XHTML one.
     * @param {IEmmetEditor} editor
     * @returns {Boolean}
     */
    isXHTML: function(editor) {
      return editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;
    },

    /**
     * Check if current caret position is inside &lt;style&gt; tag
     * @param {IEmmetEditor} editor
     * @returns
     */
    isStyle: function(editor) {
      var content = String(editor.getContent());
      var caretPos = editor.getCaretPos();
      var tag = require('htmlMatcher').tag(content, caretPos);
      return tag && tag.open.name.toLowerCase() == 'style'
        && tag.innerRange.cmp(caretPos, 'lte', 'gte');
    },

    /**
     * Check if current caret position is inside "style" attribute of HTML
     * element
     * @param {IEmmetEditor} editor
     * @returns {Boolean}
     */
    isInlineCSS: function(editor) {
      var content = String(editor.getContent());
      var caretPos = editor.getCaretPos();
      var tree = require('xmlEditTree').parseFromPosition(content, caretPos, true);
            if (tree) {
                var attr = tree.itemFromPosition(caretPos, true);
                return attr && attr.name().toLowerCase() == 'style'
                  && attr.valueRange(true).cmp(caretPos, 'lte', 'gte');
            }

            return false;
    }
  };
});/**
 * Utility functions to work with <code>AbbreviationNode</code> as HTML element
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('abbreviationUtils', function(require, _) {
  return {
    /**
     * Check if passed abbreviation node has matched snippet resource
     * @param {AbbreviationNode} node
     * @returns {Boolean}
     * @memberOf abbreviationUtils
     */
    isSnippet: function(node) {
      return require('elements').is(node.matchedResource(), 'snippet');
    },

    /**
     * Test if passed node is unary (no closing tag)
     * @param {AbbreviationNode} node
     * @return {Boolean}
     */
    isUnary: function(node) {
      var r = node.matchedResource();
      if (node.children.length || this.isSnippet(node))
        return false;

      return r && r.is_empty || require('tagName').isEmptyElement(node.name());
    },

    /**
     * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)
     * @param {AbbreviationNode} node
     * @return {Boolean}
     */
    isInline: function(node) {
      return node.isTextNode()
        || !node.name()
        || require('tagName').isInlineLevel(node.name());
    },

    /**
     * Test if passed node is block-level
     * @param {AbbreviationNode} node
     * @return {Boolean}
     */
    isBlock: function(node) {
      return this.isSnippet(node) || !this.isInline(node);
    },

    /**
     * Test if given node is a snippet
     * @param {AbbreviationNode} node
     * @return {Boolean}
     */
    isSnippet: function(node) {
      return require('elements').is(node.matchedResource(), 'snippet');
    },

    /**
     * This function tests if passed node content contains HTML tags.
     * This function is mostly used for output formatting
     * @param {AbbreviationNode} node
     * @returns {Boolean}
     */
    hasTagsInContent: function(node) {
      return require('utils').matchesTag(node.content);
    },

    /**
     * Test if current element contains block-level children
     * @param {AbbreviationNode} node
     * @return {Boolean}
     */
    hasBlockChildren: function(node) {
      return (this.hasTagsInContent(node) && this.isBlock(node))
        || _.any(node.children, function(child) {
          return this.isBlock(child);
        }, this);
    },

    /**
     * Utility function that inserts content instead of <code>${child}</code>
     * variables on <code>text</code>
     * @param {String} text Text where child content should be inserted
     * @param {String} childContent Content to insert
     * @param {Object} options
     * @returns {String
     */
    insertChildContent: function(text, childContent, options) {
      options = _.extend({
        keepVariable: true,
        appendIfNoChild: true
      }, options || {});

      var childVariableReplaced = false;
      var utils = require('utils');
      text = utils.replaceVariables(text, function(variable, name, data) {
        var output = variable;
        if (name == 'child') {
          // add correct indentation
          output = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));
          childVariableReplaced = true;
          if (options.keepVariable)
            output += variable;
        }

        return output;
      });

      if (!childVariableReplaced && options.appendIfNoChild) {
        text += childContent;
      }

      return text;
    }
  };
});/**
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 */
emmet.define('base64', function(require, _) {
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  return {
    /**
     * Encodes data using base64 algorithm
     * @author Tyler Akins (http://rumkin.com)
     * @param {String} input
     * @returns {String}
     * @memberOf emmet.base64
     */
    encode : function(input) {
      var output = [];
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;
      var i = 0, il = input.length, b64 = chars;

      while (i < il) {

        cdp1 = input.charCodeAt(i++);
        cdp2 = input.charCodeAt(i++);
        cdp3 = input.charCodeAt(i++);

        chr1 = cdp1 & 0xff;
        chr2 = cdp2 & 0xff;
        chr3 = cdp3 & 0xff;

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(cdp2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(cdp3)) {
          enc4 = 64;
        }

        output.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));
      }

      return output.join('');
    },

    /**
     * Decodes string using MIME base64 algorithm
     *
     * @author Tyler Akins (http://rumkin.com)
     * @param {String} data
     * @return {String}
     */
    decode : function(data) {
      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmpArr = [];
      var b64 = chars, il = data.length;

      if (!data) {
        return data;
      }

      data += '';

      do { // unpack four hexets into three octets using index points in b64
        h1 = b64.indexOf(data.charAt(i++));
        h2 = b64.indexOf(data.charAt(i++));
        h3 = b64.indexOf(data.charAt(i++));
        h4 = b64.indexOf(data.charAt(i++));

        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

        o1 = bits >> 16 & 0xff;
        o2 = bits >> 8 & 0xff;
        o3 = bits & 0xff;

        if (h3 == 64) {
          tmpArr[ac++] = String.fromCharCode(o1);
        } else if (h4 == 64) {
          tmpArr[ac++] = String.fromCharCode(o1, o2);
        } else {
          tmpArr[ac++] = String.fromCharCode(o1, o2, o3);
        }
      } while (i < il);

      return tmpArr.join('');
    }
  };
});/**
 * HTML matcher: takes string and searches for HTML tag pairs for given position
 *
 * Unlike â€œclassicâ€ matchers, it parses content from the specified
 * position, not from the start, so it may work even outside HTML documents
 * (for example, inside strings of programming languages like JavaScript, Python
 * etc.)
 * @constructor
 * @memberOf __htmlMatcherDefine
 */
emmet.define('htmlMatcher', function(require, _) {
  // Regular Expressions for parsing tags and attributes
  var reOpenTag = /^<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/;
  var reCloseTag = /^<\/([\w\:\-]+)[^>]*>/;

  function openTag(i, match) {
    return {
      name: match[1],
      selfClose: !!match[3],
      /** @type Range */
      range: require('range').create(i, match[0]),
      type: 'open'
    };
  }

  function closeTag(i, match) {
    return {
      name: match[1],
      /** @type Range */
      range: require('range').create(i, match[0]),
      type: 'close'
    };
  }

  function comment(i, match) {
    return {
      /** @type Range */
      range: require('range').create(i, _.isNumber(match) ? match - i : match[0]),
      type: 'comment'
    };
  }

  /**
   * Creates new tag matcher session
   * @param {String} text
   */
  function createMatcher(text) {
    var memo = {}, m;
    return {
      /**
       * Test if given position matches opening tag
       * @param {Number} i
       * @returns {Object} Matched tag object
       */
      open: function(i) {
        var m = this.matches(i);
        return m && m.type == 'open' ? m : null;
      },

      /**
       * Test if given position matches closing tag
       * @param {Number} i
       * @returns {Object} Matched tag object
       */
      close: function(i) {
        var m = this.matches(i);
        return m && m.type == 'close' ? m : null;
      },

      /**
       * Matches either opening or closing tag for given position
       * @param i
       * @returns
       */
      matches: function(i) {
        var key = 'p' + i;

        if (!(key in memo)) {
          if (text.charAt(i) == '<') {
            var substr = text.slice(i);
            if (m = substr.match(reOpenTag)) {
              memo[key] = openTag(i, m);
            } else if (m = substr.match(reCloseTag)) {
              memo[key] = closeTag(i, m);
            } else {
              // remember that given position contains no valid tag
              memo[key] = false;
            }
          }
        }

        return memo[key];
      },

      /**
       * Returns original text
       * @returns {String}
       */
      text: function() {
        return text;
      }
    };
  }

  function matches(text, pos, pattern) {
    return text.substring(pos, pos + pattern.length) == pattern;
  }

  /**
   * Search for closing pair of opening tag
   * @param {Object} open Open tag instance
   * @param {Object} matcher Matcher instance
   */
  function findClosingPair(open, matcher) {
    var stack = [], tag = null;
    var text = matcher.text();

    for (var pos = open.range.end, len = text.length; pos < len; pos++) {
      if (matches(text, pos, '<!--')) {
        // skip to end of comment
        for (var j = pos; j < len; j++) {
          if (matches(text, j, '-->')) {
            pos = j + 3;
            break;
          }
        }
      }

      if (tag = matcher.matches(pos)) {
        if (tag.type == 'open' && !tag.selfClose) {
          stack.push(tag.name);
        } else if (tag.type == 'close') {
          if (!stack.length) { // found valid pair?
            return tag.name == open.name ? tag : null;
          }

          // check if current closing tag matches previously opened one
          if (_.last(stack) == tag.name) {
            stack.pop();
          } else {
            var found = false;
            while (stack.length && !found) {
              var last = stack.pop();
              if (last == tag.name) {
                found = true;
              }
            }

            if (!stack.length && !found) {
              return tag.name == open.name ? tag : null;
            }
          }
        }
      }

    }
  }

  return {
    /**
     * Main function: search for tag pair in <code>text</code> for given
     * position
     * @memberOf htmlMatcher
     * @param {String} text
     * @param {Number} pos
     * @returns {Object}
     */
    find: function(text, pos) {
      var range = require('range');
      var matcher = createMatcher(text);
      var open = null, close = null;

      for (var i = pos; i >= 0; i--) {
        if (open = matcher.open(i)) {
          // found opening tag
          if (open.selfClose) {
            if (open.range.cmp(pos, 'lt', 'gt')) {
              // inside self-closing tag, found match
              break;
            }

            // outside self-closing tag, continue
            continue;
          }

          close = findClosingPair(open, matcher);
          if (close) {
            // found closing tag.
            var r = range.create2(open.range.start, close.range.end);
            if (r.contains(pos)) {
              break;
            }
          } else if (open.range.contains(pos)) {
            // we inside empty HTML tag like <br>
            break;
          }

          open = null;
        } else if (matches(text, i, '-->')) {
          // skip back to comment start
          for (var j = i - 1; j >= 0; j--) {
            if (matches(text, j, '-->')) {
              // found another comment end, do nothing
              break;
            } else if (matches(text, j, '<!--')) {
              i = j;
              break;
            }
          }
        } else if (matches(text, i, '<!--')) {
          // we're inside comment, match it
          var j = i + 4, jl = text.length;
          for (; j < jl; j++) {
            if (matches(text, j, '-->')) {
              j += 3;
              break;
            }
          }

          open = comment(i, j);
          break;
        }
      }

      if (open) {
        var outerRange = null;
        var innerRange = null;

        if (close) {
          outerRange = range.create2(open.range.start, close.range.end);
          innerRange = range.create2(open.range.end, close.range.start);
        } else {
          outerRange = innerRange = range.create2(open.range.start, open.range.end);
        }

        if (open.type == 'comment') {
          // adjust positions of inner range for comment
          var _c = outerRange.substring(text);
          innerRange.start += _c.length - _c.replace(/^<\!--\s*/, '').length;
          innerRange.end -= _c.length - _c.replace(/\s*-->$/, '').length;
        }

        return {
          open: open,
          close: close,
          type: open.type == 'comment' ? 'comment' : 'tag',
          innerRange: innerRange,
          innerContent: function() {
            return this.innerRange.substring(text);
          },
          outerRange: outerRange,
          outerContent: function() {
            return this.outerRange.substring(text);
          },
          range: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,
          content: function() {
            return this.range.substring(text);
          },
          source: text
        };
      }
    },

    /**
     * The same as <code>find()</code> method, but restricts matched result
     * to <code>tag</code> type
     * @param {String} text
     * @param {Number} pos
     * @returns {Object}
     */
    tag: function(text, pos) {
      var result = this.find(text, pos);
      if (result && result.type == 'tag') {
        return result;
      }
    }
  };
});/**
 * Utility module for handling tabstops tokens generated by Emmet's
 * "Expand Abbreviation" action. The main <code>extract</code> method will take
 * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops
 * occurrences, replace them with tokens suitable for your editor of choice and
 * return object with processed text and list of found tabstops and their ranges.
 * For sake of portability (Objective-C/Java) the tabstops list is a plain
 * sorted array with plain objects.
 *
 * Placeholders with the same are meant to be <i>linked</i> in your editor.
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('tabStops', function(require, _) {
  /**
   * Global placeholder value, automatically incremented by
   * <code>variablesResolver()</code> function
   */
  var startPlaceholderNum = 100;

  var tabstopIndex = 0;

  var defaultOptions = {
    replaceCarets: false,
    escape: function(ch) {
      return '\\' + ch;
    },
    tabstop: function(data) {
      return data.token;
    },
    variable: function(data) {
      return data.token;
    }
  };

  // XXX register output processor that will upgrade tabstops of parsed node
  // in order to prevent tabstop index conflicts
  require('abbreviationParser').addOutputProcessor(function(text, node, type) {
    var maxNum = 0;
    var tabstops = require('tabStops');
    var utils = require('utils');

    var tsOptions = {
      tabstop: function(data) {
        var group = parseInt(data.group);
        if (group == 0)
          return '${0}';

        if (group > maxNum) maxNum = group;
        if (data.placeholder) {
          // respect nested placeholders
          var ix = group + tabstopIndex;
          var placeholder = tabstops.processText(data.placeholder, tsOptions);
          return '${' + ix + ':' + placeholder + '}';
        } else {
          return '${' + (group + tabstopIndex) + '}';
        }
      }
    };

    // upgrade tabstops
    text = tabstops.processText(text, tsOptions);

    // resolve variables
    text = utils.replaceVariables(text, tabstops.variablesResolver(node));

    tabstopIndex += maxNum + 1;
    return text;
  });

  return {
    /**
     * Main function that looks for a tabstops in provided <code>text</code>
     * and returns a processed version of <code>text</code> with expanded
     * placeholders and list of tabstops found.
     * @param {String} text Text to process
     * @param {Object} options List of processor options:<br>
     *
     * <b>replaceCarets</b> : <code>Boolean</code> â€” replace all default
     * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>
     *
     * <b>escape</b> : <code>Function</code> â€” function that handle escaped
     * characters (mostly '$'). By default, it returns the character itself
     * to be displayed as is in output, but sometimes you will use
     * <code>extract</code> method as intermediate solution for further
     * processing and want to keep character escaped. Thus, you should override
     * <code>escape</code> method to return escaped symbol (e.g. '\\$')<br>
     *
     * <b>tabstop</b> : <code>Function</code> â€“ a tabstop handler. Receives
     * a single argument â€“ an object describing token: its position, number
     * group, placeholder and token itself. Should return a replacement
     * string that will appear in final output
     *
     * <b>variable</b> : <code>Function</code> â€“ variable handler. Receives
     * a single argument â€“ an object describing token: its position, name
     * and original token itself. Should return a replacement
     * string that will appear in final output
     *
     * @returns {Object} Object with processed <code>text</code> property
     * and array of <code>tabstops</code> found
     * @memberOf tabStops
     */
    extract: function(text, options) {
      // prepare defaults
      var utils = require('utils');
      var placeholders = {carets: ''};
      var marks = [];

      options = _.extend({}, defaultOptions, options, {
        tabstop: function(data) {
          var token = data.token;
          var ret = '';
          if (data.placeholder == 'cursor') {
            marks.push({
              start: data.start,
              end: data.start + token.length,
              group: 'carets',
              value: ''
            });
          } else {
            // unify placeholder value for single group
            if ('placeholder' in data)
              placeholders[data.group] = data.placeholder;

            if (data.group in placeholders)
              ret = placeholders[data.group];

            marks.push({
              start: data.start,
              end: data.start + token.length,
              group: data.group,
              value: ret
            });
          }

          return token;
        }
      });

      if (options.replaceCarets) {
        text = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');
      }

      // locate tabstops and unify group's placeholders
      text = this.processText(text, options);

      // now, replace all tabstops with placeholders
      var buf = utils.stringBuilder(), lastIx = 0;
      var tabStops = _.map(marks, function(mark) {
        buf.append(text.substring(lastIx, mark.start));

        var pos = buf.length;
        var ph = placeholders[mark.group] || '';

        buf.append(ph);
        lastIx = mark.end;

        return {
          group: mark.group,
          start: pos,
          end:  pos + ph.length
        };
      });

      buf.append(text.substring(lastIx));

      return {
        text: buf.toString(),
        tabstops: _.sortBy(tabStops, 'start')
      };
    },

    /**
     * Text processing routine. Locates escaped characters and tabstops and
     * replaces them with values returned by handlers defined in
     * <code>options</code>
     * @param {String} text
     * @param {Object} options See <code>extract</code> method options
     * description
     * @returns {String}
     */
    processText: function(text, options) {
      options = _.extend({}, defaultOptions, options);

      var buf = require('utils').stringBuilder();
      /** @type StringStream */
      var stream = require('stringStream').create(text);
      var ch, m, a;

      while (ch = stream.next()) {
        if (ch == '\\' && !stream.eol()) {
          // handle escaped character
          buf.append(options.escape(stream.next()));
          continue;
        }

        a = ch;

        if (ch == '$') {
          // looks like a tabstop
          stream.start = stream.pos - 1;

          if (m = stream.match(/^[0-9]+/)) {
            // it's $N
            a = options.tabstop({
              start: buf.length,
              group: stream.current().substr(1),
              token: stream.current()
            });
          } else if (m = stream.match(/^\{([a-z_\-][\w\-]*)\}/)) {
            // ${variable}
            a = options.variable({
              start: buf.length,
              name: m[1],
              token: stream.current()
            });
          } else if (m = stream.match(/^\{([0-9]+)(:.+?)?\}/, false)) {
            // ${N:value} or ${N} placeholder
            // parse placeholder, including nested ones
            stream.skipToPair('{', '}');

            var obj = {
              start: buf.length,
              group: m[1],
              token: stream.current()
            };

            var placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);

            if (placeholder) {
              obj.placeholder = placeholder.substr(1);
            }

            a = options.tabstop(obj);
          }
        }

        buf.append(a);
      }

      return buf.toString();
    },

    /**
     * Upgrades tabstops in output node in order to prevent naming conflicts
     * @param {AbbreviationNode} node
     * @param {Number} offset Tab index offset
     * @returns {Number} Maximum tabstop index in element
     */
    upgrade: function(node, offset) {
      var maxNum = 0;
      var options = {
        tabstop: function(data) {
          var group = parseInt(data.group);
          if (group > maxNum) maxNum = group;

          if (data.placeholder)
            return '${' + (group + offset) + ':' + data.placeholder + '}';
          else
            return '${' + (group + offset) + '}';
        }
      };

      _.each(['start', 'end', 'content'], function(p) {
        node[p] = this.processText(node[p], options);
      }, this);

      return maxNum;
    },

    /**
     * Helper function that produces a callback function for
     * <code>replaceVariables()</code> method from {@link utils}
     * module. This callback will replace variable definitions (like
     * ${var_name}) with their value defined in <i>resource</i> module,
     * or outputs tabstop with variable name otherwise.
     * @param {AbbreviationNode} node Context node
     * @returns {Function}
     */
    variablesResolver: function(node) {
      var placeholderMemo = {};
      var res = require('resources');
      return function(str, varName) {
        // do not mark `child` variable as placeholder â€“ itâ€˜s a reserved
        // variable name
        if (varName == 'child')
          return str;

        if (varName == 'cursor')
          return require('utils').getCaretPlaceholder();

        var attr = node.attribute(varName);
        if (!_.isUndefined(attr) && attr !== str) {
          return attr;
        }

        var varValue = res.getVariable(varName);
        if (varValue)
          return varValue;

        // output as placeholder
        if (!placeholderMemo[varName])
          placeholderMemo[varName] = startPlaceholderNum++;

        return '${' + placeholderMemo[varName] + ':' + varName + '}';
      };
    },

    /**
     * Resets global tabstop index. When parsed tree is converted to output
     * string (<code>AbbreviationNode.toString()</code>), all tabstops
     * defined in snippets and elements are upgraded in order to prevent
     * naming conflicts of nested. For example, <code>${1}</code> of a node
     * should not be linked with the same placehilder of the child node.
     * By default, <code>AbbreviationNode.toString()</code> automatically
     * upgrades tabstops of the same index for each node and writes maximum
     * tabstop index into the <code>tabstopIndex</code> variable. To keep
     * this variable at reasonable value, it is recommended to call
     * <code>resetTabstopIndex()</code> method each time you expand variable
     * @returns
     */
    resetTabstopIndex: function() {
      tabstopIndex = 0;
      startPlaceholderNum = 100;
    }
  };
});/**
 * Common module's preferences storage. This module
 * provides general storage for all module preferences, their description and
 * default values.<br><br>
 *
 * This module can also be used to list all available properties to create
 * UI for updating properties
 *
 * @memberOf __preferencesDefine
 * @constructor
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('preferences', function(require, _) {
  var preferences = {};
  var defaults = {};
  var _dbgDefaults = null;
  var _dbgPreferences = null;

  function toBoolean(val) {
    if (_.isString(val)) {
      val = val.toLowerCase();
      return val == 'yes' || val == 'true' || val == '1';
    }

    return !!val;
  }

  function isValueObj(obj) {
    return _.isObject(obj)
      && 'value' in obj
      && _.keys(obj).length < 3;
  }

  return {
    /**
     * Creates new preference item with default value
     * @param {String} name Preference name. You can also pass object
     * with many options
     * @param {Object} value Preference default value
     * @param {String} description Item textual description
     * @memberOf preferences
     */
    define: function(name, value, description) {
      var prefs = name;
      if (_.isString(name)) {
        prefs = {};
        prefs[name] = {
          value: value,
          description: description
        };
      }

      _.each(prefs, function(v, k) {
        defaults[k] = isValueObj(v) ? v : {value: v};
      });
    },

    /**
     * Updates preference item value. Preference value should be defined
     * first with <code>define</code> method.
     * @param {String} name Preference name. You can also pass object
     * with many options
     * @param {Object} value Preference default value
     * @memberOf preferences
     */
    set: function(name, value) {
      var prefs = name;
      if (_.isString(name)) {
        prefs = {};
        prefs[name] = value;
      }

      _.each(prefs, function(v, k) {
        if (!(k in defaults)) {
          throw 'Property "' + k + '" is not defined. You should define it first with `define` method of current module';
        }

        // do not set value if it equals to default value
        if (v !== defaults[k].value) {
          // make sure we have value of correct type
          switch (typeof defaults[k].value) {
            case 'boolean':
              v = toBoolean(v);
              break;
            case 'number':
              v = parseInt(v + '', 10) || 0;
              break;
            default: // convert to string
              v += '';
          }

          preferences[k] = v;
        } else if  (k in preferences) {
          delete preferences[k];
        }
      });
    },

    /**
     * Returns preference value
     * @param {String} name
     * @returns {String} Returns <code>undefined</code> if preference is
     * not defined
     */
    get: function(name) {
      if (name in preferences)
        return preferences[name];

      if (name in defaults)
        return defaults[name].value;

      return void 0;
    },

    /**
     * Returns comma-separated preference value as array of values
     * @param {String} name
     * @returns {Array} Returns <code>undefined</code> if preference is
     * not defined, <code>null</code> if string cannot be converted to array
     */
    getArray: function(name) {
      var val = this.get(name);
      if (!_.isUndefined(val)) {
        val = _.map(val.split(','), require('utils').trim);
        if (!val.length)
          val = null;
      }

      return val;
    },

    /**
     * Returns comma and colon-separated preference value as dictionary
     * @param {String} name
     * @returns {Object}
     */
    getDict: function(name) {
      var result = {};
      _.each(this.getArray(name), function(val) {
        var parts = val.split(':');
        result[parts[0]] = parts[1];
      });

      return result;
    },

    /**
     * Returns description of preference item
     * @param {String} name Preference name
     * @returns {Object}
     */
    description: function(name) {
      return name in defaults ? defaults[name].description : void 0;
    },

    /**
     * Completely removes specified preference(s)
     * @param {String} name Preference name (or array of names)
     */
    remove: function(name) {
      if (!_.isArray(name))
        name = [name];

      _.each(name, function(key) {
        if (key in preferences)
          delete preferences[key];

        if (key in defaults)
          delete defaults[key];
      });
    },

    /**
     * Returns sorted list of all available properties
     * @returns {Array}
     */
    list: function() {
      return _.map(_.keys(defaults).sort(), function(key) {
        return {
          name: key,
          value: this.get(key),
          type: typeof defaults[key].value,
          description: defaults[key].description
        };
      }, this);
    },

    /**
     * Loads user-defined preferences from JSON
     * @param {Object} json
     * @returns
     */
    load: function(json) {
      _.each(json, function(value, key) {
        this.set(key, value);
      }, this);
    },

    /**
     * Returns hash of user-modified preferences
     * @returns {Object}
     */
    exportModified: function() {
      return _.clone(preferences);
    },

    /**
     * Reset to defaults
     * @returns
     */
    reset: function() {
      preferences = {};
    },

    /**
     * For unit testing: use empty storage
     */
    _startTest: function() {
      _dbgDefaults = defaults;
      _dbgPreferences = preferences;
      defaults = {};
      preferences = {};
    },

    /**
     * For unit testing: restore original storage
     */
    _stopTest: function() {
      defaults = _dbgDefaults;
      preferences = _dbgPreferences;
    }
  };
});/**
 * Module for handling filters
 * @param {Function} require
 * @param {Underscore} _
 * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>
 */
emmet.define('filters', function(require, _) {
  /** List of registered filters */
  var registeredFilters = {};

  /** Filters that will be applied for unknown syntax */
  var basicFilters = 'html';

  function list(filters) {
    if (!filters)
      return [];

    if (_.isString(filters))
      return filters.split(/[\|,]/g);

    return filters;
  }

  return  {
    /**
     * Register new filter
     * @param {String} name Filter name
     * @param {Function} fn Filter function
     */
    add: function(name, fn) {
      registeredFilters[name] = fn;
    },

    /**
     * Apply filters for final output tree
     * @param {AbbreviationNode} tree Output tree
     * @param {Array} filters List of filters to apply. Might be a
     * <code>String</code>
     * @param {Object} profile Output profile, defined in <i>profile</i>
     * module. Filters defined it profile are not used, <code>profile</code>
     * is passed to filter function
     * @memberOf emmet.filters
     * @returns {AbbreviationNode}
     */
    apply: function(tree, filters, profile) {
      var utils = require('utils');
      profile = require('profile').get(profile);

      _.each(list(filters), function(filter) {
        var name = utils.trim(filter.toLowerCase());
        if (name && name in registeredFilters) {
          tree = registeredFilters[name](tree, profile);
        }
      });

      return tree;
    },

    /**
     * Composes list of filters that should be applied to a tree, based on
     * passed data
     * @param {String} syntax Syntax name ('html', 'css', etc.)
     * @param {Object} profile Output profile
     * @param {String} additionalFilters List or pipe-separated
     * string of additional filters to apply
     * @returns {Array}
     */
    composeList: function(syntax, profile, additionalFilters) {
      profile = require('profile').get(profile);
      var filters = list(profile.filters || require('resources').findItem(syntax, 'filters') || basicFilters);

      if (profile.extraFilters) {
        filters = filters.concat(list(profile.extraFilters));
      }

      if (additionalFilters) {
        filters = filters.concat(list(additionalFilters));
      }

      if (!filters || !filters.length) {
        // looks like unknown syntax, apply basic filters
        filters = list(basicFilters);
      }

      return filters;
    },

    /**
     * Extracts filter list from abbreviation
     * @param {String} abbr
     * @returns {Array} Array with cleaned abbreviation and list of
     * extracted filters
     */
    extractFromAbbreviation: function(abbr) {
      var filters = '';
      abbr = abbr.replace(/\|([\w\|\-]+)$/, function(str, p1){
        filters = p1;
        return '';
      });

      return [abbr, list(filters)];
    }
  };
});/**
 * Module that contains factories for element types used by Emmet
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('elements', function(require, _) {
  var factories = {};
  var reAttrs = /([\w\-]+)\s*=\s*(['"])(.*?)\2/g;

  var result = {
    /**
     * Create new element factory
     * @param {String} name Element identifier
     * @param {Function} factory Function that produces element of specified
     * type. The object generated by this factory is automatically
     * augmented with <code>type</code> property pointing to element
     * <code>name</code>
     * @memberOf elements
     */
    add: function(name, factory) {
      var that = this;
      factories[name] = function() {
        var elem = factory.apply(that, arguments);
        if (elem)
          elem.type = name;

        return elem;
      };
    },

    /**
     * Returns factory for specified name
     * @param {String} name
     * @returns {Function}
     */
    get: function(name) {
      return factories[name];
    },

    /**
     * Creates new element with specified type
     * @param {String} name
     * @returns {Object}
     */
    create: function(name) {
      var args = [].slice.call(arguments, 1);
      var factory = this.get(name);
      return factory ? factory.apply(this, args) : null;
    },

    /**
     * Check if passed element is of specified type
     * @param {Object} elem
     * @param {String} type
     * @returns {Boolean}
     */
    is: function(elem, type) {
      return elem && elem.type === type;
    }
  };

  // register resource references
  function commonFactory(value) {
    return {data: value};
  }

  /**
   * Element factory
   * @param {String} elementName Name of output element
   * @param {String} attrs Attributes definition. You may also pass
   * <code>Array</code> where each contains object with <code>name</code>
   * and <code>value</code> properties, or <code>Object</code>
   * @param {Boolean} isEmpty Is expanded element should be empty
   */
  result.add('element', function(elementName, attrs, isEmpty) {
    var ret = {
      /** @memberOf __emmetDataElement */
      name: elementName,
      is_empty: !!isEmpty
    };

    if (attrs) {
      ret.attributes = [];
      if (_.isArray(attrs)) {
        ret.attributes = attrs;
      } else if (_.isString(attrs)) {
        var m;
        while (m = reAttrs.exec(attrs)) {
          ret.attributes.push({
            name: m[1],
            value: m[3]
          });
        }
      } else {
        _.each(attrs, function(value, name) {
          ret.attributes.push({
            name: name,
            value: value
          });
        });
      }
    }

    return ret;
  });

  result.add('snippet', commonFactory);
  result.add('reference', commonFactory);
  result.add('empty', function() {
    return {};
  });

  return result;
});/**
 * Abstract implementation of edit tree interface.
 * Edit tree is a named container of editable â€œname-valueâ€ child elements,
 * parsed from <code>source</code>. This container provides convenient methods
 * for editing/adding/removing child elements. All these update actions are
 * instantly reflected in the <code>source</code> code with respect of formatting.
 * <br><br>
 * For example, developer can create an edit tree from CSS rule and add or
 * remove properties from itâ€“all changes will be immediately reflected in the
 * original source.
 * <br><br>
 * All classes defined in this module should be extended the same way as in
 * Backbone framework: using <code>extend</code> method to create new class and
 * <code>initialize</code> method to define custom class constructor.
 *
 * @example
 * <pre><code>
 * var MyClass = require('editTree').EditElement.extend({
 *   initialize: function() {
 *     // constructor code here
 *   }
 * });
 *
 * var elem = new MyClass();
 * </code></pre>
 *
 *
 * @param {Function} require
 * @param {Underscore} _
 * @constructor
 * @memberOf __editTreeDefine
 */
emmet.define('editTree', function(require, _, core) {
  var range = require('range').create;

  /**
   * Named container of edited source
   * @type EditContainer
   * @param {String} source
   * @param {Object} options
   */
  function EditContainer(source, options) {
    this.options = _.extend({offset: 0}, options);
    /**
     * Source code of edited structure. All changes in the structure are
     * immediately reflected into this property
     */
    this.source = source;

    /**
     * List of all editable children
     * @private
     */
    this._children = [];

    /**
     * Hash of all positions of container
     * @private
     */
    this._positions = {
      name: 0
    };

    this.initialize.apply(this, arguments);
  }

  /**
   * The self-propagating extend function for classes.
   * @type Function
   */
  EditContainer.extend = core.extend;

  EditContainer.prototype = {
    /**
     * Child class constructor
     */
    initialize: function() {},

    /**
     * Replace substring of tag's source
     * @param {String} value
     * @param {Number} start
     * @param {Number} end
     * @private
     */
    _updateSource: function(value, start, end) {
      // create modification range
      var r = range(start, _.isUndefined(end) ? 0 : end - start);
      var delta = value.length - r.length();

      var update = function(obj) {
        _.each(obj, function(v, k) {
          if (v >= r.end)
            obj[k] += delta;
        });
      };

      // update affected positions of current container
      update(this._positions);

      // update affected positions of children
      _.each(this.list(), function(item) {
        update(item._positions);
      });

      this.source = require('utils').replaceSubstring(this.source, value, r);
    },


    /**
     * Adds new attribute
     * @param {String} name Property name
     * @param {String} value Property value
     * @param {Number} pos Position at which to insert new property. By
     * default the property is inserted at the end of rule
     * @returns {EditElement} Newly created element
     */
    add: function(name, value, pos) {
      // this is abstract implementation
      var item = new EditElement(name, value);
      this._children.push(item);
      return item;
    },

    /**
     * Returns attribute object
     * @param {String} name Attribute name or its index
     * @returns {EditElement}
     */
    get: function(name) {
      if (_.isNumber(name))
        return this.list()[name];

      if (_.isString(name))
        return _.find(this.list(), function(prop) {
          return prop.name() === name;
        });

      return name;
    },

    /**
     * Returns all children by name or indexes
     * @param {Object} name Element name(s) or indexes (<code>String</code>,
     * <code>Array</code>, <code>Number</code>)
     * @returns {Array}
     */
    getAll: function(name) {
      if (!_.isArray(name))
        name = [name];

      // split names and indexes
      var names = [], indexes = [];
      _.each(name, function(item) {
        if (_.isString(item))
          names.push(item);
        else if (_.isNumber(item))
          indexes.push(item);
      });

      return _.filter(this.list(), function(attribute, i) {
        return _.include(indexes, i) || _.include(names, attribute.name());
      });
    },

    /**
     * Returns or updates element value. If such element doesn't exists,
     * it will be created automatically and added at the end of child list.
     * @param {String} name Element name or its index
     * @param {String} value New element value
     * @returns {String}
     */
    value: function(name, value, pos) {
      var element = this.get(name);
      if (element)
        return element.value(value);

      if (!_.isUndefined(value)) {
        // no such element â€” create it
        return this.add(name, value, pos);
      }
    },

    /**
     * Returns all values of child elements found by <code>getAll()</code>
     * method
     * @param {Object} name Element name(s) or indexes (<code>String</code>,
     * <code>Array</code>, <code>Number</code>)
     * @returns {Array}
     */
    values: function(name) {
      return _.map(this.getAll(name), function(element) {
        return element.value();
      });
    },

    /**
     * Remove child element
     * @param {String} name Property name or its index
     */
    remove: function(name) {
      var element = this.get(name);
      if (element) {
        this._updateSource('', element.fullRange());
        this._children = _.without(this._children, element);
      }
    },

    /**
     * Returns list of all editable child elements
     * @returns {Array}
     */
    list: function() {
      return this._children;
    },

    /**
     * Returns index of editble child in list
     * @param {Object} item
     * @returns {Number}
     */
    indexOf: function(item) {
      return _.indexOf(this.list(), this.get(item));
    },

    /**
     * Sets or gets container name
     * @param {String} val New name. If not passed, current
     * name is returned
     * @return {String}
     */
    name: function(val) {
      if (!_.isUndefined(val) && this._name !== (val = String(val))) {
        this._updateSource(val, this._positions.name, this._positions.name + this._name.length);
        this._name = val;
      }

      return this._name;
    },

    /**
     * Returns name range object
     * @param {Boolean} isAbsolute Return absolute range (with respect of
     * rule offset)
     * @returns {Range}
     */
    nameRange: function(isAbsolute) {
      return range(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());
    },

    /**
     * Returns range of current source
     * @param {Boolean} isAbsolute
     */
    range: function(isAbsolute) {
      return range(isAbsolute ? this.options.offset : 0, this.toString());
    },

    /**
     * Returns element that belongs to specified position
     * @param {Number} pos
     * @param {Boolean} isAbsolute
     * @returns {EditElement}
     */
    itemFromPosition: function(pos, isAbsolute) {
      return _.find(this.list(), function(elem) {
        return elem.range(isAbsolute).inside(pos);
      });
    },

    /**
     * Returns source code of current container
     * @returns {String}
     */
    toString: function() {
      return this.source;
    }
  };

  /**
   * @param {EditContainer} parent
   * @param {Object} nameToken
   * @param {Object} valueToken
   */
  function EditElement(parent, nameToken, valueToken) {
    /** @type EditContainer */
    this.parent = parent;

    this._name = nameToken.value;
    this._value = valueToken ? valueToken.value : '';

    this._positions = {
      name: nameToken.start,
      value: valueToken ? valueToken.start : -1
    };

    this.initialize.apply(this, arguments);
  }

  /**
   * The self-propagating extend function for classes.
   * @type Function
   */
  EditElement.extend = core.extend;

  EditElement.prototype = {
    /**
     * Child class constructor
     */
    initialize: function() {},

    /**
     * Make position absolute
     * @private
     * @param {Number} num
     * @param {Boolean} isAbsolute
     * @returns {Boolean}
     */
    _pos: function(num, isAbsolute) {
      return num + (isAbsolute ? this.parent.options.offset : 0);
    },

    /**
     * Sets of gets element value
     * @param {String} val New element value. If not passed, current
     * value is returned
     * @returns {String}
     */
    value: function(val) {
      if (!_.isUndefined(val) && this._value !== (val = String(val))) {
        this.parent._updateSource(val, this.valueRange());
        this._value = val;
      }

      return this._value;
    },

    /**
     * Sets of gets element name
     * @param {String} val New element name. If not passed, current
     * name is returned
     * @returns {String}
     */
    name: function(val) {
      if (!_.isUndefined(val) && this._name !== (val = String(val))) {
        this.parent._updateSource(val, this.nameRange());
        this._name = val;
      }

      return this._name;
    },

    /**
     * Returns position of element name token
     * @param {Boolean} isAbsolute Return absolute position
     * @returns {Number}
     */
    namePosition: function(isAbsolute) {
      return this._pos(this._positions.name, isAbsolute);
    },

    /**
     * Returns position of element value token
     * @param {Boolean} isAbsolute Return absolute position
     * @returns {Number}
     */
    valuePosition: function(isAbsolute) {
      return this._pos(this._positions.value, isAbsolute);
    },

    /**
     * Returns element name
     * @param {Boolean} isAbsolute Return absolute range
     * @returns {Range}
     */
    range: function(isAbsolute) {
      return range(this.namePosition(isAbsolute), this.toString());
    },

    /**
     * Returns full element range, including possible indentation
     * @param {Boolean} isAbsolute Return absolute range
     * @returns {Range}
     */
    fullRange: function(isAbsolute) {
      return this.range(isAbsolute);
    },

    /**
     * Returns element name range
     * @param {Boolean} isAbsolute Return absolute range
     * @returns {Range}
     */
    nameRange: function(isAbsolute) {
      return range(this.namePosition(isAbsolute), this.name());
    },

    /**
     * Returns element value range
     * @param {Boolean} isAbsolute Return absolute range
     * @returns {Range}
     */
    valueRange: function(isAbsolute) {
      return range(this.valuePosition(isAbsolute), this.value());
    },

    /**
     * Returns current element string representation
     * @returns {String}
     */
    toString: function() {
      return this.name() + this.value();
    },

    valueOf: function() {
      return this.toString();
    }
  };

  return {
    EditContainer: EditContainer,
    EditElement: EditElement,

    /**
     * Creates token that can be fed to <code>EditElement</code>
     * @param {Number} start
     * @param {String} value
     * @param {String} type
     * @returns
     */
    createToken: function(start, value, type) {
      var obj = {
        start: start || 0,
        value: value || '',
        type: type
      };

      obj.end = obj.start + obj.value.length;
      return obj;
    }
  };
});/**
 * CSS EditTree is a module that can parse a CSS rule into a tree with
 * convenient methods for adding, modifying and removing CSS properties. These
 * changes can be written back to string with respect of code formatting.
 *
 * @memberOf __cssEditTreeDefine
 * @constructor
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('cssEditTree', function(require, _) {
  var defaultOptions = {
    styleBefore: '\n\t',
    styleSeparator: ': ',
    offset: 0
  };

  var WHITESPACE_REMOVE_FROM_START = 1;
  var WHITESPACE_REMOVE_FROM_END   = 2;

  /**
   * Returns range object
   * @param {Number} start
   * @param {Number} len
   * @returns {Range}
   */
  function range(start, len) {
    return require('range').create(start, len);
  }

  /**
   * Removes whitespace tokens from the array ends
   * @param {Array} tokens
   * @param {Number} mask Mask indicating from which end whitespace should be
   * removed
   * @returns {Array}
   */
  function trimWhitespaceTokens(tokens, mask) {
    mask = mask || (WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END);
    var whitespace = ['white', 'line'];

    if ((mask & WHITESPACE_REMOVE_FROM_END) == WHITESPACE_REMOVE_FROM_END)
      while (tokens.length && _.include(whitespace, _.last(tokens).type)) {
        tokens.pop();
       }

    if ((mask & WHITESPACE_REMOVE_FROM_START) == WHITESPACE_REMOVE_FROM_START)
      while (tokens.length && _.include(whitespace, tokens[0].type)) {
        tokens.shift();
      }

    return tokens;
  }

  /**
   * Helper function that searches for selector range for <code>CSSEditRule</code>
   * @param {TokenIterator} it
   * @returns {Range}
   */
  function findSelectorRange(it) {
    var tokens = [], token;
     var start = it.position(), end;

     while (token = it.next()) {
      if (token.type == '{')
        break;
      tokens.push(token);
    }

     trimWhitespaceTokens(tokens);

     if (tokens.length) {
       start = tokens[0].start;
       end = _.last(tokens).end;
     } else {
       end = start;
     }

     return range(start, end - start);
  }

  /**
   * Helper function that searches for CSS property value range next to
   * iterator's current position
   * @param {TokenIterator} it
   * @returns {Range}
   */
  function findValueRange(it) {
    // find value start position
    var skipTokens = ['white', 'line', ':'];
    var tokens = [], token, start, end;

    it.nextUntil(function(tok) {
      return !_.include(skipTokens, this.itemNext().type);
    });

    start = it.current().end;
    // consume value
    while (token = it.next()) {
      if (token.type == '}' || token.type == ';') {
        // found value end
        trimWhitespaceTokens(tokens, WHITESPACE_REMOVE_FROM_START
            | (token.type == '}' ? WHITESPACE_REMOVE_FROM_END : 0));

        if (tokens.length) {
          start = tokens[0].start;
          end = _.last(tokens).end;
        } else {
          end = start;
        }

        return range(start, end - start);
      }

      tokens.push(token);
    }

    // reached the end of tokens list
    if (tokens.length) {
      return range(tokens[0].start, _.last(tokens).end - tokens[0].start);
    }
  }

  /**
   * Finds parts of complex CSS value
   * @param {String} str
   * @returns {Array} Returns list of <code>Range</code>'s
   */
  function findParts(str) {
    /** @type StringStream */
    var stream = require('stringStream').create(str);
    var ch;
    var result = [];
    var sep = /[\s\u00a0,]/;

    var add = function() {
      stream.next();
      result.push(range(stream.start, stream.current()));
      stream.start = stream.pos;
    };

    // skip whitespace
    stream.eatSpace();
    stream.start = stream.pos;

    while (ch = stream.next()) {
      if (ch == '"' || ch == "'") {
        stream.next();
        if (!stream.skipTo(ch)) break;
        add();
      } else if (ch == '(') {
        // function found, may have nested function
        stream.backUp(1);
        if (!stream.skipToPair('(', ')')) break;
        stream.backUp(1);
        add();
      } else {
        if (sep.test(ch)) {
          result.push(range(stream.start, stream.current().length - 1));
          stream.eatWhile(sep);
          stream.start = stream.pos;
        }
      }
    }

    add();

    return _.chain(result)
      .filter(function(item) {
        return !!item.length();
      })
      .uniq(false, function(item) {
        return item.toString();
      })
      .value();
  }

  /**
   * A bit hacky way to identify invalid CSS property definition: when user
   * starts writing new abbreviation in CSS rule, he actually creates invalid
   * CSS property definition and this method tries to identify such abbreviation
   * and prevent it from being added to CSS edit tree
   * @param {TokenIterator} it
   */
  function isValidIdentifier(it) {
//    return true;
    var tokens = it.tokens;
    for (var i = it._i + 1, il = tokens.length; i < il; i++) {
      if (tokens[i].type == ':')
        return true;

      if (tokens[i].type == 'identifier' || tokens[i].type == 'line')
        return false;
    }

    return false;
  }

  /**
   * @class
   * @extends EditContainer
   */
  var CSSEditContainer = require('editTree').EditContainer.extend({
    initialize: function(source, options) {
      _.defaults(this.options, defaultOptions);
      var editTree = require('editTree');

      /** @type TokenIterator */
       var it = require('tokenIterator').create(
           require('cssParser').parse(source));

       var selectorRange = findSelectorRange(it);
       this._positions.name = selectorRange.start;
       this._name = selectorRange.substring(source);

       if (!it.current() || it.current().type != '{')
         throw 'Invalid CSS rule';

       this._positions.contentStart = it.position() + 1;

       // consume properties
       var propertyRange, valueRange, token;
      while (token = it.next()) {
        if (token.type == 'identifier' && isValidIdentifier(it)) {
          propertyRange = range(token);
          valueRange = findValueRange(it);
          var end = (it.current() && it.current().type == ';')
            ? range(it.current())
            : range(valueRange.end, 0);
          this._children.push(new CSSEditElement(this,
              editTree.createToken(propertyRange.start, propertyRange.substring(source)),
              editTree.createToken(valueRange.start, valueRange.substring(source)),
              editTree.createToken(end.start, end.substring(source))
              ));
        }
      }

      this._saveStyle();
    },

    /**
     * Remembers all styles of properties
     * @private
     */
    _saveStyle: function() {
      var start = this._positions.contentStart;
      var source = this.source;
      var utils = require('utils');

      _.each(this.list(), /** @param {CSSEditProperty} p */ function(p) {
        p.styleBefore = source.substring(start, p.namePosition());
        // a small hack here:
        // Sometimes users add empty lines before properties to logically
        // separate groups of properties. In this case, a blind copy of
        // characters between rules may lead to undesired behavior,
        // especially when current rule is duplicated or used as a donor
        // to create new rule.
        // To solve this issue, weâ€˜ll take only last newline indentation
        var lines = utils.splitByLines(p.styleBefore);
        if (lines.length > 1) {
          p.styleBefore = '\n' + _.last(lines);
        }

        p.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());

        // graceful and naive comments removal
        p.styleBefore = _.last(p.styleBefore.split('*/'));
        p.styleSeparator = p.styleSeparator.replace(/\/\*.*?\*\//g, '');

        start = p.range().end;
      });
    },

    /**
     * Adds new CSS property
     * @param {String} name Property name
     * @param {String} value Property value
     * @param {Number} pos Position at which to insert new property. By
     * default the property is inserted at the end of rule
     * @returns {CSSEditProperty}
     */
    add: function(name, value, pos) {
      var list = this.list();
      var start = this._positions.contentStart;
      var styles = _.pick(this.options, 'styleBefore', 'styleSeparator');
      var editTree = require('editTree');

      if (_.isUndefined(pos))
        pos = list.length;

      /** @type CSSEditProperty */
      var donor = list[pos];
      if (donor) {
        start = donor.fullRange().start;
      } else if (donor = list[pos - 1]) {
        // make sure that donor has terminating semicolon
        donor.end(';');
        start = donor.range().end;
      }

      if (donor) {
        styles = _.pick(donor, 'styleBefore', 'styleSeparator');
      }

      var nameToken = editTree.createToken(start + styles.styleBefore.length, name);
      var valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);

      var property = new CSSEditElement(this, nameToken, valueToken,
          editTree.createToken(valueToken.end, ';'));

      _.extend(property, styles);

      // write new property into the source
      this._updateSource(property.styleBefore + property.toString(), start);

      // insert new property
      this._children.splice(pos, 0, property);
      return property;
    }
  });

  /**
   * @class
   * @type CSSEditElement
   * @constructor
   */
  var CSSEditElement = require('editTree').EditElement.extend({
    initialize: function(rule, name, value, end) {
      this.styleBefore = rule.options.styleBefore;
      this.styleSeparator = rule.options.styleSeparator;

      this._end = end.value;
      this._positions.end = end.start;
    },

    /**
     * Returns ranges of complex value parts
     * @returns {Array} Returns <code>null</code> if value is not complex
     */
    valueParts: function(isAbsolute) {
      var parts = findParts(this.value());
      if (isAbsolute) {
        var offset = this.valuePosition(true);
        _.each(parts, function(p) {
          p.shift(offset);
        });
      }

      return parts;
    },

    /**
     * Sets of gets property end value (basically, it's a semicolon)
     * @param {String} val New end value. If not passed, current
     * value is returned
     */
    end: function(val) {
      if (!_.isUndefined(val) && this._end !== val) {
        this.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);
        this._end = val;
      }

      return this._end;
    },

    /**
     * Returns full rule range, with indentation
     * @param {Boolean} isAbsolute Return absolute range (with respect of
     * rule offset)
     * @returns {Range}
     */
    fullRange: function(isAbsolute) {
      var r = this.range(isAbsolute);
      r.start -= this.styleBefore.length;
      return r;
    },

    /**
     * Returns item string representation
     * @returns {String}
     */
    toString: function() {
      return this.name() + this.styleSeparator + this.value() + this.end();
    }
  });

  return {
    /**
     * Parses CSS rule into editable tree
     * @param {String} source
     * @param {Object} options
     * @memberOf emmet.cssEditTree
     * @returns {EditContainer}
     */
    parse: function(source, options) {
      return new CSSEditContainer(source, options);
    },

    /**
     * Extract and parse CSS rule from specified position in <code>content</code>
     * @param {String} content CSS source code
     * @param {Number} pos Character position where to start source code extraction
     * @returns {EditContainer}
     */
    parseFromPosition: function(content, pos, isBackward) {
      var bounds = this.extractRule(content, pos, isBackward);
      if (!bounds || !bounds.inside(pos))
        // no matching CSS rule or caret outside rule bounds
        return null;

      return this.parse(bounds.substring(content), {
        offset: bounds.start
      });
    },

    /**
     * Extracts single CSS selector definition from source code
     * @param {String} content CSS source code
     * @param {Number} pos Character position where to start source code extraction
     * @returns {Range}
     */
    extractRule: function(content, pos, isBackward) {
      var result = '';
      var len = content.length;
      var offset = pos;
      var stopChars = '{}/\\<>\n\r';
      var bracePos = -1, ch;

      // search left until we find rule edge
      while (offset >= 0) {
        ch = content.charAt(offset);
        if (ch == '{') {
          bracePos = offset;
          break;
        }
        else if (ch == '}' && !isBackward) {
          offset++;
          break;
        }

        offset--;
      }

      // search right for full rule set
      while (offset < len) {
        ch = content.charAt(offset);
        if (ch == '{') {
          bracePos = offset;
        } else if (ch == '}') {
          if (bracePos != -1)
            result = content.substring(bracePos, offset + 1);
          break;
        }

        offset++;
      }

      if (result) {
        // find CSS selector
        offset = bracePos - 1;
        var selector = '';
        while (offset >= 0) {
          ch = content.charAt(offset);
          if (stopChars.indexOf(ch) != -1) break;
          offset--;
        }

        // also trim whitespace
        selector = content.substring(offset + 1, bracePos).replace(/^[\s\n\r]+/m, '');
        return require('range').create(bracePos - selector.length, result.length + selector.length);
      }

      return null;
    },

    /**
      * Removes vendor prefix from CSS property
      * @param {String} name CSS property
      * @return {String}
      */
     baseName: function(name) {
       return name.replace(/^\s*\-\w+\-/, '');
     },

     /**
      * Finds parts of complex CSS value
      * @param {String} str
      * @returns {Array}
      */
     findParts: findParts
  };
});/**
 * XML EditTree is a module that can parse an XML/HTML element into a tree with
 * convenient methods for adding, modifying and removing attributes. These
 * changes can be written back to string with respect of code formatting.
 *
 * @memberOf __xmlEditTreeDefine
 * @constructor
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('xmlEditTree', function(require, _) {
  var defaultOptions = {
    styleBefore: ' ',
    styleSeparator: '=',
    styleQuote: '"',
    offset: 0
  };

  var startTag = /^<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/m;

  var XMLEditContainer = require('editTree').EditContainer.extend({
    initialize: function(source, options) {
      _.defaults(this.options, defaultOptions);
      this._positions.name = 1;

      var attrToken = null;
      var tokens = require('xmlParser').parse(source);
      var range = require('range');

      _.each(tokens, function(token) {
        token.value = range.create(token).substring(source);
        switch (token.type) {
          case 'tag':
            if (/^<[^\/]+/.test(token.value)) {
              this._name = token.value.substring(1);
            }
            break;

          case 'attribute':
            // add empty attribute
            if (attrToken) {
              this._children.push(new XMLEditElement(this, attrToken));
            }

            attrToken = token;
            break;

          case 'string':
            this._children.push(new XMLEditElement(this, attrToken, token));
            attrToken = null;
            break;
        }
      }, this);

      if (attrToken) {
        this._children.push(new XMLEditElement(this, attrToken));
      }

      this._saveStyle();
    },

    /**
     * Remembers all styles of properties
     * @private
     */
    _saveStyle: function() {
      var start = this.nameRange().end;
      var source = this.source;

      _.each(this.list(), /** @param {EditElement} p */ function(p) {
        p.styleBefore = source.substring(start, p.namePosition());

        if (p.valuePosition() !== -1) {
          p.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);
        }

        start = p.range().end;
      });
    },

    /**
     * Adds new attribute
     * @param {String} name Property name
     * @param {String} value Property value
     * @param {Number} pos Position at which to insert new property. By
     * default the property is inserted at the end of rule
     */
    add: function(name, value, pos) {
      var list = this.list();
      var start = this.nameRange().end;
      var editTree = require('editTree');
      var styles = _.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');

      if (_.isUndefined(pos))
        pos = list.length;


      /** @type XMLEditAttribute */
      var donor = list[pos];
      if (donor) {
        start = donor.fullRange().start;
      } else if (donor = list[pos - 1]) {
        start = donor.range().end;
      }

      if (donor) {
        styles = _.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');
      }

      value = styles.styleQuote + value + styles.styleQuote;

      var attribute = new XMLEditElement(this,
          editTree.createToken(start + styles.styleBefore.length, name),
          editTree.createToken(start + styles.styleBefore.length + name.length
              + styles.styleSeparator.length, value)
          );

      _.extend(attribute, styles);

      // write new attribute into the source
      this._updateSource(attribute.styleBefore + attribute.toString(), start);

      // insert new attribute
      this._children.splice(pos, 0, attribute);
      return attribute;
    }
  });

  var XMLEditElement = require('editTree').EditElement.extend({
    initialize: function(parent, nameToken, valueToken) {
      this.styleBefore = parent.options.styleBefore;
      this.styleSeparator = parent.options.styleSeparator;

      var value = '', quote = parent.options.styleQuote;
      if (valueToken) {
        value = valueToken.value;
        quote = value.charAt(0);
        if (quote == '"' || quote == "'") {
          value = value.substring(1);
        } else {
          quote = '';
        }

        if (quote && value.charAt(value.length - 1) == quote) {
          value = value.substring(0, value.length - 1);
        }
      }

      this.styleQuote = quote;

      this._value = value;
      this._positions.value = valueToken ? valueToken.start + quote.length : -1;
    },

    /**
     * Returns full rule range, with indentation
     * @param {Boolean} isAbsolute Return absolute range (with respect of
     * rule offset)
     * @returns {Range}
     */
    fullRange: function(isAbsolute) {
      var r = this.range(isAbsolute);
      r.start -= this.styleBefore.length;
      return r;
    },

    toString: function() {
      return this.name() + this.styleSeparator
        + this.styleQuote + this.value() + this.styleQuote;
    }
  });

  return {
    /**
     * Parses HTML element into editable tree
     * @param {String} source
     * @param {Object} options
     * @memberOf emmet.htmlEditTree
     * @returns {EditContainer}
     */
    parse: function(source, options) {
      return new XMLEditContainer(source, options);
    },

    /**
     * Extract and parse HTML from specified position in <code>content</code>
     * @param {String} content CSS source code
     * @param {Number} pos Character position where to start source code extraction
     * @returns {XMLEditElement}
     */
    parseFromPosition: function(content, pos, isBackward) {
      var bounds = this.extractTag(content, pos, isBackward);
      if (!bounds || !bounds.inside(pos))
        // no matching HTML tag or caret outside tag bounds
        return null;

      return this.parse(bounds.substring(content), {
        offset: bounds.start
      });
    },

    /**
     * Extracts nearest HTML tag range from <code>content</code>, starting at
     * <code>pos</code> position
     * @param {String} content
     * @param {Number} pos
     * @param {Boolean} isBackward
     * @returns {Range}
     */
    extractTag: function(content, pos, isBackward) {
      var len = content.length, i;
      var range = require('range');

      // max extraction length. I don't think there may be tags larger
      // than 2000 characters length
      var maxLen = Math.min(2000, len);

      /** @type Range */
      var r = null;

      var match = function(pos) {
        var m;
        if (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag)))
          return range.create(pos, m[0]);
      };

      // lookup backward, in case we are inside tag already
      for (i = pos; i >= 0; i--) {
        if (r = match(i)) break;
      }

      if (r && (r.inside(pos) || isBackward))
        return r;

      if (!r && isBackward)
        return null;

      // search forward
      for (i = pos; i < len; i++) {
        if (r = match(i))
          return r;
      }
    }
  };
});/**
 * 'Expand abbreviation' editor action: extracts abbreviation from current caret
 * position and replaces it with formatted output.
 * <br><br>
 * This behavior can be overridden with custom handlers which can perform
 * different actions when 'Expand Abbreviation' action is called.
 * For example, a CSS gradient handler that produces vendor-prefixed gradient
 * definitions registers its own expand abbreviation handler.
 *
 * @constructor
 * @memberOf __expandAbbreviationActionDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('expandAbbreviation', function(require, _) {
  /**
   * @type HandlerList List of registered handlers
   */
  var handlers = require('handlerList').create();

  /** Back-reference to module */
  var module = null;

  var actions = require('actions');
  /**
   * 'Expand abbreviation' editor action
   * @param {IEmmetEditor} editor Editor instance
   * @param {String} syntax Syntax type (html, css, etc.)
   * @param {String} profile Output profile name (html, xml, xhtml)
   * @return {Boolean} Returns <code>true</code> if abbreviation was expanded
   * successfully
   */
  actions.add('expand_abbreviation', function(editor, syntax, profile) {
    var args = _.toArray(arguments);

    // normalize incoming arguments
    var info = require('editorUtils').outputInfo(editor, syntax, profile);
    args[1] = info.syntax;
    args[2] = info.profile;

    return handlers.exec(false, args);
  });

  /**
   * A special version of <code>expandAbbreviation</code> function: if it can't
   * find abbreviation, it will place Tab character at caret position
   * @param {IEmmetEditor} editor Editor instance
   * @param {String} syntax Syntax type (html, css, etc.)
   * @param {String} profile Output profile name (html, xml, xhtml)
   */
  actions.add('expand_abbreviation_with_tab', function(editor, syntax, profile) {
    var sel = editor.getSelection();
    var indent = require('resources').getVariable('indentation');
    if (sel) {
      // indent selection
      var utils = require('utils');
      var selRange = require('range').create(editor.getSelectionRange());
      var content = utils.padString(sel, indent);

      editor.replaceContent(indent + '${0}', editor.getCaretPos());
      var replaceRange = require('range').create(editor.getCaretPos(), selRange.length());
      editor.replaceContent(content, replaceRange.start, replaceRange.end, true);
      editor.createSelection(replaceRange.start, replaceRange.start + content.length);
      return true;
    }

    if (!actions.run('expand_abbreviation', editor, syntax, profile)) {
      editor.replaceContent(indent, editor.getCaretPos());
    }

    return true;
  }, {hidden: true});

  // XXX setup default handler
  /**
   * Extracts abbreviation from current caret
   * position and replaces it with formatted output
   * @param {IEmmetEditor} editor Editor instance
   * @param {String} syntax Syntax type (html, css, etc.)
   * @param {String} profile Output profile name (html, xml, xhtml)
   * @return {Boolean} Returns <code>true</code> if abbreviation was expanded
   * successfully
   */
  handlers.add(function(editor, syntax, profile) {
    var caretPos = editor.getSelectionRange().end;
    var abbr = module.findAbbreviation(editor);

    if (abbr) {
      var content = emmet.expandAbbreviation(abbr, syntax, profile,
          require('actionUtils').captureContext(editor));
      if (content) {
        editor.replaceContent(content, caretPos - abbr.length, caretPos);
        return true;
      }
    }

    return false;
  }, {order: -1});

  return module = {
    /**
     * Adds custom expand abbreviation handler. The passed function should
     * return <code>true</code> if it was performed successfully,
     * <code>false</code> otherwise.
     *
     * Added handlers will be called when 'Expand Abbreviation' is called
     * in order they were added
     * @memberOf expandAbbreviation
     * @param {Function} fn
     * @param {Object} options
     */
    addHandler: function(fn, options) {
      handlers.add(fn, options);
    },

    /**
     * Removes registered handler
     * @returns
     */
    removeHandler: function(fn) {
      handlers.remove(fn, options);
    },

    /**
     * Search for abbreviation in editor from current caret position
     * @param {IEmmetEditor} editor Editor instance
     * @return {String}
     */
    findAbbreviation: function(editor) {
      /** @type Range */
      var range = require('range').create(editor.getSelectionRange());
      var content = String(editor.getContent());
      if (range.length()) {
        // abbreviation is selected by user
        return range.substring(content);
      }

      // search for new abbreviation from current caret position
      var curLine = editor.getCurrentLineRange();
      return require('actionUtils').extractAbbreviation(content.substring(curLine.start, range.start));
    }
  };
});/**
 * Action that wraps content with abbreviation. For convenience, action is
 * defined as reusable module
 * @constructor
 * @memberOf __wrapWithAbbreviationDefine
 */
emmet.define('wrapWithAbbreviation', function(require, _) {
  /** Back-references to current module */
  var module = null;

  /**
   * Wraps content with abbreviation
   * @param {IEmmetEditor} Editor instance
   * @param {String} abbr Abbreviation to wrap with
   * @param {String} syntax Syntax type (html, css, etc.)
   * @param {String} profile Output profile name (html, xml, xhtml)
   */
  require('actions').add('wrap_with_abbreviation', function (editor, abbr, syntax, profile) {
    var info = require('editorUtils').outputInfo(editor, syntax, profile);
    var utils = require('utils');
    /** @type emmet.editorUtils */
    var editorUtils = require('editorUtils');
    abbr = abbr || editor.prompt("Enter abbreviation");

    if (!abbr)
      return null;

    abbr = String(abbr);

    var range = require('range').create(editor.getSelectionRange());

    if (!range.length()) {
      // no selection, find tag pair
      var match = require('htmlMatcher').tag(info.content, range.start);
      if (!match) {  // nothing to wrap
        return false;
      }

      range = utils.narrowToNonSpace(info.content, match.range);
    }

    var newContent = utils.escapeText(range.substring(info.content));
    var result = module
      .wrap(abbr, editorUtils.unindent(editor, newContent), info.syntax,
          info.profile, require('actionUtils').captureContext(editor));

    if (result) {
      editor.replaceContent(result, range.start, range.end);
      return true;
    }

    return false;
  });

  return module = {
    /**
     * Wraps passed text with abbreviation. Text will be placed inside last
     * expanded element
     * @memberOf wrapWithAbbreviation
     * @param {String} abbr Abbreviation
     * @param {String} text Text to wrap
     * @param {String} syntax Document type (html, xml, etc.). Default is 'html'
     * @param {String} profile Output profile's name. Default is 'plain'
     * @param {Object} contextNode Context node inside which abbreviation
     * is wrapped. It will be used as a reference for node name resolvers
     * @return {String}
     */
    wrap: function(abbr, text, syntax, profile, contextNode) {
      /** @type emmet.filters */
      var filters = require('filters');
      /** @type emmet.utils */
      var utils = require('utils');

      syntax = syntax || emmet.defaultSyntax();
      profile = require('profile').get(profile, syntax);

      require('tabStops').resetTabstopIndex();

      var data = filters.extractFromAbbreviation(abbr);
      var parsedTree = require('abbreviationParser').parse(data[0], {
        syntax: syntax,
        pastedContent: text,
        contextNode: contextNode
      });
      if (parsedTree) {
        var filtersList = filters.composeList(syntax, profile, data[1]);
        filters.apply(parsedTree, filtersList, profile);
        return utils.replaceVariables(parsedTree.toString());
      }

      return null;
    }
  };
});/**
 * Toggles HTML and CSS comments depending on current caret context. Unlike
 * the same action in most editors, this action toggles comment on currently
 * matched itemâ€”HTML tag or CSS selectorâ€”when nothing is selected.
 *
 * @param {Function} require
 * @param {Underscore} _
 * @memberOf __toggleCommentAction
 * @constructor
 */
emmet.exec(function(require, _) {
  /**
   * Toggle HTML comment on current selection or tag
   * @param {IEmmetEditor} editor
   * @return {Boolean} Returns <code>true</code> if comment was toggled
   */
  function toggleHTMLComment(editor) {
    /** @type Range */
    var range = require('range').create(editor.getSelectionRange());
    var info = require('editorUtils').outputInfo(editor);

    if (!range.length()) {
      // no selection, find matching tag
      var tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());
      if (tag) { // found pair
        range = tag.outerRange;
      }
    }

    return genericCommentToggle(editor, '<!--', '-->', range);
  }

  /**
   * Simple CSS commenting
   * @param {IEmmetEditor} editor
   * @return {Boolean} Returns <code>true</code> if comment was toggled
   */
  function toggleCSSComment(editor) {
    /** @type Range */
    var range = require('range').create(editor.getSelectionRange());
    var info = require('editorUtils').outputInfo(editor);

    if (!range.length()) {
      // no selection, try to get current rule
      /** @type CSSRule */
      var rule = require('cssEditTree').parseFromPosition(info.content, editor.getCaretPos());
      if (rule) {
        var property = cssItemFromPosition(rule, editor.getCaretPos());
        range = property
          ? property.range(true)
          : require('range').create(rule.nameRange(true).start, rule.source);
      }
    }

    if (!range.length()) {
      // still no selection, get current line
      range = require('range').create(editor.getCurrentLineRange());
      require('utils').narrowToNonSpace(info.content, range);
    }

    return genericCommentToggle(editor, '/*', '*/', range);
  }

  /**
   * Returns CSS property from <code>rule</code> that matches passed position
   * @param {EditContainer} rule
   * @param {Number} absPos
   * @returns {EditElement}
   */
  function cssItemFromPosition(rule, absPos) {
    // do not use default EditContainer.itemFromPosition() here, because
    // we need to make a few assumptions to make CSS commenting more reliable
    var relPos = absPos - (rule.options.offset || 0);
    var reSafeChar = /^[\s\n\r]/;
    return _.find(rule.list(), function(item) {
      if (item.range().end === relPos) {
        // at the end of property, but outside of it
        // if thereâ€™s a space character at current position,
        // use current property
        return reSafeChar.test(rule.source.charAt(relPos));
      }

      return item.range().inside(relPos);
    });
  }

  /**
   * Search for nearest comment in <code>str</code>, starting from index <code>from</code>
   * @param {String} text Where to search
   * @param {Number} from Search start index
   * @param {String} start_token Comment start string
   * @param {String} end_token Comment end string
   * @return {Range} Returns null if comment wasn't found
   */
  function searchComment(text, from, startToken, endToken) {
    var commentStart = -1;
    var commentEnd = -1;

    var hasMatch = function(str, start) {
      return text.substr(start, str.length) == str;
    };

    // search for comment start
    while (from--) {
      if (hasMatch(startToken, from)) {
        commentStart = from;
        break;
      }
    }

    if (commentStart != -1) {
      // search for comment end
      from = commentStart;
      var contentLen = text.length;
      while (contentLen >= from++) {
        if (hasMatch(endToken, from)) {
          commentEnd = from + endToken.length;
          break;
        }
      }
    }

    return (commentStart != -1 && commentEnd != -1)
      ? require('range').create(commentStart, commentEnd - commentStart)
      : null;
  }

  /**
   * Generic comment toggling routine
   * @param {IEmmetEditor} editor
   * @param {String} commentStart Comment start token
   * @param {String} commentEnd Comment end token
   * @param {Range} range Selection range
   * @return {Boolean}
   */
  function genericCommentToggle(editor, commentStart, commentEnd, range) {
    var editorUtils = require('editorUtils');
    var content = editorUtils.outputInfo(editor).content;
    var caretPos = editor.getCaretPos();
    var newContent = null;

    var utils = require('utils');

    /**
     * Remove comment markers from string
     * @param {Sting} str
     * @return {String}
     */
    function removeComment(str) {
      return str
        .replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\s*'), function(str){
          caretPos -= str.length;
          return '';
        }).replace(new RegExp('\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');
    }

    // first, we need to make sure that this substring is not inside
    // comment
    var commentRange = searchComment(content, caretPos, commentStart, commentEnd);
    if (commentRange && commentRange.overlap(range)) {
      // we're inside comment, remove it
      range = commentRange;
      newContent = removeComment(range.substring(content));
    } else {
      // should add comment
      // make sure that there's no comment inside selection
      newContent = commentStart + ' ' +
        range.substring(content)
          .replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\s*|\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') +
        ' ' + commentEnd;

      // adjust caret position
      caretPos += commentStart.length + 1;
    }

    // replace editor content
    if (newContent !== null) {
      newContent = utils.escapeText(newContent);
      editor.setCaretPos(range.start);
      editor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);
      editor.setCaretPos(caretPos);
      return true;
    }

    return false;
  }

  /**
   * Toggle comment on current editor's selection or HTML tag/CSS rule
   * @param {IEmmetEditor} editor
   */
  require('actions').add('toggle_comment', function(editor) {
    var info = require('editorUtils').outputInfo(editor);
    if (info.syntax == 'css') {
      // in case our editor is good enough and can recognize syntax from
      // current token, we have to make sure that cursor is not inside
      // 'style' attribute of html element
      var caretPos = editor.getCaretPos();
      var tag = require('htmlMatcher').tag(info.content, caretPos);
      if (tag && tag.open.range.inside(caretPos)) {
        info.syntax = 'html';
      }
    }

    if (info.syntax == 'html')
      return toggleHTMLComment(editor);

    return toggleCSSComment(editor);
  });
});/**
 * Move between next/prev edit points. 'Edit points' are places between tags
 * and quotes of empty attributes in html
 * @constructor
 *
 * @memberOf __editPointActionDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  /**
   * Search for new caret insertion point
   * @param {IEmmetEditor} editor Editor instance
   * @param {Number} inc Search increment: -1 â€” search left, 1 â€” search right
   * @param {Number} offset Initial offset relative to current caret position
   * @return {Number} Returns -1 if insertion point wasn't found
   */
  function findNewEditPoint(editor, inc, offset) {
    inc = inc || 1;
    offset = offset || 0;

    var curPoint = editor.getCaretPos() + offset;
    var content = String(editor.getContent());
    var maxLen = content.length;
    var nextPoint = -1;
    var reEmptyLine = /^\s+$/;

    function getLine(ix) {
      var start = ix;
      while (start >= 0) {
        var c = content.charAt(start);
        if (c == '\n' || c == '\r')
          break;
        start--;
      }

      return content.substring(start, ix);
    }

    while (curPoint <= maxLen && curPoint >= 0) {
      curPoint += inc;
      var curChar = content.charAt(curPoint);
      var nextChar = content.charAt(curPoint + 1);
      var prevChar = content.charAt(curPoint - 1);

      switch (curChar) {
        case '"':
        case '\'':
          if (nextChar == curChar && prevChar == '=') {
            // empty attribute
            nextPoint = curPoint + 1;
          }
          break;
        case '>':
          if (nextChar == '<') {
            // between tags
            nextPoint = curPoint + 1;
          }
          break;
        case '\n':
        case '\r':
          // empty line
          if (reEmptyLine.test(getLine(curPoint - 1))) {
            nextPoint = curPoint;
          }
          break;
      }

      if (nextPoint != -1)
        break;
    }

    return nextPoint;
  }

  /** @type emmet.actions */
  var actions = require('actions');

  /**
   * Move caret to previous edit point
   * @param {IEmmetEditor} editor Editor instance
   */
  actions.add('prev_edit_point', function(editor) {
    var curPos = editor.getCaretPos();
    var newPoint = findNewEditPoint(editor, -1);

    if (newPoint == curPos)
      // we're still in the same point, try searching from the other place
      newPoint = findNewEditPoint(editor, -1, -2);

    if (newPoint != -1) {
      editor.setCaretPos(newPoint);
      return true;
    }

    return false;
  }, {label: 'Previous Edit Point'});

  /**
   * Move caret to next edit point
   * @param {IEmmetEditor} editor Editor instance
   */
  actions.add('next_edit_point', function(editor) {
    var newPoint = findNewEditPoint(editor, 1);
    if (newPoint != -1) {
      editor.setCaretPos(newPoint);
      return true;
    }

    return false;
  });
});/**
 * Actions that use stream parsers and tokenizers for traversing:
 * -- Search for next/previous items in HTML
 * -- Search for next/previous items in CSS
 * @constructor
 * @memberOf __selectItemActionDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  var startTag = /^<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/;

  /**
   * Generic function for searching for items to select
   * @param {IEmmetEditor} editor
   * @param {Boolean} isBackward Search backward (search forward otherwise)
   * @param {Function} extractFn Function that extracts item content
   * @param {Function} rangeFn Function that search for next token range
   */
  function findItem(editor, isBackward, extractFn, rangeFn) {
    var range = require('range');
    var content = require('editorUtils').outputInfo(editor).content;

    var contentLength = content.length;
    var itemRange, rng;
    /** @type Range */
    var prevRange = range.create(-1, 0);
    /** @type Range */
    var sel = range.create(editor.getSelectionRange());

    var searchPos = sel.start, loop = 100000; // endless loop protection
    while (searchPos >= 0 && searchPos < contentLength && --loop > 0) {
      if ( (itemRange = extractFn(content, searchPos, isBackward)) ) {
        if (prevRange.equal(itemRange)) {
          break;
        }

        prevRange = itemRange.clone();
        rng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());

        if (rng) {
          editor.createSelection(rng.start, rng.end);
          return true;
        } else {
          searchPos = isBackward ? itemRange.start : itemRange.end - 1;
        }
      }

      searchPos += isBackward ? -1 : 1;
    }

    return false;
  }

  // XXX HTML section

  /**
   * Find next HTML item
   * @param {IEmmetEditor} editor
   */
  function findNextHTMLItem(editor) {
    var isFirst = true;
    return findItem(editor, false, function(content, searchPos){
      if (isFirst) {
        isFirst = false;
        return findOpeningTagFromPosition(content, searchPos);
      } else {
        return getOpeningTagFromPosition(content, searchPos);
      }
    }, function(tag, offset, selRange) {
      return getRangeForHTMLItem(tag, offset, selRange, false);
    });
  }

  /**
   * Find previous HTML item
   * @param {IEmmetEditor} editor
   */
  function findPrevHTMLItem(editor) {
    return findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {
      return getRangeForHTMLItem(tag, offset, selRange, true);
    });
  }

  /**
   * Creates possible selection ranges for HTML tag
   * @param {String} source Original HTML source for tokens
   * @param {Array} tokens List of HTML tokens
   * @returns {Array}
   */
  function makePossibleRangesHTML(source, tokens, offset) {
    offset = offset || 0;
    var range = require('range');
    var result = [];
    var attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;
    _.each(tokens, function(tok) {
      switch (tok.type) {
        case 'tag':
          tagName = source.substring(tok.start, tok.end);
          if (/^<[\w\:\-]/.test(tagName)) {
            // add tag name
            result.push(range.create({
              start: tok.start + 1,
              end: tok.end
            }));
          }
          break;
        case 'attribute':
          attrStart = tok.start;
          attrName = source.substring(tok.start, tok.end);
          break;

        case 'string':
          // attribute value
          // push full attribute first
           result.push(range.create(attrStart, tok.end - attrStart));

           attrValueRange = range.create(tok);
           attrValue = attrValueRange.substring(source);

           // is this a quoted attribute?
           if (isQuote(attrValue.charAt(0)))
             attrValueRange.start++;

           if (isQuote(attrValue.charAt(attrValue.length - 1)))
             attrValueRange.end--;

           result.push(attrValueRange);

           if (attrName == 'class') {
             result = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));
           }

          break;
      }
    });

    // offset ranges
    _.each(result, function(r) {
      r.shift(offset);
    });

    return _.chain(result)
      .filter(function(item) {        // remove empty
        return !!item.length();
      })
      .uniq(false, function(item) {   // remove duplicates
        return item.toString();
      })
      .value();
  }

  /**
   * Returns ranges of class names in "class" attribute value
   * @param {String} className
   * @returns {Array}
   */
  function classNameRanges(className, offset) {
    offset = offset || 0;
    var result = [];
    /** @type StringStream */
    var stream = require('stringStream').create(className);
    var range = require('range');

    // skip whitespace
    stream.eatSpace();
    stream.start = stream.pos;

    var ch;
    while (ch = stream.next()) {
      if (/[\s\u00a0]/.test(ch)) {
        result.push(range.create(stream.start + offset, stream.pos - stream.start - 1));
        stream.eatSpace();
        stream.start = stream.pos;
      }
    }

    result.push(range.create(stream.start + offset, stream.pos - stream.start));
    return result;
  }

  /**
   * Returns best HTML tag range match for current selection
   * @param {String} tag Tag declaration
   * @param {Number} offset Tag's position index inside content
   * @param {Range} selRange Selection range
   * @return {Range} Returns range if next item was found, <code>null</code> otherwise
   */
  function getRangeForHTMLItem(tag, offset, selRange, isBackward) {
    var ranges = makePossibleRangesHTML(tag, require('xmlParser').parse(tag), offset);

    if (isBackward)
      ranges.reverse();

    // try to find selected range
    var curRange = _.find(ranges, function(r) {
      return r.equal(selRange);
    });

    if (curRange) {
      var ix = _.indexOf(ranges, curRange);
      if (ix < ranges.length - 1)
        return ranges[ix + 1];

      return null;
    }

    // no selected range, find nearest one
    if (isBackward)
      // search backward
      return _.find(ranges, function(r) {
        return r.start < selRange.start;
      });

    // search forward
    // to deal with overlapping ranges (like full attribute definition
    // and attribute value) let's find range under caret first
    if (!curRange) {
      var matchedRanges = _.filter(ranges, function(r) {
        return r.inside(selRange.end);
      });

      if (matchedRanges.length > 1)
        return matchedRanges[1];
    }


    return _.find(ranges, function(r) {
      return r.end > selRange.end;
    });
  }

  /**
   * Search for opening tag in content, starting at specified position
   * @param {String} html Where to search tag
   * @param {Number} pos Character index where to start searching
   * @return {Range} Returns range if valid opening tag was found,
   * <code>null</code> otherwise
   */
  function findOpeningTagFromPosition(html, pos) {
    var tag;
    while (pos >= 0) {
      if (tag = getOpeningTagFromPosition(html, pos))
        return tag;
      pos--;
    }

    return null;
  }

  /**
   * @param {String} html Where to search tag
   * @param {Number} pos Character index where to start searching
   * @return {Range} Returns range if valid opening tag was found,
   * <code>null</code> otherwise
   */
  function getOpeningTagFromPosition(html, pos) {
    var m;
    if (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {
      return require('range').create(pos, m[0]);
    }
  }

  function isQuote(ch) {
    return ch == '"' || ch == "'";
  }

  /**
   * Makes all possible selection ranges for specified CSS property
   * @param {CSSProperty} property
   * @returns {Array}
   */
  function makePossibleRangesCSS(property) {
    // find all possible ranges, sorted by position and size
    var valueRange = property.valueRange(true);
    var result = [property.range(true), valueRange];
    var stringStream = require('stringStream');
    var cssEditTree = require('cssEditTree');
    var range = require('range');

    // locate parts of complex values.
    // some examples:
    // â€“ 1px solid red: 3 parts
    // â€“ arial, sans-serif: enumeration, 2 parts
    // â€“ url(image.png): function value part
    var value = property.value();
    _.each(property.valueParts(), function(r) {
      // add absolute range
      var clone = r.clone();
      result.push(clone.shift(valueRange.start));

      /** @type StringStream */
      var stream = stringStream.create(r.substring(value));
      if (stream.match(/^[\w\-]+\(/, true)) {
        // we have a function, find values in it.
        // but first add function contents
        stream.start = stream.pos;
        stream.skipToPair('(', ')');
        var fnBody = stream.current();
        result.push(range.create(clone.start + stream.start, fnBody));

        // find parts
        _.each(cssEditTree.findParts(fnBody), function(part) {
          result.push(range.create(clone.start + stream.start + part.start, part.substring(fnBody)));
        });
      }
    });

    // optimize result: remove empty ranges and duplicates
    return _.chain(result)
      .filter(function(item) {
        return !!item.length();
      })
      .uniq(false, function(item) {
        return item.toString();
      })
      .value();
  }

  /**
   * Tries to find matched CSS property and nearest range for selection
   * @param {CSSRule} rule
   * @param {Range} selRange
   * @param {Boolean} isBackward
   * @returns {Range}
   */
  function matchedRangeForCSSProperty(rule, selRange, isBackward) {
    /** @type CSSProperty */
    var property = null;
    var possibleRanges, curRange = null, ix;
    var list = rule.list();
    var searchFn, nearestItemFn;

    if (isBackward) {
      list.reverse();
      searchFn = function(p) {
        return p.range(true).start <= selRange.start;
      };
      nearestItemFn = function(r) {
        return r.start < selRange.start;
      };
    } else {
      searchFn = function(p) {
        return p.range(true).end >= selRange.end;
      };
      nearestItemFn = function(r) {
        return r.end > selRange.start;
      };
    }

    // search for nearest to selection CSS property
    while (property = _.find(list, searchFn)) {
      possibleRanges = makePossibleRangesCSS(property);
      if (isBackward)
        possibleRanges.reverse();

      // check if any possible range is already selected
      curRange = _.find(possibleRanges, function(r) {
        return r.equal(selRange);
      });

      if (!curRange) {
        // no selection, select nearest item
        var matchedRanges = _.filter(possibleRanges, function(r) {
          return r.inside(selRange.end);
        });

        if (matchedRanges.length > 1) {
          curRange = matchedRanges[1];
          break;
        }

        if (curRange = _.find(possibleRanges, nearestItemFn))
          break;
      } else {
        ix = _.indexOf(possibleRanges, curRange);
        if (ix != possibleRanges.length - 1) {
          curRange = possibleRanges[ix + 1];
          break;
        }
      }

      curRange = null;
      selRange.start = selRange.end = isBackward
        ? property.range(true).start - 1
        : property.range(true).end + 1;
    }

    return curRange;
  }

  function findNextCSSItem(editor) {
    return findItem(editor, false, require('cssEditTree').extractRule, getRangeForNextItemInCSS);
  }

  function findPrevCSSItem(editor) {
    return findItem(editor, true, require('cssEditTree').extractRule, getRangeForPrevItemInCSS);
  }

  /**
   * Returns range for item to be selected in CSS after current caret
   * (selection) position
   * @param {String} rule CSS rule declaration
   * @param {Number} offset Rule's position index inside content
   * @param {Range} selRange Selection range
   * @return {Range} Returns range if next item was found, <code>null</code> otherwise
   */
  function getRangeForNextItemInCSS(rule, offset, selRange) {
    var tree = require('cssEditTree').parse(rule, {
      offset: offset
    });

    // check if selector is matched
    var range = tree.nameRange(true);
    if (selRange.end < range.end) {
      return range;
    }

    return matchedRangeForCSSProperty(tree, selRange, false);
  }

  /**
   * Returns range for item to be selected in CSS before current caret
   * (selection) position
   * @param {String} rule CSS rule declaration
   * @param {Number} offset Rule's position index inside content
   * @param {Range} selRange Selection range
   * @return {Range} Returns range if previous item was found, <code>null</code> otherwise
   */
  function getRangeForPrevItemInCSS(rule, offset, selRange) {
    var tree = require('cssEditTree').parse(rule, {
      offset: offset
    });

    var curRange = matchedRangeForCSSProperty(tree, selRange, true);

    if (!curRange) {
      // no matched property, try to match selector
      var range = tree.nameRange(true);
      if (selRange.start > range.start) {
        return range;
      }
    }

    return curRange;
  }

  // XXX register actions
  var actions = require('actions');
  actions.add('select_next_item', function(editor){
    if (editor.getSyntax() == 'css')
      return findNextCSSItem(editor);
    else
      return findNextHTMLItem(editor);
  });

  actions.add('select_previous_item', function(editor){
    if (editor.getSyntax() == 'css')
      return findPrevCSSItem(editor);
    else
      return findPrevHTMLItem(editor);
  });
});/**
 * HTML pair matching (balancing) actions
 * @constructor
 * @memberOf __matchPairActionDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  /** @type emmet.actions */
  var actions = require('actions');
  var matcher = require('htmlMatcher');
  var lastMatch = null;

  /**
   * Find and select HTML tag pair
   * @param {IEmmetEditor} editor Editor instance
   * @param {String} direction Direction of pair matching: 'in' or 'out'.
   * Default is 'out'
   */
  function matchPair(editor, direction) {
    direction = String((direction || 'out').toLowerCase());
    var info = require('editorUtils').outputInfo(editor);

    var range = require('range');
    /** @type Range */
    var sel = range.create(editor.getSelectionRange());
    var content = info.content;

    // validate previous match
    if (lastMatch && !lastMatch.range.equal(sel)) {
      lastMatch = null;
    }

    if (lastMatch && sel.length()) {
      if (direction == 'in') {
        // user has previously selected tag and wants to move inward
        if (lastMatch.type == 'tag' && !lastMatch.close) {
          // unary tag was selected, can't move inward
          return false;
        } else {
          if (lastMatch.range.equal(lastMatch.outerRange)) {
            lastMatch.range = lastMatch.innerRange;
          } else {
            var narrowed = require('utils').narrowToNonSpace(content, lastMatch.innerRange);
            lastMatch = matcher.find(content, narrowed.start + 1);
            if (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {
              lastMatch.range = lastMatch.innerRange;
            }
          }
        }
      } else {
        if (
            !lastMatch.innerRange.equal(lastMatch.outerRange)
            && lastMatch.range.equal(lastMatch.innerRange)
            && sel.equal(lastMatch.range)) {
          lastMatch.range = lastMatch.outerRange;
        } else {
          lastMatch = matcher.find(content, sel.start);
          if (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {
            lastMatch.range = lastMatch.outerRange;
          }
        }
      }
    } else {
      lastMatch = matcher.find(content, sel.start);
    }

    if (lastMatch && !lastMatch.range.equal(sel)) {
      editor.createSelection(lastMatch.range.start, lastMatch.range.end);
      return true;
    }

    lastMatch = null;
    return false;
  }

  actions.add('match_pair', matchPair, {hidden: true});
  actions.add('match_pair_inward', function(editor){
    return matchPair(editor, 'in');
  }, {label: 'HTML/Match Pair Tag (inward)'});

  actions.add('match_pair_outward', function(editor){
    return matchPair(editor, 'out');
  }, {label: 'HTML/Match Pair Tag (outward)'});

  /**
   * Moves caret to matching opening or closing tag
   * @param {IEmmetEditor} editor
   */
  actions.add('matching_pair', function(editor) {
    var content = String(editor.getContent());
    var caretPos = editor.getCaretPos();

    if (content.charAt(caretPos) == '<')
      // looks like caret is outside of tag pair
      caretPos++;

    var tag = matcher.tag(content, caretPos);
    if (tag && tag.close) { // exclude unary tags
      if (tag.open.range.inside(caretPos)) {
        editor.setCaretPos(tag.close.range.start);
      } else {
        editor.setCaretPos(tag.open.range.start);
      }

      return true;
    }

    return false;
  }, {label: 'HTML/Go To Matching Tag Pair'});
});/**
 * Gracefully removes tag under cursor
 *
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  require('actions').add('remove_tag', function(editor) {
    var utils = require('utils');
    var info = require('editorUtils').outputInfo(editor);

    // search for tag
    var tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());
    if (tag) {
      if (!tag.close) {
        // simply remove unary tag
        editor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);
      } else {
        // remove tag and its newlines
        /** @type Range */
        var tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);
        /** @type Range */
        var startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);
        var startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));
        var tagContent = tagContentRange.substring(info.content);

        tagContent = utils.unindentString(tagContent, startLinePad);
        editor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);
      }

      return true;
    }

    return false;
  }, {label: 'HTML/Remove Tag'});
});
/**
 * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>
 * &lt;div&gt;&lt;/div&gt; â†’ &lt;div /&gt; : join<br>
 * &lt;div /&gt; â†’ &lt;div&gt;&lt;/div&gt; : split
 * @param {Function} require
 * @param {Underscore} _
 * @memberOf __splitJoinTagAction
 * @constructor
 */
emmet.exec(function(require, _) {
  /**
   * @param {IEmmetEditor} editor
   * @param {Object} profile
   * @param {Object} tag
   */
  function joinTag(editor, profile, tag) {
    /** @type emmet.utils */
    var utils = require('utils');

    // empty closing slash is a nonsense for this action
    var slash = profile.selfClosing() || ' /';
    var content = tag.open.range.substring(tag.source).replace(/\s*>$/, slash + '>');

    var caretPos = editor.getCaretPos();

    // update caret position
    if (content.length + tag.outerRange.start < caretPos) {
      caretPos = content.length + tag.outerRange.start;
    }

    content = utils.escapeText(content);
    editor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);
    editor.setCaretPos(caretPos);
    return true;
  }

  function splitTag(editor, profile, tag) {
    /** @type emmet.utils */
    var utils = require('utils');

    var nl = utils.getNewline();
    var pad = require('resources').getVariable('indentation');
    var caretPos = editor.getCaretPos();

    // define tag content depending on profile
    var tagContent = (profile.tag_nl === true) ? nl + pad + nl : '';
    var content = tag.outerContent().replace(/\s*\/>$/, '>');
    caretPos = tag.outerRange.start + content.length;
    content += tagContent + '</' + tag.open.name + '>';

    content = utils.escapeText(content);
    editor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);
    editor.setCaretPos(caretPos);
    return true;
  }

  require('actions').add('split_join_tag', function(editor, profileName) {
    var matcher = require('htmlMatcher');

    var info = require('editorUtils').outputInfo(editor, null, profileName);
    var profile = require('profile').get(info.profile);

    // find tag at current position
    var tag = matcher.tag(info.content, editor.getCaretPos());
    if (tag) {
      return tag.close
        ? joinTag(editor, profile, tag)
        : splitTag(editor, profile, tag);
    }

    return false;
  }, {label: 'HTML/Split\\Join Tag Declaration'});
});/**
 * Reflect CSS value: takes rule's value under caret and pastes it for the same
 * rules with vendor prefixes
 * @constructor
 * @memberOf __reflectCSSActionDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('reflectCSSValue', function(require, _) {
  /**
   * @type HandlerList List of registered handlers
   */
  var handlers = require('handlerList').create();

  require('actions').add('reflect_css_value', function(editor) {
    if (editor.getSyntax() != 'css') return false;

    return require('actionUtils').compoundUpdate(editor, doCSSReflection(editor));
  }, {label: 'CSS/Reflect Value'});

  function doCSSReflection(editor) {
    /** @type emmet.cssEditTree */
    var cssEditTree = require('cssEditTree');
    var outputInfo = require('editorUtils').outputInfo(editor);
    var caretPos = editor.getCaretPos();

    var cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);
    if (!cssRule) return;

    var property = cssRule.itemFromPosition(caretPos, true);
    // no property under cursor, nothing to reflect
    if (!property) return;

    var oldRule = cssRule.source;
    var offset = cssRule.options.offset;
    var caretDelta = caretPos - offset - property.range().start;

    handlers.exec(false, [property]);

    if (oldRule !== cssRule.source) {
      return {
        data:  cssRule.source,
        start: offset,
        end:   offset + oldRule.length,
        caret: offset + property.range().start + caretDelta
      };
    }
  }

  /**
   * Returns regexp that should match reflected CSS property names
   * @param {String} name Current CSS property name
   * @return {RegExp}
   */
  function getReflectedCSSName(name) {
    name = require('cssEditTree').baseName(name);
    var vendorPrefix = '^(?:\\-\\w+\\-)?', m;

    if (name == 'opacity' || name == 'filter') {
      return new RegExp(vendorPrefix + '(?:opacity|filter)$');
    } else if (m = name.match(/^border-radius-(top|bottom)(left|right)/)) {
      // Mozilla-style border radius
      return new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');
    } else if (m = name.match(/^border-(top|bottom)-(left|right)-radius/)) {
      return new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');
    }

    return new RegExp(vendorPrefix + name + '$');
  }

  /**
   * Reflects value from <code>donor</code> into <code>receiver</code>
   * @param {CSSProperty} donor Donor CSS property from which value should
   * be reflected
   * @param {CSSProperty} receiver Property that should receive reflected
   * value from donor
   */
  function reflectValue(donor, receiver) {
    var value = getReflectedValue(donor.name(), donor.value(),
        receiver.name(), receiver.value());

    receiver.value(value);
  }

  /**
   * Returns value that should be reflected for <code>refName</code> CSS property
   * from <code>curName</code> property. This function is used for special cases,
   * when the same result must be achieved with different properties for different
   * browsers. For example: opÐ°city:0.5; â†’ filter:alpha(opacity=50);<br><br>
   *
   * This function does value conversion between different CSS properties
   *
   * @param {String} curName Current CSS property name
   * @param {String} curValue Current CSS property value
   * @param {String} refName Receiver CSS property's name
   * @param {String} refValue Receiver CSS property's value
   * @return {String} New value for receiver property
   */
  function getReflectedValue(curName, curValue, refName, refValue) {
    var cssEditTree = require('cssEditTree');
    var utils = require('utils');
    curName = cssEditTree.baseName(curName);
    refName = cssEditTree.baseName(refName);

    if (curName == 'opacity' && refName == 'filter') {
      return refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));
    } else if (curName == 'filter' && refName == 'opacity') {
      var m = curValue.match(/opacity=([^)]*)/i);
      return m ? utils.prettifyNumber(parseInt(m[1]) / 100) : refValue;
    }

    return curValue;
  }

  // XXX add default handler
  handlers.add(function(property) {
    var reName = getReflectedCSSName(property.name());
    _.each(property.parent.list(), function(p) {
      if (reName.test(p.name())) {
        reflectValue(property, p);
      }
    });
  }, {order: -1});

  return {
    /**
     * Adds custom reflect handler. The passed function will receive matched
     * CSS property (as <code>CSSEditElement</code> object) and should
     * return <code>true</code> if it was performed successfully (handled
     * reflection), <code>false</code> otherwise.
     * @param {Function} fn
     * @param {Object} options
     */
    addHandler: function(fn, options) {
      handlers.add(fn, options);
    },

    /**
     * Removes registered handler
     * @returns
     */
    removeHandler: function(fn) {
      handlers.remove(fn, options);
    }
  };
});/**
 * Evaluates simple math expression under caret
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  require('actions').add('evaluate_math_expression', function(editor) {
    var actionUtils = require('actionUtils');
    var utils = require('utils');

    var content = String(editor.getContent());
    var chars = '.+-*/\\';

    /** @type Range */
    var sel = require('range').create(editor.getSelectionRange());
    if (!sel.length()) {
      sel = actionUtils.findExpressionBounds(editor, function(ch) {
        return utils.isNumeric(ch) || chars.indexOf(ch) != -1;
      });
    }

    if (sel && sel.length()) {
      var expr = sel.substring(content);

      // replace integral division: 11\2 => Math.round(11/2)
      expr = expr.replace(/([\d\.\-]+)\\([\d\.\-]+)/g, 'Math.round($1/$2)');

      try {
        var result = utils.prettifyNumber(new Function('return ' + expr)());
        editor.replaceContent(result, sel.start, sel.end);
        editor.setCaretPos(sel.start + result.length);
        return true;
      } catch (e) {}
    }

    return false;
  }, {label: 'Numbers/Evaluate Math Expression'});
});
/**
 * Increment/decrement number under cursor
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  /**
   * Extract number from current caret position of the <code>editor</code> and
   * increment it by <code>step</code>
   * @param {IEmmetEditor} editor
   * @param {Number} step Increment step (may be negative)
   */
  function incrementNumber(editor, step) {
    var utils = require('utils');
    var actionUtils = require('actionUtils');

    var hasSign = false;
    var hasDecimal = false;

    var r = actionUtils.findExpressionBounds(editor, function(ch, pos, content) {
      if (utils.isNumeric(ch))
        return true;
      if (ch == '.') {
        // make sure that next character is numeric too
        if (!utils.isNumeric(content.charAt(pos + 1)))
          return false;

        return hasDecimal ? false : hasDecimal = true;
      }
      if (ch == '-')
        return hasSign ? false : hasSign = true;

      return false;
    });

    if (r && r.length()) {
      var strNum = r.substring(String(editor.getContent()));
      var num = parseFloat(strNum);
      if (!_.isNaN(num)) {
        num = utils.prettifyNumber(num + step);

        // do we have zero-padded number?
        if (/^(\-?)0+[1-9]/.test(strNum)) {
          var minus = '';
          if (RegExp.$1) {
            minus = '-';
            num = num.substring(1);
          }

          var parts = num.split('.');
          parts[0] = utils.zeroPadString(parts[0], intLength(strNum));
          num = minus + parts.join('.');
        }

        editor.replaceContent(num, r.start, r.end);
        editor.createSelection(r.start, r.start + num.length);
        return true;
      }
    }

    return false;
  }

  /**
   * Returns length of integer part of number
   * @param {String} num
   */
  function intLength(num) {
    num = num.replace(/^\-/, '');
    if (~num.indexOf('.')) {
      return num.split('.')[0].length;
    }

    return num.length;
  }

  var actions = require('actions');
  _.each([1, -1, 10, -10, 0.1, -0.1], function(num) {
    var prefix = num > 0 ? 'increment' : 'decrement';

    actions.add(prefix + '_number_by_' + String(Math.abs(num)).replace('.', '').substring(0, 2), function(editor) {
      return incrementNumber(editor, num);
    }, {label: 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num)});
  });
});/**
 * Actions to insert line breaks. Some simple editors (like browser's
 * &lt;textarea&gt;, for example) do not provide such simple things
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  var actions = require('actions');
  /** @type emmet.preferences */
  var prefs = require('preferences');

  // setup default preferences
  prefs.define('css.closeBraceIndentation', '\n',
      'Indentation before closing brace of CSS rule. Some users prefere '
      + 'indented closing brace of CSS rule for better readability. '
      + 'This preferenceâ€™s value will be automatically inserted before '
      + 'closing brace when user adds newline in newly created CSS rule '
      + '(e.g. when â€œInsert formatted linebreakâ€ action will be performed '
      + 'in CSS file). If youâ€™re such user, you may want to write put a value '
      + 'like <code>\\n\\t</code> in this preference.');

  /**
   * Inserts newline character with proper indentation in specific positions only.
   * @param {IEmmetEditor} editor
   * @return {Boolean} Returns <code>true</code> if line break was inserted
   */
  actions.add('insert_formatted_line_break_only', function(editor) {
    var utils = require('utils');
    /** @type emmet.resources */
    var res = require('resources');

    var info = require('editorUtils').outputInfo(editor);
    var caretPos = editor.getCaretPos();
    var nl = utils.getNewline();

    if (_.include(['html', 'xml', 'xsl'], info.syntax)) {
      var pad = res.getVariable('indentation');
      // let's see if we're breaking newly created tag
      var tag = require('htmlMatcher').tag(info.content, caretPos);
      if (tag && !tag.innerRange.length()) {
        editor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);
        return true;
      }
    } else if (info.syntax == 'css') {
      /** @type String */
      var content = info.content;
      if (caretPos && content.charAt(caretPos - 1) == '{') {
        var append = prefs.get('css.closeBraceIndentation');
        var pad = res.getVariable('indentation');

        var hasCloseBrace = content.charAt(caretPos) == '}';
        if (!hasCloseBrace) {
          // do we really need special formatting here?
          // check if this is really a newly created rule,
          // look ahead for a closing brace
          for (var i = caretPos, il = content.length, ch; i < il; i++) {
            ch = content.charAt(i);
            if (ch == '{') {
              // ok, this is a new rule without closing brace
              break;
            }

            if (ch == '}') {
              // not a new rule, just add indentation
              append = '';
              hasCloseBrace = true;
              break;
            }
          }
        }

        if (!hasCloseBrace) {
          append += '}';
        }

        // defining rule set
        var insValue = nl + pad + utils.getCaretPlaceholder() + append;
        editor.replaceContent(insValue, caretPos);
        return true;
      }
    }

    return false;
  }, {hidden: true});

  /**
   * Inserts newline character with proper indentation. This action is used in
   * editors that doesn't have indentation control (like textarea element) to
   * provide proper indentation
   * @param {IEmmetEditor} editor Editor instance
   */
  actions.add('insert_formatted_line_break', function(editor) {
    if (!actions.run('insert_formatted_line_break_only', editor)) {
      var utils = require('utils');

      var curPadding = require('editorUtils').getCurrentLinePadding(editor);
      var content = String(editor.getContent());
      var caretPos = editor.getCaretPos();
      var len = content.length;
      var nl = utils.getNewline();

      // check out next line padding
      var lineRange = editor.getCurrentLineRange();
      var nextPadding = '';

      for (var i = lineRange.end + 1, ch; i < len; i++) {
        ch = content.charAt(i);
        if (ch == ' ' || ch == '\t')
          nextPadding += ch;
        else
          break;
      }

      if (nextPadding.length > curPadding.length)
        editor.replaceContent(nl + nextPadding, caretPos, caretPos, true);
      else
        editor.replaceContent(nl, caretPos);
    }

    return true;
  }, {hidden: true});
});/**
 * Merges selected lines or lines between XHTML tag pairs
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  require('actions').add('merge_lines', function(editor) {
    var matcher = require('htmlMatcher');
    var utils = require('utils');
    var editorUtils = require('editorUtils');
    var info = editorUtils.outputInfo(editor);

    /** @type Range */
    var selection = require('range').create(editor.getSelectionRange());
    if (!selection.length()) {
      // find matching tag
      var pair = matcher.find(info.content, editor.getCaretPos());
      if (pair) {
        selection = pair.outerRange;
      }
    }

    if (selection.length()) {
      // got range, merge lines
      var text =  selection.substring(info.content);
      var lines = utils.splitByLines(text);

      for (var i = 1; i < lines.length; i++) {
        lines[i] = lines[i].replace(/^\s+/, '');
      }

      text = lines.join('').replace(/\s{2,}/, ' ');
      var textLen = text.length;
      text = utils.escapeText(text);
      editor.replaceContent(text, selection.start, selection.end);
      editor.createSelection(selection.start, selection.start + textLen);

      return true;
    }

    return false;
  });
});/**
 * Encodes/decodes image under cursor to/from base64
 * @param {IEmmetEditor} editor
 * @since 0.65
 *
 * @memberOf __base64ActionDefine
 * @constructor
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  require('actions').add('encode_decode_data_url', function(editor) {
    var data = String(editor.getSelection());
    var caretPos = editor.getCaretPos();

    if (!data) {
      // no selection, try to find image bounds from current caret position
      var text = String(editor.getContent()),  m;
      while (caretPos-- >= 0) {
        if (startsWith('src=', text, caretPos)) { // found <img src="">
          if (m = text.substr(caretPos).match(/^(src=(["'])?)([^'"<>\s]+)\1?/)) {
            data = m[3];
            caretPos += m[1].length;
          }
          break;
        } else if (startsWith('url(', text, caretPos)) { // found CSS url() pattern
          if (m = text.substr(caretPos).match(/^(url\((['"])?)([^'"\)\s]+)\1?/)) {
            data = m[3];
            caretPos += m[1].length;
          }
          break;
        }
      }
    }

    if (data) {
      if (startsWith('data:', data))
        return decodeFromBase64(editor, data, caretPos);
      else
        return encodeToBase64(editor, data, caretPos);
    }

    return false;
  }, {label: 'Encode\\Decode data:URL image'});

  /**
   * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>
   * position. If <code>pos</code> is omitted, search from beginning of text
   * @param {String} token Token to test
   * @param {String} text Where to search
   * @param {Number} pos Position where to start search
   * @return {Boolean}
   * @since 0.65
   */
  function startsWith(token, text, pos) {
    pos = pos || 0;
    return text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;
  }

  /**
   * Encodes image to base64
   *
   * @param {IEmmetEditor} editor
   * @param {String} imgPath Path to image
   * @param {Number} pos Caret position where image is located in the editor
   * @return {Boolean}
   */
  function encodeToBase64(editor, imgPath, pos) {
    var file = require('file');
    var actionUtils = require('actionUtils');

    var editorFile = editor.getFilePath();
    var defaultMimeType = 'application/octet-stream';

    if (editorFile === null) {
      throw "You should save your file before using this action";
    }

    // locate real image path
    var realImgPath = file.locateFile(editorFile, imgPath);
    if (realImgPath === null) {
      throw "Can't find " + imgPath + ' file';
    }

    file.read(realImgPath, function(err, content) {
      if (err) {
        throw 'Unable to read ' + realImgPath + ': ' + err;
      }

      var b64 = require('base64').encode(String(content));
      if (!b64) {
        throw "Can't encode file content to base64";
      }

      b64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) +
        ';base64,' + b64;

      editor.replaceContent('$0' + b64, pos, pos + imgPath.length);
    });


    return true;
  }

  /**
   * Decodes base64 string back to file.
   * @param {IEmmetEditor} editor
   * @param {String} data Base64-encoded file content
   * @param {Number} pos Caret position where image is located in the editor
   */
  function decodeFromBase64(editor, data, pos) {
    // ask user to enter path to file
    var filePath = String(editor.prompt('Enter path to file (absolute or relative)'));
    if (!filePath)
      return false;

    var file = require('file');
    var absPath = file.createPath(editor.getFilePath(), filePath);
    if (!absPath) {
      throw "Can't save file";
    }

    file.save(absPath, require('base64').decode( data.replace(/^data\:.+?;.+?,/, '') ));
    editor.replaceContent('$0' + filePath, pos, pos + data.length);
    return true;
  }
});
/**
 * Automatically updates image size attributes in HTML's &lt;img&gt; element or
 * CSS rule
 * @param {Function} require
 * @param {Underscore} _
 * @constructor
 * @memberOf __updateImageSizeAction
 */
emmet.exec(function(require, _) {
  /**
   * Updates image size of &lt;img src=""&gt; tag
   * @param {IEmmetEditor} editor
   */
  function updateImageSizeHTML(editor) {
    var offset = editor.getCaretPos();

    // find tag from current caret position
    var info = require('editorUtils').outputInfo(editor);
    var xmlElem = require('xmlEditTree').parseFromPosition(info.content, offset, true);
    if (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {
      getImageSizeForSource(editor, xmlElem.value('src'), function(size) {
        if (size) {
          var compoundData = xmlElem.range(true);
          xmlElem.value('width', size.width);
          xmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);

          require('actionUtils').compoundUpdate(editor, _.extend(compoundData, {
            data: xmlElem.toString(),
            caret: offset
          }));
        }
      });
    }
  }

  /**
   * Updates image size of CSS property
   * @param {IEmmetEditor} editor
   */
  function updateImageSizeCSS(editor) {
    var offset = editor.getCaretPos();

    // find tag from current caret position
    var info = require('editorUtils').outputInfo(editor);
    var cssRule = require('cssEditTree').parseFromPosition(info.content, offset, true);
    if (cssRule) {
      // check if there is property with image under caret
      var prop = cssRule.itemFromPosition(offset, true), m;
      if (prop && (m = /url\((["']?)(.+?)\1\)/i.exec(prop.value() || ''))) {
        getImageSizeForSource(editor, m[2], function(size) {
          if (size) {
            var compoundData = cssRule.range(true);
            cssRule.value('width', size.width + 'px');
            cssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);

            require('actionUtils').compoundUpdate(editor, _.extend(compoundData, {
              data: cssRule.toString(),
              caret: offset
            }));
          }
        });
      }
    }
  }

  /**
   * Returns image dimensions for source
   * @param {IEmmetEditor} editor
   * @param {String} src Image source (path or data:url)
   */
  function getImageSizeForSource(editor, src, callback) {
    var fileContent;
    var au = require('actionUtils');
    if (src) {
      // check if it is data:url
      if (/^data:/.test(src)) {
        fileContent = require('base64').decode( src.replace(/^data\:.+?;.+?,/, '') );
        return callback(au.getImageSize(fileContent));
      }

      var file = require('file');
      var absPath = file.locateFile(editor.getFilePath(), src);
      if (absPath === null) {
        throw "Can't find " + src + ' file';
      }

      file.read(absPath, function(err, content) {
        if (err) {
          throw 'Unable to read ' + absPath + ': ' + err;
        }

        content = String(content);
        callback(au.getImageSize(content));
      });
    }
  }

  require('actions').add('update_image_size', function(editor) {
    // this action will definitely wonâ€™t work in SASS dialect,
    // but may work in SCSS or LESS
    if (_.include(['css', 'less', 'scss'], String(editor.getSyntax()))) {
      updateImageSizeCSS(editor);
    } else {
      updateImageSizeHTML(editor);
    }

    return true;
  });
});/**
 * Resolver for fast CSS typing. Handles abbreviations with the following
 * notation:<br>
 *
 * <code>(-vendor prefix)?property(value)*(!)?</code>
 *
 * <br><br>
 * <b>Abbreviation handling</b><br>
 *
 * By default, Emmet searches for matching snippet definition for provided abbreviation.
 * If snippet wasn't found, Emmet automatically generates element with
 * abbreviation's name. For example, <code>foo</code> abbreviation will generate
 * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.
 * <br><br>
 * This module will capture all expanded properties and upgrade them with values,
 * vendor prefixes and !important declarations. All unmatched abbreviations will
 * be automatically transformed into <code>property-name: ${1}</code> snippets.
 *
 * <b>Vendor prefixes<b><br>
 *
 * If CSS-property is preceded with dash, resolver should output property with
 * all <i>known</i> vendor prefixes. For example, if <code>brad</code>
 * abbreviation generates <code>border-radius: ${value};</code> snippet,
 * the <code>-brad</code> abbreviation should generate:
 * <pre><code>
 * -webkit-border-radius: ${value};
 * -moz-border-radius: ${value};
 * border-radius: ${value};
 * </code></pre>
 * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE
 * supports unprefixed property.<br><br>
 *
 * Users can also provide an explicit list of one-character prefixes for any
 * CSS property. For example, <code>-wm-float</code> will produce
 *
 * <pre><code>
 * -webkit-float: ${1};
 * -moz-float: ${1};
 * float: ${1};
 * </code></pre>
 *
 * Although this example looks pointless, users can use this feature to write
 * cutting-edge properties implemented by browser vendors recently.
 *
 * @constructor
 * @memberOf __cssResolverDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('cssResolver', function(require, _) {
  /** Back-reference to module */
  var module = null;

  var prefixObj = {
    /** Real vendor prefix name */
    prefix: 'emmet',

    /**
     * Indicates this prefix is obsolete and should't be used when user
     * wants to generate all-prefixed properties
     */
    obsolete: false,

    /**
     * Returns prefixed CSS property name
     * @param {String} name Unprefixed CSS property
     */
    transformName: function(name) {
      return '-' + this.prefix + '-' + name;
    },

    /**
     * List of unprefixed CSS properties that supported by
     * current prefix. This list is used to generate all-prefixed property
     * @returns {Array}
     */
    properties: function() {
      return getProperties('css.' + this.prefix + 'Properties') || [];
    },

    /**
     * Check if given property is supported by current prefix
     * @param name
     */
    supports: function(name) {
      return _.include(this.properties(), name);
    }
  };


  /**
   * List of registered one-character prefixes. Key is a one-character prefix,
   * value is an <code>prefixObj</code> object
   */
  var vendorPrefixes = {};

  var defaultValue = '${1};';

  // XXX module preferences
  var prefs = require('preferences');
  prefs.define('css.valueSeparator', ': ',
      'Defines a symbol that should be placed between CSS property and '
      + 'value when expanding CSS abbreviations.');
  prefs.define('css.propertyEnd', ';',
      'Defines a symbol that should be placed at the end of CSS property  '
      + 'when expanding CSS abbreviations.');

  prefs.define('stylus.valueSeparator', ' ',
      'Defines a symbol that should be placed between CSS property and '
      + 'value when expanding CSS abbreviations in Stylus dialect.');
  prefs.define('stylus.propertyEnd', '',
      'Defines a symbol that should be placed at the end of CSS property  '
      + 'when expanding CSS abbreviations in Stylus dialect.');

  prefs.define('sass.propertyEnd', '',
      'Defines a symbol that should be placed at the end of CSS property  '
      + 'when expanding CSS abbreviations in SASS dialect.');

  prefs.define('css.autoInsertVendorPrefixes', true,
      'Automatically generate vendor-prefixed copies of expanded CSS '
      + 'property. By default, Emmet will generate vendor-prefixed '
      + 'properties only when you put dash before abbreviation '
      + '(e.g. <code>-bxsh</code>). With this option enabled, you donâ€™t '
      + 'need dashes before abbreviations: Emmet will produce '
      + 'vendor-prefixed properties for you.');

  var descTemplate = _.template('A comma-separated list of CSS properties that may have '
    + '<code><%= vendor %></code> vendor prefix. This list is used to generate '
    + 'a list of prefixed properties when expanding <code>-property</code> '
    + 'abbreviations. Empty list means that all possible CSS values may '
    + 'have <code><%= vendor %></code> prefix.');

  var descAddonTemplate = _.template('A comma-separated list of <em>additional</em> CSS properties '
      + 'for <code>css.<%= vendor %>Preperties</code> preference. '
      + 'You should use this list if you want to add or remove a few CSS '
      + 'properties to original set. To add a new property, simply write its name, '
      + 'to remove it, precede property with hyphen.<br>'
      + 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, '
      + 'the preference value will look like this: <code>foo, -border-radius</code>.');

  // properties list is created from cssFeatures.html file
  var props = {
    'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',
    'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',
    'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, word-wrap, wrap-flow, wrap-margin, wrap-through, writing-mode',
    'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'
  };

  _.each(props, function(v, k) {
    prefs.define('css.' + k + 'Properties', v, descTemplate({vendor: k}));
    prefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({vendor: k}));
  });

  prefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom',
      'The list of properties whose values â€‹â€‹must not contain units.');

  prefs.define('css.intUnit', 'px', 'Default unit for integer values');
  prefs.define('css.floatUnit', 'em', 'Default unit for float values');

  prefs.define('css.keywords', 'auto, inherit',
      'A comma-separated list of valid keywords that can be used in CSS abbreviations.');

  prefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent',
      'A comma-separated list of keyword aliases, used in CSS abbreviation. '
      + 'Each alias should be defined as <code>alias:keyword_name</code>.');

  prefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem',
      'A comma-separated list of unit aliases, used in CSS abbreviation. '
      + 'Each alias should be defined as <code>alias:unit_value</code>.');

  prefs.define('css.color.short', true,
      'Should color values like <code>#ffffff</code> be shortened to '
      + '<code>#fff</code> after abbreviation with color was expanded.');

  prefs.define('css.color.case', 'keep',
      'Letter case of color values generated by abbreviations with color '
      + '(like <code>c#0</code>). Possible values are <code>upper</code>, '
      + '<code>lower</code> and <code>keep</code>.');

  prefs.define('css.fuzzySearch', true,
      'Enable fuzzy search among CSS snippet names. When enabled, every '
      + '<em>unknown</em> snippet will be scored against available snippet '
      + 'names (not values or CSS properties!). The match with best score '
      + 'will be used to resolve snippet value. For example, with this '
      + 'preference enabled, the following abbreviations are equal: '
      + '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '
      + '<code>oh</code>');

  prefs.define('css.fuzzySearchMinScore', 0.3,
      'The minium score (from 0 to 1) that fuzzy-matched abbreviation should '
      + 'achive. Lower values may produce many false-positive matches, '
      + 'higher values may reduce possible matches.');

  prefs.define('css.alignVendor', false,
      'If set to <code>true</code>, all generated vendor-prefixed properties '
      + 'will be aligned by real property name.');


  function isNumeric(ch) {
    var code = ch && ch.charCodeAt(0);
    return (ch && ch == '.' || (code > 47 && code < 58));
  }

  /**
   * Check if provided snippet contains only one CSS property and value.
   * @param {String} snippet
   * @returns {Boolean}
   */
  function isSingleProperty(snippet) {
    var utils = require('utils');
    snippet = utils.trim(snippet);

    // check if it doesn't contain a comment and a newline
    if (~snippet.indexOf('/*') || /[\n\r]/.test(snippet)) {
      return false;
    }

    // check if it's a valid snippet definition
    if (!/^[a-z0-9\-]+\s*\:/i.test(snippet)) {
      return false;
    }

    snippet = require('tabStops').processText(snippet, {
      replaceCarets: true,
      tabstop: function() {
        return 'value';
      }
    });

    return snippet.split(':').length == 2;
  }

  /**
   * Normalizes abbreviated value to final CSS one
   * @param {String} value
   * @returns {String}
   */
  function normalizeValue(value) {
    if (value.charAt(0) == '-' && !/^\-[\.\d]/.test(value)) {
      value = value.replace(/^\-+/, '');
    }

    if (value.charAt(0) == '#') {
      return normalizeHexColor(value);
    }

    return getKeyword(value);
  }

  function normalizeHexColor(value) {
    var hex = value.replace(/^#+/, '') || '0';
    if (hex.toLowerCase() == 't') {
      return 'transparent';
    }

    var repeat = require('utils').repeatString;
    var color = null;
    switch (hex.length) {
      case 1:
        color = repeat(hex, 6);
        break;
      case 2:
        color = repeat(hex, 3);
        break;
      case 3:
        color = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
        break;
      case 4:
        color = hex + hex.substr(0, 2);
        break;
      case 5:
        color = hex + hex.charAt(0);
        break;
      default:
        color = hex.substr(0, 6);
    }

    // color must be shortened?
    if (prefs.get('css.color.short')) {
      var p = color.split('');
      if (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {
        color = p[0] + p[2] + p[4];
      }
    }

    // should transform case?
    switch (prefs.get('css.color.case')) {
      case 'upper':
        color = color.toUpperCase();
        break;
      case 'lower':
        color = color.toLowerCase();
        break;
    }

    return '#' + color;
  }

  function getKeyword(name) {
    var aliases = prefs.getDict('css.keywordAliases');
    return name in aliases ? aliases[name] : name;
  }

  function getUnit(name) {
    var aliases = prefs.getDict('css.unitAliases');
    return name in aliases ? aliases[name] : name;
  }

  function isValidKeyword(keyword) {
    return _.include(prefs.getArray('css.keywords'), getKeyword(keyword));
  }

  /**
   * Check if passed CSS property support specified vendor prefix
   * @param {String} property
   * @param {String} prefix
   */
  function hasPrefix(property, prefix) {
    var info = vendorPrefixes[prefix];

    if (!info)
      info = _.find(vendorPrefixes, function(data) {
        return data.prefix == prefix;
      });

    return info && info.supports(property);
  }

  /**
   * Search for a list of supported prefixes for CSS property. This list
   * is used to generate all-prefixed snippet
   * @param {String} property CSS property name
   * @returns {Array}
   */
  function findPrefixes(property, noAutofill) {
    var result = [];
    _.each(vendorPrefixes, function(obj, prefix) {
      if (hasPrefix(property, prefix)) {
        result.push(prefix);
      }
    });

    if (!result.length && !noAutofill) {
      // add all non-obsolete prefixes
      _.each(vendorPrefixes, function(obj, prefix) {
        if (!obj.obsolete)
          result.push(prefix);
      });
    }

    return result;
  }

  function addPrefix(name, obj) {
    if (_.isString(obj))
      obj = {prefix: obj};

    vendorPrefixes[name] = _.extend({}, prefixObj, obj);
  }

  function getSyntaxPreference(name, syntax) {
    if (syntax) {
      var val = prefs.get(syntax + '.' + name);
      if (!_.isUndefined(val))
        return val;
    }

    return prefs.get('css.' + name);
  }

  /**
   * Format CSS property according to current syntax dialect
   * @param {String} property
   * @param {String} syntax
   * @returns {String}
   */
  function formatProperty(property, syntax) {
    var ix = property.indexOf(':');
    property = property.substring(0, ix).replace(/\s+$/, '')
      + getSyntaxPreference('valueSeparator', syntax)
      + require('utils').trim(property.substring(ix + 1));

    return property.replace(/\s*;\s*$/, getSyntaxPreference('propertyEnd', syntax));
  }

  /**
   * Transforms snippet value if required. For example, this transformation
   * may add <i>!important</i> declaration to CSS property
   * @param {String} snippet
   * @param {Boolean} isImportant
   * @returns {String}
   */
  function transformSnippet(snippet, isImportant, syntax) {
    if (!_.isString(snippet))
      snippet = snippet.data;

    if (!isSingleProperty(snippet))
      return snippet;

    if (isImportant) {
      if (~snippet.indexOf(';')) {
        snippet = snippet.split(';').join(' !important;');
      } else {
        snippet += ' !important';
      }
    }

    return formatProperty(snippet, syntax);
  }

  /**
   * Helper function that parses comma-separated list of elements into array
   * @param {String} list
   * @returns {Array}
   */
  function parseList(list) {
    var result = _.map((list || '').split(','), require('utils').trim);
    return result.length ? result : null;
  }

  function getProperties(key) {
    var list = prefs.getArray(key);
    _.each(prefs.getArray(key + 'Addon'), function(prop) {
      if (prop.charAt(0) == '-') {
        list = _.without(list, prop.substr(1));
      } else {
        if (prop.charAt(0) == '+')
          prop = prop.substr(1);

        list.push(prop);
      }
    });

    return list;
  }


  // TODO refactor, this looks awkward now
  addPrefix('w', {
    prefix: 'webkit'
  });
  addPrefix('m', {
    prefix: 'moz'
  });
  addPrefix('s', {
    prefix: 'ms'
  });
  addPrefix('o', {
    prefix: 'o'
  });

  // I think nobody uses it
//  addPrefix('k', {
//    prefix: 'khtml',
//    obsolete: true
//  });

  var cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus'];

  /**
   * XXX register resolver
   * @param {TreeNode} node
   * @param {String} syntax
   */
  require('resources').addResolver(function(node, syntax) {
    if (_.include(cssSyntaxes, syntax) && node.isElement()) {
      return module.expandToSnippet(node.abbreviation, syntax);
    }

    return null;
  });

  var ea = require('expandAbbreviation');
  /**
   * For CSS-like syntaxes, we need to handle a special use case. Some editors
   * (like Sublime Text 2) may insert semicolons automatically when user types
   * abbreviation. After expansion, user receives a double semicolon. This
   * handler automatically removes semicolon from generated content in such cases.
   * @param {IEmmetEditor} editor
   * @param {String} syntax
   * @param {String} profile
   */
  ea.addHandler(function(editor, syntax, profile) {
    if (!_.include(cssSyntaxes, syntax)) {
      return false;
    }

    var caretPos = editor.getSelectionRange().end;
    var abbr = ea.findAbbreviation(editor);

    if (abbr) {
      var content = emmet.expandAbbreviation(abbr, syntax, profile);
      if (content) {
        var replaceFrom = caretPos - abbr.length;
        var replaceTo = caretPos;
        if (editor.getContent().charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {
          replaceTo++;
        }

        editor.replaceContent(content, replaceFrom, replaceTo);
        return true;
      }
    }

    return false;
  });

  return module = {
    /**
     * Adds vendor prefix
     * @param {String} name One-character prefix name
     * @param {Object} obj Object describing vendor prefix
     * @memberOf cssResolver
     */
    addPrefix: addPrefix,

    /**
     * Check if passed CSS property supports specified vendor prefix
     * @param {String} property
     * @param {String} prefix
     */
    supportsPrefix: hasPrefix,

    /**
     * Returns prefixed version of passed CSS property, only if this
     * property supports such prefix
     * @param {String} property
     * @param {String} prefix
     * @returns
     */
    prefixed: function(property, prefix) {
      return hasPrefix(property, prefix)
        ? '-' + prefix + '-' + property
        : property;
    },

    /**
     * Returns list of all registered vendor prefixes
     * @returns {Array}
     */
    listPrefixes: function() {
      return _.map(vendorPrefixes, function(obj) {
        return obj.prefix;
      });
    },

    /**
     * Returns object describing vendor prefix
     * @param {String} name
     * @returns {Object}
     */
    getPrefix: function(name) {
      return vendorPrefixes[name];
    },

    /**
     * Removes prefix object
     * @param {String} name
     */
    removePrefix: function(name) {
      if (name in vendorPrefixes)
        delete vendorPrefixes[name];
    },

    /**
     * Extract vendor prefixes from abbreviation
     * @param {String} abbr
     * @returns {Object} Object containing array of prefixes and clean
     * abbreviation name
     */
    extractPrefixes: function(abbr) {
      if (abbr.charAt(0) != '-') {
        return {
          property: abbr,
          prefixes: null
        };
      }

      // abbreviation may either contain sequence of one-character prefixes
      // or just dash, meaning that user wants to produce all possible
      // prefixed properties
      var i = 1, il = abbr.length, ch;
      var prefixes = [];

      while (i < il) {
        ch = abbr.charAt(i);
        if (ch == '-') {
          // end-sequence character found, stop searching
          i++;
          break;
        }

        if (ch in vendorPrefixes) {
          prefixes.push(ch);
        } else {
          // no prefix found, meaning user want to produce all
          // vendor-prefixed properties
          prefixes.length = 0;
          i = 1;
          break;
        }

        i++;
      }

      // reached end of abbreviation and no property name left
      if (i == il -1) {
        i = 1;
        prefixes.length = 1;
      }

      return {
        property: abbr.substring(i),
        prefixes: prefixes.length ? prefixes : 'all'
      };
    },

    /**
     * Search for value substring in abbreviation
     * @param {String} abbr
     * @returns {String} Value substring
     */
    findValuesInAbbreviation: function(abbr, syntax) {
      syntax = syntax || 'css';

      var i = 0, il = abbr.length, value = '', ch;
      while (i < il) {
        ch = abbr.charAt(i);
        if (isNumeric(ch) || ch == '#' || (ch == '-' && isNumeric(abbr.charAt(i + 1)))) {
          value = abbr.substring(i);
          break;
        }

        i++;
      }

      // try to find keywords in abbreviation
      var property = abbr.substring(0, abbr.length - value.length);
      var res = require('resources');
      var keywords = [];
      // try to extract some commonly-used properties
      while (~property.indexOf('-') && !res.findSnippet(syntax, property)) {
        var parts = property.split('-');
        var lastPart = parts.pop();
        if (!isValidKeyword(lastPart)) {
          break;
        }

        keywords.unshift(lastPart);
        property = parts.join('-');
      }

      return keywords.join('-') + value;
    },

    parseValues: function(str) {
      /** @type StringStream */
      var stream = require('stringStream').create(str);
      var values = [];
      var ch = null;

      while (ch = stream.next()) {
        if (ch == '#') {
          stream.match(/^t|[0-9a-f]+/i, true);
          values.push(stream.current());
        } else if (ch == '-') {
          if (isValidKeyword(_.last(values)) ||
              ( stream.start && isNumeric(str.charAt(stream.start - 1)) )
            ) {
            stream.start = stream.pos;
          }

          stream.match(/^\-?[0-9]*(\.[0-9]+)?[a-z%\.]*/, true);
          values.push(stream.current());
        } else {
          stream.match(/^[0-9]*(\.[0-9]*)?[a-z%]*/, true);
          values.push(stream.current());
        }

        stream.start = stream.pos;
      }

      return _.map(_.compact(values), normalizeValue);
    },

    /**
     * Extracts values from abbreviation
     * @param {String} abbr
     * @returns {Object} Object containing array of values and clean
     * abbreviation name
     */
    extractValues: function(abbr) {
      // search for value start
      var abbrValues = this.findValuesInAbbreviation(abbr);
      if (!abbrValues) {
        return {
          property: abbr,
          values: null
        };
      }

      return {
        property: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),
        values: this.parseValues(abbrValues)
      };
    },

    /**
     * Normalizes value, defined in abbreviation.
     * @param {String} value
     * @param {String} property
     * @returns {String}
     */
    normalizeValue: function(value, property) {
      property = (property || '').toLowerCase();
      var unitlessProps = prefs.getArray('css.unitlessProperties');
      return value.replace(/^(\-?[0-9\.]+)([a-z]*)$/, function(str, val, unit) {
        if (!unit && (val == '0' || _.include(unitlessProps, property)))
          return val;

        if (!unit)
          return val.replace(/\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');

        return val + getUnit(unit);
      });
    },

    /**
     * Expands abbreviation into a snippet
     * @param {String} abbr Abbreviation name to expand
     * @param {String} value Abbreviation value
     * @param {String} syntax Currect syntax or dialect. Default is 'css'
     * @returns {Object} Array of CSS properties and values or predefined
     * snippet (string or element)
     */
    expand: function(abbr, value, syntax) {
      syntax = syntax || 'css';
      var resources = require('resources');
      var autoInsertPrefixes = prefs.get('css.autoInsertVendorPrefixes');

      // check if snippet should be transformed to !important
      var isImportant;
      if (isImportant = /^(.+)\!$/.test(abbr)) {
        abbr = RegExp.$1;
      }

      // check if we have abbreviated resource
      var snippet = resources.findSnippet(syntax, abbr);
      if (snippet && !autoInsertPrefixes) {
        return transformSnippet(snippet, isImportant, syntax);
      }

      // no abbreviated resource, parse abbreviation
      var prefixData = this.extractPrefixes(abbr);
      var valuesData = this.extractValues(prefixData.property);
      var abbrData = _.extend(prefixData, valuesData);

      if (!snippet) {
        snippet = resources.findSnippet(syntax, abbrData.property);
      } else {
        abbrData.values = null;
      }

      if (!snippet && prefs.get('css.fuzzySearch')) {
        // letâ€™s try fuzzy search
        snippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));
      }

      if (!snippet) {
        snippet = abbrData.property + ':' + defaultValue;
      } else if (!_.isString(snippet)) {
        snippet = snippet.data;
      }

      if (!isSingleProperty(snippet)) {
        return snippet;
      }

      var snippetObj = this.splitSnippet(snippet);
      var result = [];
      if (!value && abbrData.values) {
        value = _.map(abbrData.values, function(val) {
          return this.normalizeValue(val, snippetObj.name);
        }, this).join(' ') + ';';
      }

      snippetObj.value = value || snippetObj.value;

      var prefixes = abbrData.prefixes == 'all' || (!abbrData.prefixes && autoInsertPrefixes)
        ? findPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all')
        : abbrData.prefixes;


      var names = [], propName;
      _.each(prefixes, function(p) {
        if (p in vendorPrefixes) {
          propName = vendorPrefixes[p].transformName(snippetObj.name);
          names.push(propName);
          result.push(transformSnippet(propName + ':' + snippetObj.value,
              isImportant, syntax));
        }
      });

      // put the original property
      result.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));
      names.push(snippetObj.name);

      if (prefs.get('css.alignVendor')) {
        var pads = require('utils').getStringsPads(names);
        result = _.map(result, function(prop, i) {
          return pads[i] + prop;
        });
      }

      return result;
    },

    /**
     * Same as <code>expand</code> method but transforms output into
     * Emmet snippet
     * @param {String} abbr
     * @param {String} syntax
     * @returns {String}
     */
    expandToSnippet: function(abbr, syntax) {
      var snippet = this.expand(abbr, null, syntax);
      if (_.isArray(snippet)) {
        return snippet.join('\n');
      }

      if (!_.isString(snippet))
        return snippet.data;

      return String(snippet);
    },

    /**
     * Split snippet into a CSS property-value pair
     * @param {String} snippet
     */
    splitSnippet: function(snippet) {
      var utils = require('utils');
      snippet = utils.trim(snippet);
      if (snippet.indexOf(':') == -1) {
        return {
          name: snippet,
          value: defaultValue
        };
      }

      var pair = snippet.split(':');

      return {
        name: utils.trim(pair.shift()),
        // replace ${0} tabstop to produce valid vendor-prefixed values
        // where possible
        value: utils.trim(pair.join(':')).replace(/^(\$\{0\}|\$0)(\s*;?)$/, '${1}$2')
      };
    },

    getSyntaxPreference: getSyntaxPreference,
    transformSnippet: transformSnippet
  };
});
/**
 * 'Expand Abbreviation' handler that parses gradient definition from under
 * cursor and updates CSS rule with vendor-prefixed values.
 *
 * @memberOf __cssGradientHandlerDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('cssGradient', function(require, _) {
  var defaultLinearDirections = ['top', 'to bottom', '0deg'];
  /** Back-reference to current module */
  var module = null;

  var cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];

  var reDeg = /\d+deg/i;
  var reKeyword = /top|bottom|left|right/i;

  // XXX define preferences
  /** @type preferences */
  var prefs = require('preferences');
  prefs.define('css.gradient.prefixes', 'webkit, moz, o',
      'A comma-separated list of vendor-prefixes for which values should '
      + 'be generated.');

  prefs.define('css.gradient.oldWebkit', true,
      'Generate gradient definition for old Webkit implementations');

  prefs.define('css.gradient.omitDefaultDirection', true,
    'Do not output default direction definition in generated gradients.');

  prefs.define('css.gradient.defaultProperty', 'background-image',
    'When gradient expanded outside CSS value context, it will produce '
      + 'properties with this name.');

  prefs.define('css.gradient.fallback', false,
      'With this option enabled, CSS gradient generator will produce '
      + '<code>background-color</code> property with gradient first color '
      + 'as fallback for old browsers.');

  function normalizeSpace(str) {
    return require('utils').trim(str).replace(/\s+/g, ' ');
  }

  /**
   * Parses linear gradient definition
   * @param {String}
   */
  function parseLinearGradient(gradient) {
    var direction = defaultLinearDirections[0];

    // extract tokens
    /** @type StringStream */
    var stream = require('stringStream').create(require('utils').trim(gradient));
    var colorStops = [], ch;
    while (ch = stream.next()) {
      if (stream.peek() == ',') {
        colorStops.push(stream.current());
        stream.next();
        stream.eatSpace();
        stream.start = stream.pos;
      } else if (ch == '(') { // color definition, like 'rgb(0,0,0)'
        stream.skipTo(')');
      }
    }

    // add last token
    colorStops.push(stream.current());
    colorStops = _.compact(_.map(colorStops, normalizeSpace));

    if (!colorStops.length)
      return null;

    // let's see if the first color stop is actually a direction
    if (reDeg.test(colorStops[0]) || reKeyword.test(colorStops[0])) {
      direction = colorStops.shift();
    }

    return {
      type: 'linear',
      direction: direction,
      colorStops: _.map(colorStops, parseColorStop)
    };
  }

  /**
   * Parses color stop definition
   * @param {String} colorStop
   * @returns {Object}
   */
  function parseColorStop(colorStop) {
    colorStop = normalizeSpace(colorStop);

    // find color declaration
    // first, try complex color declaration, like rgb(0,0,0)
    var color = null;
    colorStop = colorStop.replace(/^(\w+\(.+?\))\s*/, function(str, c) {
      color = c;
      return '';
    });

    if (!color) {
      // try simple declaration, like yellow, #fco, #ffffff, etc.
      var parts = colorStop.split(' ');
      color = parts[0];
      colorStop = parts[1] || '';
    }

    var result = {
      color: color
    };

    if (colorStop) {
      // there's position in color stop definition
      colorStop.replace(/^(\-?[\d\.]+)([a-z%]+)?$/, function(str, pos, unit) {
        result.position = pos;
        if (~pos.indexOf('.')) {
          unit = '';
        } else if (!unit) {
          unit = '%';
        }

        if (unit)
          result.unit = unit;
      });
    }

    return result;
  }

  /**
   * Resolves property name (abbreviation): searches for snippet definition in
   * 'resources' and returns new name of matched property
   */
  function resolvePropertyName(name, syntax) {
    var res = require('resources');
    var prefs = require('preferences');
    var snippet = res.findSnippet(syntax, name);

    if (!snippet && prefs.get('css.fuzzySearch')) {
      snippet = res.fuzzyFindSnippet(syntax, name,
          parseFloat(prefs.get('css.fuzzySearchMinScore')));
    }

    if (snippet) {
      if (!_.isString(snippet)) {
        snippet = snippet.data;
      }

      return require('cssResolver').splitSnippet(snippet).name;
    }
  }

  /**
   * Fills-out implied positions in color-stops. This function is useful for
   * old Webkit gradient definitions
   */
  function fillImpliedPositions(colorStops) {
    var from = 0;

    _.each(colorStops, function(cs, i) {
      // make sure that first and last positions are defined
      if (!i)
        return cs.position = cs.position || 0;

      if (i == colorStops.length - 1 && !('position' in cs))
        cs.position = 1;

      if ('position' in cs) {
        var start = colorStops[from].position || 0;
        var step = (cs.position - start) / (i - from);
        _.each(colorStops.slice(from, i), function(cs2, j) {
          cs2.position = start + step * j;
        });

        from = i;
      }
    });
  }

  /**
   * Returns textual version of direction expressed in degrees
   * @param {String} direction
   * @returns {String}
   */
  function textualDirection(direction) {
    var angle = parseFloat(direction);

    if(!_.isNaN(angle)) {
      switch(angle % 360) {
        case 0:   return 'left';
        case 90:  return 'bottom';
        case 180: return 'right';
        case 240: return 'top';
      }
    }

    return direction;
  }

  /**
   * Creates direction definition for old Webkit gradients
   * @param {String} direction
   * @returns {String}
   */
  function oldWebkitDirection(direction) {
    direction = textualDirection(direction);

    if(reDeg.test(direction))
      throw "The direction is an angle that canâ€™t be converted.";

    var v = function(pos) {
      return ~direction.indexOf(pos) ? '100%' : '0';
    };

    return v('right') + ' ' + v('bottom') + ', ' + v('left') + ' ' + v('top');
  }

  function getPrefixedNames(name) {
    var prefixes = prefs.getArray('css.gradient.prefixes');
    var names = _.map(prefixes, function(p) {
      return '-' + p + '-' + name;
    });
    names.push(name);

    return names;
  }

  /**
   * Returns list of CSS properties with gradient
   * @param {Object} gradient
   * @param {String} propertyName Original CSS property name
   * @returns {Array}
   */
  function getPropertiesForGradient(gradient, propertyName) {
    var props = [];
    var css = require('cssResolver');

    if (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {
      props.push({
        name: 'background-color',
        value: '${1:' + gradient.colorStops[0].color + '}'
      });
    }

    _.each(prefs.getArray('css.gradient.prefixes'), function(prefix) {
      var name = css.prefixed(propertyName, prefix);
      if (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {
        try {
          props.push({
            name: name,
            value: module.oldWebkitLinearGradient(gradient)
          });
        } catch(e) {}
      }

      props.push({
        name: name,
        value: module.toString(gradient, prefix)
      });
    });

    return props.sort(function(a, b) {
      return b.name.length - a.name.length;
    });
  }

  /**
   * Pastes gradient definition into CSS rule with correct vendor-prefixes
   * @param {EditElement} property Matched CSS property
   * @param {Object} gradient Parsed gradient
   * @param {Range} valueRange If passed, only this range within property
   * value will be replaced with gradient. Otherwise, full value will be
   * replaced
   */
  function pasteGradient(property, gradient, valueRange) {
    var rule = property.parent;
    var utils = require('utils');
    var alignVendor = require('preferences').get('css.alignVendor');

    // we may have aligned gradient definitions: find the smallest value
    // separator
    var sep = property.styleSeparator;
    var before = property.styleBefore;

    // first, remove all properties within CSS rule with the same name and
    // gradient definition
    _.each(rule.getAll(getPrefixedNames(property.name())), function(item) {
      if (item != property && /gradient/i.test(item.value())) {
        if (item.styleSeparator.length < sep.length) {
          sep = item.styleSeparator;
        }
        if (item.styleBefore.length < before.length) {
          before = item.styleBefore;
        }
        rule.remove(item);
      }
    });

    if (alignVendor) {
      // update prefix
      if (before != property.styleBefore) {
        var fullRange = property.fullRange();
        rule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);
        property.styleBefore = before;
      }

      // update separator value
      if (sep != property.styleSeparator) {
        rule._updateSource(sep, property.nameRange().end, property.valueRange().start);
        property.styleSeparator = sep;
      }
    }

    var value = property.value();
    if (!valueRange)
      valueRange = require('range').create(0, property.value());

    var val = function(v) {
      return utils.replaceSubstring(value, v, valueRange);
    };

    // put vanilla-clean gradient definition into current rule
    property.value(val(module.toString(gradient)) + '${2}');

    // create list of properties to insert
    var propsToInsert = getPropertiesForGradient(gradient, property.name());

    // align prefixed values
    if (alignVendor) {
      var values = _.pluck(propsToInsert, 'value');
      var names = _.pluck(propsToInsert, 'name');
      values.push(property.value());
      names.push(property.name());

      var valuePads = utils.getStringsPads(_.map(values, function(v) {
        return v.substring(0, v.indexOf('('));
      }));

      var namePads = utils.getStringsPads(names);
      property.name(_.last(namePads) + property.name());

      _.each(propsToInsert, function(prop, i) {
        prop.name = namePads[i] + prop.name;
        prop.value = valuePads[i] + prop.value;
      });

      property.value(_.last(valuePads) + property.value());
    }

    // put vendor-prefixed definitions before current rule
    _.each(propsToInsert, function(prop) {
      rule.add(prop.name, prop.value, rule.indexOf(property));
    });
  }

  /**
   * Search for gradient definition inside CSS property value
   */
  function findGradient(cssProp) {
    var value = cssProp.value();
    var gradient = null;
    var matchedPart = _.find(cssProp.valueParts(), function(part) {
      return gradient = module.parse(part.substring(value));
    });

    if (matchedPart && gradient) {
      return {
        gradient: gradient,
        valueRange: matchedPart
      };
    }

    return null;
  }

  /**
   * Tries to expand gradient outside CSS value
   * @param {IEmmetEditor} editor
   * @param {String} syntax
   */
  function expandGradientOutsideValue(editor, syntax) {
    var propertyName = prefs.get('css.gradient.defaultProperty');

    if (!propertyName)
      return false;

    // assuming that gradient definition is written on new line,
    // do a simplified parsing
    var content = String(editor.getContent());
    /** @type Range */
    var lineRange = require('range').create(editor.getCurrentLineRange());

    // get line content and adjust range with padding
    var line = lineRange.substring(content)
      .replace(/^\s+/, function(pad) {
        lineRange.start += pad.length;
        return '';
      })
      .replace(/\s+$/, function(pad) {
        lineRange.end -= pad.length;
        return '';
      });

    var css = require('cssResolver');
    var gradient = module.parse(line);
    if (gradient) {
      var props = getPropertiesForGradient(gradient, propertyName);
      props.push({
        name: propertyName,
        value: module.toString(gradient) + '${2}'
      });

      var sep = css.getSyntaxPreference('valueSeparator', syntax);
      var end = css.getSyntaxPreference('propertyEnd', syntax);

      if (require('preferences').get('css.alignVendor')) {
        var pads = require('utils').getStringsPads(_.map(props, function(prop) {
          return prop.value.substring(0, prop.value.indexOf('('));
        }));
        _.each(props, function(prop, i) {
          prop.value = pads[i] + prop.value;
        });
      }

      props = _.map(props, function(item) {
        return item.name + sep + item.value + end;
      });

      editor.replaceContent(props.join('\n'), lineRange.start, lineRange.end);
      return true;
    }

    return false;
  }

  /**
   * Search for gradient definition inside CSS value under cursor
   * @param {String} content
   * @param {Number} pos
   * @returns {Object}
   */
  function findGradientFromPosition(content, pos) {
    var cssProp = null;
    /** @type EditContainer */
    var cssRule = require('cssEditTree').parseFromPosition(content, pos, true);

    if (cssRule) {
      cssProp = cssRule.itemFromPosition(pos, true);
      if (!cssProp) {
        // in case user just started writing CSS property
        // and didn't include semicolonâ€“try another approach
        cssProp = _.find(cssRule.list(), function(elem) {
          return elem.range(true).end == pos;
        });
      }
    }

    return {
      rule: cssRule,
      property: cssProp
    };
  }

  // XXX register expand abbreviation handler
  /**
   * @param {IEmmetEditor} editor
   * @param {String} syntax
   * @param {String} profile
   */
  require('expandAbbreviation').addHandler(function(editor, syntax, profile) {
    var info = require('editorUtils').outputInfo(editor, syntax, profile);
    if (!_.include(cssSyntaxes, info.syntax))
      return false;

    // let's see if we are expanding gradient definition
    var caret = editor.getCaretPos();
    var content = info.content;
    var css = findGradientFromPosition(content, caret);

    if (css.property) {
      // make sure that caret is inside property value with gradient
      // definition
      var g = findGradient(css.property);
      if (g) {
        var ruleStart = css.rule.options.offset || 0;
        var ruleEnd = ruleStart + css.rule.toString().length;

        // Handle special case:
        // user wrote gradient definition between existing CSS
        // properties and did not finished it with semicolon.
        // In this case, we have semicolon right after gradient
        // definition and re-parse rule again
        if (/[\n\r]/.test(css.property.value())) {
          // insert semicolon at the end of gradient definition
          var insertPos = css.property.valueRange(true).start + g.valueRange.end;
          content = require('utils').replaceSubstring(content, ';', insertPos);
          var newCss = findGradientFromPosition(content, caret);
          if (newCss.property) {
            g = findGradient(newCss.property);
            css = newCss;
          }
        }

        // make sure current property has terminating semicolon
        css.property.end(';');

        // resolve CSS property name
        var resolvedName = resolvePropertyName(css.property.name(), syntax);
        if (resolvedName) {
          css.property.name(resolvedName);
        }

        pasteGradient(css.property, g.gradient, g.valueRange);
        editor.replaceContent(css.rule.toString(), ruleStart, ruleEnd, true);
        return true;
      }
    }

    return expandGradientOutsideValue(editor, syntax);
  });

  // XXX register "Reflect CSS Value" action delegate
  /**
   * @param {EditElement} property
   */
  require('reflectCSSValue').addHandler(function(property) {
    var utils = require('utils');

    var g = findGradient(property);
    if (!g)
      return false;

    var value = property.value();
    var val = function(v) {
      return utils.replaceSubstring(value, v, g.valueRange);
    };

    // reflect value for properties with the same name
    _.each(property.parent.getAll(getPrefixedNames(property.name())), function(prop) {
      if (prop === property)
        return;

      // check if property value starts with gradient definition
      var m = prop.value().match(/^\s*(\-([a-z]+)\-)?linear\-gradient/);
      if (m) {
        prop.value(val(module.toString(g.gradient, m[2] || '')));
      } else if (m = prop.value().match(/\s*\-webkit\-gradient/)) {
        // old webkit gradient definition
        prop.value(val(module.oldWebkitLinearGradient(g.gradient)));
      }
    });

    return true;
  });

  return module = {
    /**
     * Parses gradient definition
     * @param {String} gradient
     * @returns {Object}
     */
    parse: function(gradient) {
      var result = null;
      require('utils').trim(gradient).replace(/^([\w\-]+)\((.+?)\)$/, function(str, type, definition) {
        // remove vendor prefix
        type = type.toLowerCase().replace(/^\-[a-z]+\-/, '');
        if (type == 'linear-gradient' || type == 'lg') {
          result = parseLinearGradient(definition);
          return '';
        }

        return str;
      });

      return result;
    },

    /**
     * Produces linear gradient definition used in early Webkit
     * implementations
     * @param {Object} gradient Parsed gradient
     * @returns {String}
     */
    oldWebkitLinearGradient: function(gradient) {
      if (_.isString(gradient))
        gradient = this.parse(gradient);

      if (!gradient)
        return null;

      var colorStops = _.map(gradient.colorStops, _.clone);

      // normalize color-stops position
      _.each(colorStops, function(cs) {
        if (!('position' in cs)) // implied position
          return;

        if (~cs.position.indexOf('.') || cs.unit == '%') {
          cs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);
        } else {
          throw "Can't convert color stop '" + (cs.position + (cs.unit || '')) + "'";
        }
      });

      fillImpliedPositions(colorStops);

      // transform color-stops into string representation
      colorStops = _.map(colorStops, function(cs, i) {
        if (!cs.position && !i)
          return 'from(' + cs.color + ')';

        if (cs.position == 1 && i == colorStops.length - 1)
          return 'to(' + cs.color + ')';

        return 'color-stop(' + (cs.position.toFixed(2).replace(/\.?0+$/, '')) + ', ' + cs.color + ')';
      });

      return '-webkit-gradient(linear, '
        + oldWebkitDirection(gradient.direction)
        + ', '
        + colorStops.join(', ')
        + ')';
    },

    /**
     * Returns string representation of parsed gradient
     * @param {Object} gradient Parsed gradient
     * @param {String} prefix Vendor prefix
     * @returns {String}
     */
    toString: function(gradient, prefix) {
      if (gradient.type == 'linear') {
        var fn = (prefix ? '-' + prefix + '-' : '') + 'linear-gradient';

        // transform color-stops
        var colorStops = _.map(gradient.colorStops, function(cs) {
          return cs.color + ('position' in cs
              ? ' ' + cs.position + (cs.unit || '')
              : '');
        });

        if (gradient.direction
            && (!prefs.get('css.gradient.omitDefaultDirection')
            || !_.include(defaultLinearDirections, gradient.direction))) {
          colorStops.unshift(gradient.direction);
        }

        return fn + '(' + colorStops.join(', ') + ')';
      }
    }
  };
});/**
 * Module adds support for generators: a regexp-based abbreviation resolver
 * that can produce custom output.
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  /** @type HandlerList */
  var generators = require('handlerList').create();
  var resources = require('resources');

  _.extend(resources, {
    /**
     * Add generator. A generator function <code>fn</code> will be called
     * only if current abbreviation matches <code>regexp</code> regular
     * expression and this function should return <code>null</code> if
     * abbreviation cannot be resolved
     * @param {RegExp} regexp Regular expression for abbreviation element name
     * @param {Function} fn Resolver function
     * @param {Object} options Options list as described in
     * {@link HandlerList#add()} method
     */
    addGenerator: function(regexp, fn, options) {
      if (_.isString(regexp))
        regexp = new RegExp(regexp);

      generators.add(function(node, syntax) {
        var m;
        if ((m = regexp.exec(node.name()))) {
          return fn(m, node, syntax);
        }

        return null;
      }, options);
    }
  });

  resources.addResolver(function(node, syntax) {
    return generators.exec(null, _.toArray(arguments));
  });
});/**
 * Module for resolving tag names: returns best matched tag name for child
 * element based on passed parent's tag name. Also provides utility function
 * for element type detection (inline, block-level, empty)
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('tagName', function(require, _) {
  var elementTypes = {
    empty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),
    blockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),
    inlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')
  };

  var elementMap = {
    'p': 'span',
    'ul': 'li',
    'ol': 'li',
    'table': 'tr',
    'tr': 'td',
    'tbody': 'tr',
    'thead': 'tr',
    'tfoot': 'tr',
    'colgroup': 'col',
    'select': 'option',
    'optgroup': 'option',
    'audio': 'source',
    'video': 'source',
    'object': 'param',
    'map': 'area'
  };

  return {
    /**
     * Returns best matched child element name for passed parent's
     * tag name
     * @param {String} name
     * @returns {String}
     * @memberOf tagName
     */
    resolve: function(name) {
      name = (name || '').toLowerCase();

      if (name in elementMap)
        return this.getMapping(name);

      if (this.isInlineLevel(name))
        return 'span';

      return 'div';
    },

    /**
     * Returns mapped child element name for passed parent's name
     * @param {String} name
     * @returns {String}
     */
    getMapping: function(name) {
      return elementMap[name.toLowerCase()];
    },

    /**
     * Check if passed element name belongs to inline-level element
     * @param {String} name
     * @returns {Boolean}
     */
    isInlineLevel: function(name) {
      return this.isTypeOf(name, 'inlineLevel');
    },

    /**
     * Check if passed element belongs to block-level element.
     * For better matching of unknown elements (for XML, for example),
     * you should use <code>!this.isInlineLevel(name)</code>
     * @returns {Boolean}
     */
    isBlockLevel: function(name) {
      return this.isTypeOf(name, 'blockLevel');
    },

    /**
     * Check if passed element is void (i.e. should not have closing tag).
     * @returns {Boolean}
     */
    isEmptyElement: function(name) {
      return this.isTypeOf(name, 'empty');
    },

    /**
     * Generic function for testing if element name belongs to specified
     * elements collection
     * @param {String} name Element name
     * @param {String} type Collection name
     * @returns {Boolean}
     */
    isTypeOf: function(name, type) {
      return _.include(elementTypes[type], name);
    },

    /**
     * Adds new parentâ€“child mapping
     * @param {String} parent
     * @param {String} child
     */
    addMapping: function(parent, child) {
      elementMap[parent] = child;
    },

    /**
     * Removes parent-child mapping
     */
    removeMapping: function(parent) {
      if (parent in elementMap)
        delete elementMap[parent];
    },

    /**
     * Adds new element into collection
     * @param {String} name Element name
     * @param {String} collection Collection name
     */
    addElementToCollection: function(name, collection) {
      if (!elementTypes[collection])
        elementTypes[collection] = [];

      var col = this.getCollection(collection);
      if (!_.include(col, name))
        col.push(name);
    },

    /**
     * Removes element name from specified collection
     * @param {String} name Element name
     * @param {String} collection Collection name
     * @returns
     */
    removeElementFromCollection: function(name, collection) {
      if (collection in elementTypes) {
        elementTypes[collection] = _.without(this.getCollection(collection), name);
      }
    },

    /**
     * Returns elements name collection
     * @param {String} name Collection name
     * @returns {Array}
     */
    getCollection: function(name) {
      return elementTypes[name];
    }
  };
});/**
 * Filter for aiding of writing elements with complex class names as described
 * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will
 * automatically inherit block and element names from parent elements and insert
 * them into child element classes
 * @memberOf __bemFilterDefine
 * @constructor
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  var prefs = require('preferences');
  prefs.define('bem.elementSeparator', '__', 'Class nameâ€™s element separator.');
  prefs.define('bem.modifierSeparator', '_', 'Class nameâ€™s modifier separator.');
  prefs.define('bem.shortElementPrefix', '-',
      'Symbol for describing short â€œblock-elementâ€ notation. Class names '
      + 'prefixed with this symbol will be treated as element name for parentâ€˜s '
      + 'block name. Each symbol instance traverses one level up in parsed '
      + 'tree for block name lookup. Empty value will disable short notation.');

  var shouldRunHtmlFilter = false;

  function getSeparators() {
    return {
      element: prefs.get('bem.elementSeparator'),
      modifier: prefs.get('bem.modifierSeparator')
    };
  }

  /**
   * @param {AbbreviationNode} item
   */
  function bemParse(item) {
    if (require('abbreviationUtils').isSnippet(item))
      return item;

    // save BEM stuff in cache for faster lookups
    item.__bem = {
      block: '',
      element: '',
      modifier: ''
    };

    var classNames = normalizeClassName(item.attribute('class')).split(' ');

    // guess best match for block name
    var reBlockName = /^[a-z]\-/i;
    item.__bem.block = _.find(classNames, function(name) {
      return reBlockName.test(name);
    });

    // guessing doesn't worked, pick first class name as block name
    if (!item.__bem.block) {
      reBlockName = /^[a-z]/i;
      item.__bem.block = _.find(classNames, function(name) {
        return reBlockName.test(name);
      }) || '';
    }

    classNames = _.chain(classNames)
      .map(function(name) {return processClassName(name, item);})
      .flatten()
      .uniq()
      .value()
      .join(' ');

    if (classNames)
      item.attribute('class', classNames);

    return item;
  }

  /**
   * @param {String} className
   * @returns {String}
   */
  function normalizeClassName(className) {
    var utils = require('utils');
    className = (' ' + (className || '') + ' ').replace(/\s+/g, ' ');

    var shortSymbol = prefs.get('bem.shortElementPrefix');
    if (shortSymbol) {
      var re = new RegExp('\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');
      className = className.replace(re, function(str, p1) {
        return ' ' + utils.repeatString(getSeparators().element, p1.length);
      });
    }

    return utils.trim(className);
  }

  /**
   * Processes class name
   * @param {String} name Class name item to process
   * @param {AbbreviationNode} item Host node for provided class name
   * @returns Processed class name. May return <code>Array</code> of
   * class names
   */
  function processClassName(name, item) {
    name = transformClassName(name, item, 'element');
    name = transformClassName(name, item, 'modifier');

    // expand class name
    // possible values:
    // * block__element
    // * block__element_modifier
    // * block__element_modifier1_modifier2
    // * block_modifier
    var block = '', element = '', modifier = '';
    var separators = getSeparators();
    if (~name.indexOf(separators.element)) {
      var blockElem = name.split(separators.element);
      var elemModifiers = blockElem[1].split(separators.modifier);

      block = blockElem[0];
      element = elemModifiers.shift();
      modifier = elemModifiers.join(separators.modifier);
    } else if (~name.indexOf(separators.modifier)) {
      var blockModifiers = name.split(separators.modifier);

      block = blockModifiers.shift();
      modifier = blockModifiers.join(separators.modifier);
    }

    if (block || element || modifier) {
      if (!block) {
        block = item.__bem.block;
      }

      // inherit parent bem element, if exists
//      if (item.parent && item.parent.__bem && item.parent.__bem.element)
//        element = item.parent.__bem.element + separators.element + element;

      // produce multiple classes
      var prefix = block;
      var result = [];

      if (element) {
        prefix += separators.element + element;
        result.push(prefix);
      } else {
        result.push(prefix);
      }

      if (modifier) {
        result.push(prefix + separators.modifier + modifier);
      }

      item.__bem.block = block;
      item.__bem.element = element;
      item.__bem.modifier = modifier;

      return result;
    }

    // ...otherwise, return processed or original class name
    return name;
  }

  /**
   * Low-level function to transform user-typed class name into full BEM class
   * @param {String} name Class name item to process
   * @param {AbbreviationNode} item Host node for provided class name
   * @param {String} entityType Type of entity to be tried to transform
   * ('element' or 'modifier')
   * @returns {String} Processed class name or original one if it can't be
   * transformed
   */
  function transformClassName(name, item, entityType) {
    var separators = getSeparators();
    var reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');
    if (reSep.test(name)) {
      var depth = 0; // parent lookup depth
      var cleanName = name.replace(reSep, function(str, p1) {
        depth = str.length / separators[entityType].length;
        return '';
      });

      // find donor element
      var donor = item;
      while (donor.parent && depth--) {
        donor = donor.parent;
      }

      if (!donor || !donor.__bem)
        donor = item;

      if (donor && donor.__bem) {
        var prefix = donor.__bem.block;

        // decide if we should inherit element name
//        if (entityType == 'element') {
//          var curElem = cleanName.split(separators.modifier, 1)[0];
//          if (donor.__bem.element && donor.__bem.element != curElem)
//            prefix += separators.element + donor.__bem.element;
//        }

        if (entityType == 'modifier' &&  donor.__bem.element)
          prefix += separators.element + donor.__bem.element;

        return prefix + separators[entityType] + cleanName;
      }
    }

    return name;
  }

  /**
   * Recursive function for processing tags, which extends class names
   * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html
   * <br><br>
   * It does several things:<br>
   * <ul>
   * <li>Expands complex class name (according to BEM symbol semantics):
   * .block__elem_modifier â†’ .block.block__elem.block__elem_modifier
   * </li>
   * <li>Inherits block name on child elements:
   * .b-block > .__el > .__el â†’ .b-block > .b-block__el > .b-block__el__el
   * </li>
   * <li>Treats first dash symbol as '__'</li>
   * <li>Double underscore (or typographic 'â€“') is also treated as an element
   * level lookup, e.g. ____el will search for element definition in parentâ€™s
   * parent element:
   * .b-block > .__el1 > .____el2 â†’ .b-block > .b-block__el1 > .b-block__el2
   * </li>
   * </ul>
   *
   * @param {AbbreviationNode} tree
   * @param {Object} profile
   */
  function process(tree, profile) {
    if (tree.name)
      bemParse(tree, profile);

    var abbrUtils = require('abbreviationUtils');
    _.each(tree.children, function(item) {
      process(item, profile);
      if (!abbrUtils.isSnippet(item) && item.start)
        shouldRunHtmlFilter = true;
    });

    return tree;
  };

  require('filters').add('bem', function(tree, profile) {
    shouldRunHtmlFilter = false;
    tree = process(tree, profile);
    // in case 'bem' filter is applied after 'html' filter: run it again
    // to update output
    if (shouldRunHtmlFilter) {
      tree = require('filters').apply(tree, 'html', profile);
    }

    return tree;
  });
});

/**
 * Comment important tags (with 'id' and 'class' attributes)
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 * @constructor
 * @memberOf __commentFilterDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  // define some preferences
  /** @type emmet.preferences */
  var prefs = require('preferences');

  prefs.define('filter.commentAfter',
      '\n<!-- /<%= attr("id", "#") %><%= attr("class", ".") %> -->',
      'A definition of comment that should be placed <i>after</i> matched '
      + 'element when <code>comment</code> filter is applied. This definition '
      + 'is an ERB-style template passed to <code>_.template()</code> '
      + 'function (see Underscore.js docs for details). In template context, '
      + 'the following properties and functions are availabe:\n'
      + '<ul>'

      + '<li><code>attr(name, before, after)</code> â€“ a function that outputs'
      + 'specified attribute value concatenated with <code>before</code> '
      + 'and <code>after</code> strings. If attribute doesn\'t exists, the '
      + 'empty string will be returned.</li>'

      + '<li><code>node</code> â€“ current node (instance of <code>AbbreviationNode</code>)</li>'

      + '<li><code>name</code> â€“ name of current tag</li>'

      + '<li><code>padding</code> â€“ current string padding, can be used '
      + 'for formatting</li>'

      +'</ul>');

  prefs.define('filter.commentBefore',
      '',
      'A definition of comment that should be placed <i>before</i> matched '
      + 'element when <code>comment</code> filter is applied. '
      + 'For more info, read description of <code>filter.commentAfter</code> '
      + 'property');

  prefs.define('filter.commentTrigger', 'id, class',
      'A comma-separated list of attribute names that should exist in abbreviatoin '
      + 'where comment should be added. If you wish to add comment for '
      + 'every element, set this option to <code>*</code>');

  /**
   * Add comments to tag
   * @param {AbbreviationNode} node
   */
  function addComments(node, templateBefore, templateAfter) {
    var utils = require('utils');

    // check if comments should be added
    var trigger = prefs.get('filter.commentTrigger');
    if (trigger != '*') {
      var shouldAdd = _.find(trigger.split(','), function(name) {
        return !!node.attribute(utils.trim(name));
      });
      if (!shouldAdd) return;
    }

    var ctx = {
      node: node,
      name: node.name(),
      padding: node.parent ? node.parent.padding : '',
      attr: function(name, before, after) {
        var attr = node.attribute(name);
        if (attr) {
          return (before || '') + attr + (after || '');
        }

        return '';
      }
    };

    var nodeBefore = utils.normalizeNewline(templateBefore ? templateBefore(ctx) : '');
    var nodeAfter = utils.normalizeNewline(templateAfter ? templateAfter(ctx) : '');

    node.start = node.start.replace(/</, nodeBefore + '<');
    node.end = node.end.replace(/>/, '>' + nodeAfter);
  }

  function process(tree, before, after) {
    var abbrUtils = require('abbreviationUtils');
    _.each(tree.children, function(item) {
      if (abbrUtils.isBlock(item))
        addComments(item, before, after);

      process(item, before, after);
    });

    return tree;
  }

  require('filters').add('c', function(tree) {
    var templateBefore = _.template(prefs.get('filter.commentBefore'));
    var templateAfter = _.template(prefs.get('filter.commentAfter'));

    return process(tree, templateBefore, templateAfter);
  });
});
/**
 * Filter for escaping unsafe XML characters: <, >, &
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 */
emmet.exec(function(require, _) {
  var charMap = {
    '<': '&lt;',
    '>': '&gt;',
    '&': '&amp;'
  };

  function escapeChars(str) {
    return str.replace(/([<>&])/g, function(str, p1){
      return charMap[p1];
    });
  }

  require('filters').add('e', function process(tree) {
    _.each(tree.children, function(item) {
      item.start = escapeChars(item.start);
      item.end = escapeChars(item.end);
      item.content = escapeChars(item.content);
      process(item);
    });

    return tree;
  });
});/**
 * Generic formatting filter: creates proper indentation for each tree node,
 * placing "%s" placeholder where the actual output should be. You can use
 * this filter to preformat tree and then replace %s placeholder to whatever you
 * need. This filter should't be called directly from editor as a part
 * of abbreviation.
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 * @constructor
 * @memberOf __formatFilterDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _){
  var placeholder = '%s';

  /** @type preferences */
  var prefs = require('preferences');
  prefs.define('format.noIndentTags', 'html',
      'A comma-separated list of tag names that should not get inner indentation.');

  prefs.define('format.forceIndentationForTags', 'body',
    'A comma-separated list of tag names that should <em>always</em> get inner indentation.');

  /**
   * Get indentation for given node
   * @param {AbbreviationNode} node
   * @returns {String}
   */
  function getIndentation(node) {
    if (_.include(prefs.getArray('format.noIndentTags') || [], node.name())) {
      return '';
    }

    return require('resources').getVariable('indentation');
  }

  /**
   * Test if passed node has block-level sibling element
   * @param {AbbreviationNode} item
   * @return {Boolean}
   */
  function hasBlockSibling(item) {
    return item.parent && require('abbreviationUtils').hasBlockChildren(item.parent);
  }

  /**
   * Test if passed item is very first child in parsed tree
   * @param {AbbreviationNode} item
   */
  function isVeryFirstChild(item) {
    return item.parent && !item.parent.parent && !item.index();
  }

  /**
   * Check if a newline should be added before element
   * @param {AbbreviationNode} node
   * @param {OutputProfile} profile
   * @return {Boolean}
   */
  function shouldAddLineBreak(node, profile) {
    var abbrUtils = require('abbreviationUtils');
    if (profile.tag_nl === true || abbrUtils.isBlock(node))
      return true;

    if (!node.parent || !profile.inline_break)
      return false;

    // check if there are required amount of adjacent inline element
    return shouldFormatInline(node.parent, profile);
}

  /**
   * Need to add newline because <code>item</code> has too many inline children
   * @param {AbbreviationNode} node
   * @param {OutputProfile} profile
   */
  function shouldBreakChild(node, profile) {
    // we need to test only one child element, because
    // hasBlockChildren() method will do the rest
    return node.children.length && shouldAddLineBreak(node.children[0], profile);
  }

  function shouldFormatInline(node, profile) {
    var nodeCount = 0;
    var abbrUtils = require('abbreviationUtils');
    return !!_.find(node.children, function(child) {
      if (child.isTextNode() || !abbrUtils.isInline(child))
        nodeCount = 0;
      else if (abbrUtils.isInline(child))
        nodeCount++;

      if (nodeCount >= profile.inline_break)
        return true;
    });
  }

  function isRoot(item) {
    return !item.parent;
  }

  /**
   * Processes element with matched resource of type <code>snippet</code>
   * @param {AbbreviationNode} item
   * @param {OutputProfile} profile
   * @param {Number} level Depth level
   */
  function processSnippet(item, profile, level) {
    item.start = item.end = '';
    if (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {
      // check if weâ€™re not inside inline element
      if (isRoot(item.parent) || !require('abbreviationUtils').isInline(item.parent)) {
        item.start = require('utils').getNewline() + item.start;
      }
    }

    return item;
  }

  /**
   * Check if we should add line breaks inside inline element
   * @param {AbbreviationNode} node
   * @param {OutputProfile} profile
   * @return {Boolean}
   */
  function shouldBreakInsideInline(node, profile) {
    var abbrUtils = require('abbreviationUtils');
    var hasBlockElems = _.any(node.children, function(child) {
      if (abbrUtils.isSnippet(child))
        return false;

      return !abbrUtils.isInline(child);
    });

    if (!hasBlockElems) {
      return shouldFormatInline(node, profile);
    }

    return true;
  }

  /**
   * Processes element with <code>tag</code> type
   * @param {AbbreviationNode} item
   * @param {OutputProfile} profile
   * @param {Number} level Depth level
   */
  function processTag(item, profile, level) {
    item.start = item.end = placeholder;
    var utils = require('utils');
    var abbrUtils = require('abbreviationUtils');
    var isUnary = abbrUtils.isUnary(item);
    var nl = utils.getNewline();
    var indent = getIndentation(item);

    // formatting output
    if (profile.tag_nl !== false) {
      var forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);
      if (!forceNl) {
        forceNl = _.include(prefs.getArray('format.forceIndentationForTags') || [], item.name());
      }

      // formatting block-level elements
      if (!item.isTextNode()) {
        if (shouldAddLineBreak(item, profile)) {
          // - do not indent the very first element
          // - do not indent first child of a snippet
          if (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index()))
            item.start = nl + item.start;

          if (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || (forceNl && !isUnary))
            item.end = nl + item.end;

          if (abbrUtils.hasTagsInContent(item) || (forceNl && !item.children.length && !isUnary))
            item.start += nl + indent;
        } else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {
          item.start = nl + item.start;
        } else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {
          item.end = nl + item.end;
        }

        item.padding = indent;
      }
    }

    return item;
  }

  /**
   * Processes simplified tree, making it suitable for output as HTML structure
   * @param {AbbreviationNode} tree
   * @param {OutputProfile} profile
   * @param {Number} level Depth level
   */
  require('filters').add('_format', function process(tree, profile, level) {
    level = level || 0;
    var abbrUtils = require('abbreviationUtils');

    _.each(tree.children, function(item) {
      if (abbrUtils.isSnippet(item))
        processSnippet(item, profile, level);
      else
        processTag(item, profile, level);

      process(item, profile, level + 1);
    });

    return tree;
  });
});/**
 * Filter for producing HAML code from abbreviation.
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 * @constructor
 * @memberOf __hamlFilterDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  var childToken = '${child}';

  function transformClassName(className) {
    return require('utils').trim(className).replace(/\s+/g, '.');
  }

  /**
   * Creates HAML attributes string from tag according to profile settings
   * @param {AbbreviationNode} tag
   * @param {Object} profile
   */
  function makeAttributesString(tag, profile) {
    var attrs = '';
    var otherAttrs = [];
    var attrQuote = profile.attributeQuote();
    var cursor = profile.cursor();

    _.each(tag.attributeList(), function(a) {
      var attrName = profile.attributeName(a.name);
      switch (attrName.toLowerCase()) {
        // use short notation for ID and CLASS attributes
        case 'id':
          attrs += '#' + (a.value || cursor);
          break;
        case 'class':
          attrs += '.' + transformClassName(a.value || cursor);
          break;
        // process other attributes
        default:
          otherAttrs.push(':' +attrName + ' => ' + attrQuote + (a.value || cursor) + attrQuote);
      }
    });

    if (otherAttrs.length)
      attrs += '{' + otherAttrs.join(', ') + '}';

    return attrs;
  }

  /**
   * Test if passed node has block-level sibling element
   * @param {AbbreviationNode} item
   * @return {Boolean}
   */
  function hasBlockSibling(item) {
    return item.parent && item.parent.hasBlockChildren();
  }

  /**
   * Processes element with <code>tag</code> type
   * @param {AbbreviationNode} item
   * @param {OutputProfile} profile
   * @param {Number} level Depth level
   */
  function processTag(item, profile, level) {
    if (!item.parent)
      // looks like it's root element
      return item;

    var abbrUtils = require('abbreviationUtils');
    var utils = require('utils');

    var attrs = makeAttributesString(item, profile);
    var cursor = profile.cursor();
    var isUnary = abbrUtils.isUnary(item);
    var selfClosing = profile.self_closing_tag && isUnary ? '/' : '';
    var start= '';

    // define tag name
    var tagName = '%' + profile.tagName(item.name());
    if (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)
      // omit div tag
      tagName = '';

    item.end = '';
    start = tagName + attrs + selfClosing + ' ';

    var placeholder = '%s';
    // We can't just replace placeholder with new value because
    // JavaScript will treat double $ character as a single one, assuming
    // we're using RegExp literal.
    item.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);

    if (!item.children.length && !isUnary)
      item.start += cursor;

    return item;
  }

  /**
   * Processes simplified tree, making it suitable for output as HTML structure
   * @param {AbbreviationNode} tree
   * @param {Object} profile
   * @param {Number} level Depth level
   */
  require('filters').add('haml', function process(tree, profile, level) {
    level = level || 0;
    var abbrUtils = require('abbreviationUtils');

    if (!level) {
      tree = require('filters').apply(tree, '_format', profile);
    }

    _.each(tree.children, function(item) {
      if (!abbrUtils.isSnippet(item))
        processTag(item, profile, level);

      process(item, profile, level + 1);
    });

    return tree;
  });
});/**
 * Filter that produces HTML tree
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 * @constructor
 * @memberOf __htmlFilterDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  /**
   * Creates HTML attributes string from tag according to profile settings
   * @param {AbbreviationNode} node
   * @param {OutputProfile} profile
   */
  function makeAttributesString(node, profile) {
    var attrQuote = profile.attributeQuote();
    var cursor = profile.cursor();

    return _.map(node.attributeList(), function(a) {
      var attrName = profile.attributeName(a.name);
      return ' ' + attrName + '=' + attrQuote + (a.value || cursor) + attrQuote;
    }).join('');
  }

  /**
   * Processes element with <code>tag</code> type
   * @param {AbbreviationNode} item
   * @param {OutputProfile} profile
   * @param {Number} level Depth level
   */
  function processTag(item, profile, level) {
    if (!item.parent) // looks like it's root element
      return item;

    var abbrUtils = require('abbreviationUtils');
    var utils = require('utils');

    var attrs = makeAttributesString(item, profile);
    var cursor = profile.cursor();
    var isUnary = abbrUtils.isUnary(item);
    var start= '';
    var end = '';

    // define opening and closing tags
    if (!item.isTextNode()) {
      var tagName = profile.tagName(item.name());
      if (isUnary) {
        start = '<' + tagName + attrs + profile.selfClosing() + '>';
        item.end = '';
      } else {
        start = '<' + tagName + attrs + '>';
        end = '</' + tagName + '>';
      }
    }

    var placeholder = '%s';
    // We can't just replace placeholder with new value because
    // JavaScript will treat double $ character as a single one, assuming
    // we're using RegExp literal.
    item.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);
    item.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);

    // should we put caret placeholder after opening tag?
    if (
        !item.children.length
        && !isUnary
        && !~item.content.indexOf(cursor)
        && !require('tabStops').extract(item.content).tabstops.length
      ) {
      item.start += cursor;
    }

    return item;
  }

  /**
   * Processes simplified tree, making it suitable for output as HTML structure
   * @param {AbbreviationNode} tree
   * @param {Object} profile
   * @param {Number} level Depth level
   */
  require('filters').add('html', function process(tree, profile, level) {
    level = level || 0;
    var abbrUtils = require('abbreviationUtils');

    if (!level) {
      tree = require('filters').apply(tree, '_format', profile);
    }

    _.each(tree.children, function(item) {
      if (!abbrUtils.isSnippet(item))
        processTag(item, profile, level);

      process(item, profile, level + 1);
    });

    return tree;
  });
});/**
 * Output abbreviation on a single line (i.e. no line breaks)
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 * @constructor
 * @memberOf __singleLineFilterDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  var rePad = /^\s+/;
  var reNl = /[\n\r]/g;

  require('filters').add('s', function process(tree, profile, level) {
    var abbrUtils = require('abbreviationUtils');

    _.each(tree.children, function(item) {
      if (!abbrUtils.isSnippet(item)) {
        // remove padding from item
        item.start = item.start.replace(rePad, '');
        item.end = item.end.replace(rePad, '');
      }

      // remove newlines
      item.start = item.start.replace(reNl, '');
      item.end = item.end.replace(reNl, '');
      item.content = item.content.replace(reNl, '');

      process(item);
    });

    return tree;
  });
});
/**
 * Trim filter: removes characters at the beginning of the text
 * content that indicates lists: numbers, #, *, -, etc.
 *
 * Useful for wrapping lists with abbreviation.
 *
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 *
 * @constructor
 * @memberOf __trimFilterDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  require('preferences').define('filter.trimRegexp', '[\\s|\\u00a0]*[\\d|#|\\-|\*|\\u2022]+\\.?\\s*',
      'Regular expression used to remove list markers (numbers, dashes, '
      + 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter '
      + 'is useful for wrapping with abbreviation lists, pased from other '
      + 'documents (for example, Word documents).');

  function process(tree, re) {
    _.each(tree.children, function(item) {
      if (item.content)
        item.content = item.content.replace(re, '');

      process(item, re);
    });

    return tree;
  }

  require('filters').add('t', function(tree) {
    var re = new RegExp(require('preferences').get('filter.trimRegexp'));
    return process(tree, re);
  });
});
/**
 * Filter for trimming "select" attributes from some tags that contains
 * child elements
 * @author Sergey Chikuyonok (serge.che@gmail.com)
 * @link http://chikuyonok.ru
 *
 * @constructor
 * @memberOf __xslFilterDefine
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.exec(function(require, _) {
  var tags = {
    'xsl:variable': 1,
    'xsl:with-param': 1
  };

  /**
   * Removes "select" attribute from node
   * @param {AbbreviationNode} node
   */
  function trimAttribute(node) {
    node.start = node.start.replace(/\s+select\s*=\s*(['"]).*?\1/, '');
  }

  require('filters').add('xsl', function process(tree) {
    var abbrUtils = require('abbreviationUtils');
    _.each(tree.children, function(item) {
      if (!abbrUtils.isSnippet(item)
          && (item.name() || '').toLowerCase() in tags
          && item.children.length)
        trimAttribute(item);
      process(item);
    });

    return tree;
  });
});/**
 * "Lorem ipsum" text generator. Matches <code>lipsum(num)?</code> or
 * <code>lorem(num)?</code> abbreviation.
 * This code is based on Django's contribution:
 * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py
 * <br><br>
 * Examples to test:<br>
 * <code>lipsum</code> â€“ generates 30 words text.<br>
 * <code>lipsum*6</code> â€“ generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>
 * <code>ol>lipsum10*5</code> â€” generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)
 * with text of 10 words on each line<br>
 * <code>span*3>lipsum20</code> â€“ generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element .
 * Each paragraph phrase is unique
 * @param {Function} require
 * @param {Underscore} _
 * @constructor
 * @memberOf __loremIpsumGeneratorDefine
 */
emmet.exec(function(require, _) {
  /**
   * @param {AbbreviationNode} tree
   * @param {Object} options
   */
  require('abbreviationParser').addPreprocessor(function(tree, options) {
    var re = /^(?:lorem|lipsum)(\d*)$/i, match;

    /** @param {AbbreviationNode} node */
    tree.findAll(function(node) {
      if (node._name && (match = node._name.match(re))) {
        var wordCound = match[1] || 30;

        // force node name resolving if node should be repeated
        // or contains attributes. In this case, node should be outputed
        // as tag, otherwise as text-only node
        node._name = '';
        node.data('forceNameResolving', node.isRepeating() || node.attributeList().length);
        node.data('pasteOverwrites', true);
        node.data('paste', function(i, content) {
          return paragraph(wordCound, !i);
        });
      }
    });
  });

  var COMMON_P = 'lorem ipsum dolor sit amet consectetur adipisicing elit'.split(' ');

  var WORDS = ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet',
               'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi',
               'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi',
               'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos',
               'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum',
               'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus',
               'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus',
               'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum',
               'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem',
               'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus',
               'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente',
               'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet',
               'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta',
               'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima',
               'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim',
               'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores',
               'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias',
               'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea',
               'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt',
               'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate',
               'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius',
               'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos',
               'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore',
               'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo',
               'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi',
               'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam',
               'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique',
               'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere',
               'maxime', 'corrupti'];

  /**
   * Returns random integer between <code>from</code> and <code>to</code> values
   * @param {Number} from
   * @param {Number} to
   * @returns {Number}
   */
  function randint(from, to) {
    return Math.round(Math.random() * (to - from) + from);
  }

  /**
   * @param {Array} arr
   * @param {Number} count
   * @returns {Array}
   */
  function sample(arr, count) {
    var len = arr.length;
    var iterations = Math.min(len, count);
    var result = [];
    while (result.length < iterations) {
      var randIx = randint(0, len - 1);
      if (!_.include(result, randIx))
        result.push(randIx);
    }

    return _.map(result, function(ix) {
      return arr[ix];
    });
  }

  function choice(val) {
    if (_.isString(val))
      return val.charAt(randint(0, val.length - 1));

    return val[randint(0, val.length - 1)];
  }

  function sentence(words, end) {
    if (words.length) {
      words[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);
    }

    return words.join(' ') + (end || choice('?!...')); // more dots that question marks
  }

  /**
   * Insert commas at randomly selected words. This function modifies values
   * inside <code>words</code> array
   * @param {Array} words
   */
  function insertCommas(words) {
    var len = words.length;
    var totalCommas = 0;

    if (len > 3 && len <= 6) {
      totalCommas = randint(0, 1);
    } else if (len > 6 && len <= 12) {
      totalCommas = randint(0, 2);
    } else {
      totalCommas = randint(1, 4);
    }

    _.each(sample(_.range(totalCommas)), function(ix) {
      words[ix] += ',';
    });
  }

  /**
   * Generate a paragraph of "Lorem ipsum" text
   * @param {Number} wordCount Words count in paragraph
   * @param {Boolean} startWithCommon Should paragraph start with common
   * "lorem ipsum" sentence.
   * @returns {String}
   */
  function paragraph(wordCount, startWithCommon) {
    var result = [];
    var totalWords = 0;
    var words;

    wordCount = parseInt(wordCount, 10);

    if (startWithCommon) {
      words = COMMON_P.slice(0, wordCount);
      if (words.length > 5)
        words[4] += ',';
      totalWords += words.length;
      result.push(sentence(words, '.'));
    }

    while (totalWords < wordCount) {
      words = sample(WORDS, Math.min(randint(3, 12) * randint(1, 5), wordCount - totalWords));
      totalWords += words.length;
      insertCommas(words);
      result.push(sentence(words));
    }

    return result.join(' ');
  }
});/**
 * Select current line (for simple editors like browser's &lt;textarea&gt;)
 */
emmet.exec(function(require, _) {
  require('actions').add('select_line', function(editor) {
    var range = editor.getCurrentLineRange();
    editor.createSelection(range.start, range.end);
    return true;
  });
});emmet.exec(function(require, _){require('resources').setVocabulary({
  "variables": {
    "lang": "en",
    "locale": "en-US",
    "charset": "UTF-8",
    "indentation": "\t",
    "newline": "\n"
  },

  "css": {
    "filters": "html",
    "snippets": {
      "@i": "@import url(|);",
      "@import": "@import url(|);",
      "@m": "@media ${1:screen} {\n\t|\n}",
      "@media": "@media ${1:screen} {\n\t|\n}",
      "@f": "@font-face {\n\tfont-family:|;\n\tsrc:url(|);\n}",
      "@f+": "@font-face {\n\tfont-family: '${1:FontName}';\n\tsrc: url('${2:FileName}.eot');\n\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\n\t\t url('${2:FileName}.woff') format('woff'),\n\t\t url('${2:FileName}.ttf') format('truetype'),\n\t\t url('${2:FileName}.svg#${1:FontName}') format('svg');\n\tfont-style: ${3:normal};\n\tfont-weight: ${4:normal};\n}",

      "@kf": "@-webkit-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@-o-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@-moz-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}",


      "anim": "animation:|;",
      "anim-": "animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};",
      "animdel": "animation-delay:${1:time};",

      "animdir": "animation-direction:${1:normal};",
      "animdir:n": "animation-direction:normal;",
      "animdir:r": "animation-direction:reverse;",
      "animdir:a": "animation-direction:alternate;",
      "animdir:ar": "animation-direction:alternate-reverse;",

      "animdur": "animation-duration:${1:0}s;",

      "animfm": "animation-fill-mode:${1:both};",
      "animfm:f": "animation-fill-mode:forwards;",
      "animfm:b": "animation-fill-mode:backwards;",
      "animfm:bt": "animation-fill-mode:both;",
      "animfm:bh": "animation-fill-mode:both;",

      "animic": "animation-iteration-count:${1:1};",
      "animic:i": "animation-iteration-count:infinite;",

      "animn": "animation-name:${1:none};",

      "animps": "animation-play-state:${1:running};",
      "animps:p": "animation-play-state:paused;",
      "animps:r": "animation-play-state:running;",

      "animtf": "animation-timing-function:${1:linear};",
      "animtf:e": "animation-timing-function:ease;",
      "animtf:ei": "animation-timing-function:ease-in;",
      "animtf:eo": "animation-timing-function:ease-out;",
      "animtf:eio": "animation-timing-function:ease-in-out;",
      "animtf:l": "animation-timing-function:linear;",
      "animtf:cb": "animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});",

      "ap": "appearance:${none}",

      "!": "!important",
      "pos": "position:${1:relative};",
      "pos:s": "position:static;",
      "pos:a": "position:absolute;",
      "pos:r": "position:relative;",
      "pos:f": "position:fixed;",
      "t": "top:|;",
      "t:a": "top:auto;",
      "r": "right:|;",
      "r:a": "right:auto;",
      "b": "bottom:|;",
      "b:a": "bottom:auto;",
      "l": "left:|;",
      "l:a": "left:auto;",
      "z": "z-index:|;",
      "z:a": "z-index:auto;",
      "fl": "float:${1:left};",
      "fl:n": "float:none;",
      "fl:l": "float:left;",
      "fl:r": "float:right;",
      "cl": "clear:${1:both};",
      "cl:n": "clear:none;",
      "cl:l": "clear:left;",
      "cl:r": "clear:right;",
      "cl:b": "clear:both;",

      "colm": "columns:|;",
      "colmc": "column-count:|;",
      "colmf": "column-fill:|;",
      "colmg": "column-gap:|;",
      "colmr": "column-rule:|;",
      "colmrc": "column-rule-color:|;",
      "colmrs": "column-rule-style:|;",
      "colmrw": "column-rule-width:|;",
      "colms": "column-span:|;",
      "colmw": "column-width:|;",

      "d": "display:${1:block};",
      "d:n": "display:none;",
      "d:b": "display:block;",
      "d:i": "display:inline;",
      "d:ib": "display:inline-block;",
      "d:li": "display:list-item;",
      "d:ri": "display:run-in;",
      "d:cp": "display:compact;",
      "d:tb": "display:table;",
      "d:itb": "display:inline-table;",
      "d:tbcp": "display:table-caption;",
      "d:tbcl": "display:table-column;",
      "d:tbclg": "display:table-column-group;",
      "d:tbhg": "display:table-header-group;",
      "d:tbfg": "display:table-footer-group;",
      "d:tbr": "display:table-row;",
      "d:tbrg": "display:table-row-group;",
      "d:tbc": "display:table-cell;",
      "d:rb": "display:ruby;",
      "d:rbb": "display:ruby-base;",
      "d:rbbg": "display:ruby-base-group;",
      "d:rbt": "display:ruby-text;",
      "d:rbtg": "display:ruby-text-group;",
      "v": "visibility:${1:hidden};",
      "v:v": "visibility:visible;",
      "v:h": "visibility:hidden;",
      "v:c": "visibility:collapse;",
      "ov": "overflow:${1:hidden};",
      "ov:v": "overflow:visible;",
      "ov:h": "overflow:hidden;",
      "ov:s": "overflow:scroll;",
      "ov:a": "overflow:auto;",
      "ovx": "overflow-x:${1:hidden};",
      "ovx:v": "overflow-x:visible;",
      "ovx:h": "overflow-x:hidden;",
      "ovx:s": "overflow-x:scroll;",
      "ovx:a": "overflow-x:auto;",
      "ovy": "overflow-y:${1:hidden};",
      "ovy:v": "overflow-y:visible;",
      "ovy:h": "overflow-y:hidden;",
      "ovy:s": "overflow-y:scroll;",
      "ovy:a": "overflow-y:auto;",
      "ovs": "overflow-style:${1:scrollbar};",
      "ovs:a": "overflow-style:auto;",
      "ovs:s": "overflow-style:scrollbar;",
      "ovs:p": "overflow-style:panner;",
      "ovs:m": "overflow-style:move;",
      "ovs:mq": "overflow-style:marquee;",
      "zoo": "zoom:1;",
      "zm": "zoom:1;",
      "cp": "clip:|;",
      "cp:a": "clip:auto;",
      "cp:r": "clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});",
      "bxz": "box-sizing:${1:border-box};",
      "bxz:cb": "box-sizing:content-box;",
      "bxz:bb": "box-sizing:border-box;",
      "bxsh": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};",
      "bxsh:r": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});",
      "bxsh:ra": "box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});",
      "bxsh:n": "box-shadow:none;",
      "m": "margin:|;",
      "m:a": "margin:auto;",
      "mt": "margin-top:|;",
      "mt:a": "margin-top:auto;",
      "mr": "margin-right:|;",
      "mr:a": "margin-right:auto;",
      "mb": "margin-bottom:|;",
      "mb:a": "margin-bottom:auto;",
      "ml": "margin-left:|;",
      "ml:a": "margin-left:auto;",
      "p": "padding:|;",
      "pt": "padding-top:|;",
      "pr": "padding-right:|;",
      "pb": "padding-bottom:|;",
      "pl": "padding-left:|;",
      "w": "width:|;",
      "w:a": "width:auto;",
      "h": "height:|;",
      "h:a": "height:auto;",
      "maw": "max-width:|;",
      "maw:n": "max-width:none;",
      "mah": "max-height:|;",
      "mah:n": "max-height:none;",
      "miw": "min-width:|;",
      "mih": "min-height:|;",
      "mar": "max-resolution:${1:res};",
      "mir": "min-resolution:${1:res};",
      "ori": "orientation:|;",
      "ori:l": "orientation:landscape;",
      "ori:p": "orientation:portrait;",
      "ol": "outline:|;",
      "ol:n": "outline:none;",
      "olo": "outline-offset:|;",
      "olw": "outline-width:|;",
      "ols": "outline-style:|;",
      "olc": "outline-color:#${1:000};",
      "olc:i": "outline-color:invert;",
      "bd": "border:|;",
      "bd+": "border:${1:1px} ${2:solid} ${3:#000};",
      "bd:n": "border:none;",
      "bdbk": "border-break:${1:close};",
      "bdbk:c": "border-break:close;",
      "bdcl": "border-collapse:|;",
      "bdcl:c": "border-collapse:collapse;",
      "bdcl:s": "border-collapse:separate;",
      "bdc": "border-color:#${1:000};",
      "bdc:t": "border-color:transparent;",
      "bdi": "border-image:url(|);",
      "bdi:n": "border-image:none;",
      "bdti": "border-top-image:url(|);",
      "bdti:n": "border-top-image:none;",
      "bdri": "border-right-image:url(|);",
      "bdri:n": "border-right-image:none;",
      "bdbi": "border-bottom-image:url(|);",
      "bdbi:n": "border-bottom-image:none;",
      "bdli": "border-left-image:url(|);",
      "bdli:n": "border-left-image:none;",
      "bdci": "border-corner-image:url(|);",
      "bdci:n": "border-corner-image:none;",
      "bdci:c": "border-corner-image:continue;",
      "bdtli": "border-top-left-image:url(|);",
      "bdtli:n": "border-top-left-image:none;",
      "bdtli:c": "border-top-left-image:continue;",
      "bdtri": "border-top-right-image:url(|);",
      "bdtri:n": "border-top-right-image:none;",
      "bdtri:c": "border-top-right-image:continue;",
      "bdbri": "border-bottom-right-image:url(|);",
      "bdbri:n": "border-bottom-right-image:none;",
      "bdbri:c": "border-bottom-right-image:continue;",
      "bdbli": "border-bottom-left-image:url(|);",
      "bdbli:n": "border-bottom-left-image:none;",
      "bdbli:c": "border-bottom-left-image:continue;",
      "bdf": "border-fit:${1:repeat};",
      "bdf:c": "border-fit:clip;",
      "bdf:r": "border-fit:repeat;",
      "bdf:sc": "border-fit:scale;",
      "bdf:st": "border-fit:stretch;",
      "bdf:ow": "border-fit:overwrite;",
      "bdf:of": "border-fit:overflow;",
      "bdf:sp": "border-fit:space;",
      "bdlen": "border-length:|;",
      "bdlen:a": "border-length:auto;",
      "bdsp": "border-spacing:|;",
      "bds": "border-style:|;",
      "bds:n": "border-style:none;",
      "bds:h": "border-style:hidden;",
      "bds:dt": "border-style:dotted;",
      "bds:ds": "border-style:dashed;",
      "bds:s": "border-style:solid;",
      "bds:db": "border-style:double;",
      "bds:dtds": "border-style:dot-dash;",
      "bds:dtdtds": "border-style:dot-dot-dash;",
      "bds:w": "border-style:wave;",
      "bds:g": "border-style:groove;",
      "bds:r": "border-style:ridge;",
      "bds:i": "border-style:inset;",
      "bds:o": "border-style:outset;",
      "bdw": "border-width:|;",
      "bdtw": "border-top-width:|;",
      "bdrw": "border-right-width:|;",
      "bdbw": "border-bottom-width:|;",
      "bdlw": "border-left-width:|;",
      "bdt": "border-top:|;",
      "bt": "border-top:|;",
      "bdt+": "border-top:${1:1px} ${2:solid} ${3:#000};",
      "bdt:n": "border-top:none;",
      "bdts": "border-top-style:|;",
      "bdts:n": "border-top-style:none;",
      "bdtc": "border-top-color:#${1:000};",
      "bdtc:t": "border-top-color:transparent;",
      "bdr": "border-right:|;",
      "br": "border-right:|;",
      "bdr+": "border-right:${1:1px} ${2:solid} ${3:#000};",
      "bdr:n": "border-right:none;",
      "bdrst": "border-right-style:|;",
      "bdrst:n": "border-right-style:none;",
      "bdrc": "border-right-color:#${1:000};",
      "bdrc:t": "border-right-color:transparent;",
      "bdb": "border-bottom:|;",
      "bb": "border-bottom:|;",
      "bdb+": "border-bottom:${1:1px} ${2:solid} ${3:#000};",
      "bdb:n": "border-bottom:none;",
      "bdbs": "border-bottom-style:|;",
      "bdbs:n": "border-bottom-style:none;",
      "bdbc": "border-bottom-color:#${1:000};",
      "bdbc:t": "border-bottom-color:transparent;",
      "bdl": "border-left:|;",
      "bl": "border-left:|;",
      "bdl+": "border-left:${1:1px} ${2:solid} ${3:#000};",
      "bdl:n": "border-left:none;",
      "bdls": "border-left-style:|;",
      "bdls:n": "border-left-style:none;",
      "bdlc": "border-left-color:#${1:000};",
      "bdlc:t": "border-left-color:transparent;",
      "bdrs": "border-radius:|;",
      "bdtrrs": "border-top-right-radius:|;",
      "bdtlrs": "border-top-left-radius:|;",
      "bdbrrs": "border-bottom-right-radius:|;",
      "bdblrs": "border-bottom-left-radius:|;",
      "bg": "background:|;",
      "bg+": "background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};",
      "bg:n": "background:none;",
      "bg:ie": "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');",
      "bgc": "background-color:#${1:fff};",
      "bgc:t": "background-color:transparent;",
      "bgi": "background-image:url(|);",
      "bgi:n": "background-image:none;",
      "bgr": "background-repeat:|;",
      "bgr:n": "background-repeat:no-repeat;",
      "bgr:x": "background-repeat:repeat-x;",
      "bgr:y": "background-repeat:repeat-y;",
      "bgr:sp": "background-repeat:space;",
      "bgr:rd": "background-repeat:round;",
      "bga": "background-attachment:|;",
      "bga:f": "background-attachment:fixed;",
      "bga:s": "background-attachment:scroll;",
      "bgp": "background-position:${1:0} ${2:0};",
      "bgpx": "background-position-x:|;",
      "bgpy": "background-position-y:|;",
      "bgbk": "background-break:|;",
      "bgbk:bb": "background-break:bounding-box;",
      "bgbk:eb": "background-break:each-box;",
      "bgbk:c": "background-break:continuous;",
      "bgcp": "background-clip:${1:padding-box};",
      "bgcp:bb": "background-clip:border-box;",
      "bgcp:pb": "background-clip:padding-box;",
      "bgcp:cb": "background-clip:content-box;",
      "bgcp:nc": "background-clip:no-clip;",
      "bgo": "background-origin:|;",
      "bgo:pb": "background-origin:padding-box;",
      "bgo:bb": "background-origin:border-box;",
      "bgo:cb": "background-origin:content-box;",
      "bgsz": "background-size:|;",
      "bgsz:a": "background-size:auto;",
      "bgsz:ct": "background-size:contain;",
      "bgsz:cv": "background-size:cover;",
      "c": "color:#${1:000};",
      "c:r": "color:rgb(${1:0}, ${2:0}, ${3:0});",
      "c:ra": "color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});",
      "cm": "/* |${child} */",
      "cnt": "content:'|';",
      "cnt:n": "content:normal;",
      "cnt:oq": "content:open-quote;",
      "cnt:noq": "content:no-open-quote;",
      "cnt:cq": "content:close-quote;",
      "cnt:ncq": "content:no-close-quote;",
      "cnt:a": "content:attr(|);",
      "cnt:c": "content:counter(|);",
      "cnt:cs": "content:counters(|);",


      "tbl": "table-layout:|;",
      "tbl:a": "table-layout:auto;",
      "tbl:f": "table-layout:fixed;",
      "cps": "caption-side:|;",
      "cps:t": "caption-side:top;",
      "cps:b": "caption-side:bottom;",
      "ec": "empty-cells:|;",
      "ec:s": "empty-cells:show;",
      "ec:h": "empty-cells:hide;",
      "lis": "list-style:|;",
      "lis:n": "list-style:none;",
      "lisp": "list-style-position:|;",
      "lisp:i": "list-style-position:inside;",
      "lisp:o": "list-style-position:outside;",
      "list": "list-style-type:|;",
      "list:n": "list-style-type:none;",
      "list:d": "list-style-type:disc;",
      "list:c": "list-style-type:circle;",
      "list:s": "list-style-type:square;",
      "list:dc": "list-style-type:decimal;",
      "list:dclz": "list-style-type:decimal-leading-zero;",
      "list:lr": "list-style-type:lower-roman;",
      "list:ur": "list-style-type:upper-roman;",
      "lisi": "list-style-image:|;",
      "lisi:n": "list-style-image:none;",
      "q": "quotes:|;",
      "q:n": "quotes:none;",
      "q:ru": "quotes:'\\00AB' '\\00BB' '\\201E' '\\201C';",
      "q:en": "quotes:'\\201C' '\\201D' '\\2018' '\\2019';",
      "ct": "content:|;",
      "ct:n": "content:normal;",
      "ct:oq": "content:open-quote;",
      "ct:noq": "content:no-open-quote;",
      "ct:cq": "content:close-quote;",
      "ct:ncq": "content:no-close-quote;",
      "ct:a": "content:attr(|);",
      "ct:c": "content:counter(|);",
      "ct:cs": "content:counters(|);",
      "coi": "counter-increment:|;",
      "cor": "counter-reset:|;",
      "va": "vertical-align:${1:top};",
      "va:sup": "vertical-align:super;",
      "va:t": "vertical-align:top;",
      "va:tt": "vertical-align:text-top;",
      "va:m": "vertical-align:middle;",
      "va:bl": "vertical-align:baseline;",
      "va:b": "vertical-align:bottom;",
      "va:tb": "vertical-align:text-bottom;",
      "va:sub": "vertical-align:sub;",
      "ta": "text-align:${1:left};",
      "ta:l": "text-align:left;",
      "ta:c": "text-align:center;",
      "ta:r": "text-align:right;",
      "ta:j": "text-align:justify;",
      "ta-lst": "text-align-last:|;",
      "tal:a": "text-align-last:auto;",
      "tal:l": "text-align-last:left;",
      "tal:c": "text-align-last:center;",
      "tal:r": "text-align-last:right;",
      "td": "text-decoration:${1:none};",
      "td:n": "text-decoration:none;",
      "td:u": "text-decoration:underline;",
      "td:o": "text-decoration:overline;",
      "td:l": "text-decoration:line-through;",
      "te": "text-emphasis:|;",
      "te:n": "text-emphasis:none;",
      "te:ac": "text-emphasis:accent;",
      "te:dt": "text-emphasis:dot;",
      "te:c": "text-emphasis:circle;",
      "te:ds": "text-emphasis:disc;",
      "te:b": "text-emphasis:before;",
      "te:a": "text-emphasis:after;",
      "th": "text-height:|;",
      "th:a": "text-height:auto;",
      "th:f": "text-height:font-size;",
      "th:t": "text-height:text-size;",
      "th:m": "text-height:max-size;",
      "ti": "text-indent:|;",
      "ti:-": "text-indent:-9999px;",
      "tj": "text-justify:|;",
      "tj:a": "text-justify:auto;",
      "tj:iw": "text-justify:inter-word;",
      "tj:ii": "text-justify:inter-ideograph;",
      "tj:ic": "text-justify:inter-cluster;",
      "tj:d": "text-justify:distribute;",
      "tj:k": "text-justify:kashida;",
      "tj:t": "text-justify:tibetan;",
      "tov": "text-overflow:${ellipsis};",
      "tov:e": "text-overflow:ellipsis;",
      "tov:c": "text-overflow:clip;",
      "to": "text-outline:|;",
      "to+": "text-outline:${1:0} ${2:0} ${3:#000};",
      "to:n": "text-outline:none;",
      "tr": "text-replace:|;",
      "tr:n": "text-replace:none;",
      "tt": "text-transform:${1:uppercase};",
      "tt:n": "text-transform:none;",
      "tt:c": "text-transform:capitalize;",
      "tt:u": "text-transform:uppercase;",
      "tt:l": "text-transform:lowercase;",
      "tw": "text-wrap:|;",
      "tw:n": "text-wrap:normal;",
      "tw:no": "text-wrap:none;",
      "tw:u": "text-wrap:unrestricted;",
      "tw:s": "text-wrap:suppress;",
      "tsh": "text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};",
      "tsh:r": "text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});",
      "tsh:ra": "text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});",
      "tsh+": "text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};",
      "tsh:n": "text-shadow:none;",
      "trf": "transform:|;",
      "trf:skx": "transform: skewX(${1:angle});",
      "trf:sky": "transform: skewY(${1:angle});",
      "trf:sc": "transform: scale(${1:x}, ${2:y});",
      "trf:scx": "transform: scaleX(${1:x});",
      "trf:scy": "transform: scaleY(${1:y});",
      "trf:r": "transform: rotate(${1:angle});",
      "trf:t": "transform: translate(${1:x}, ${2:y});",
      "trf:tx": "transform: translateX(${1:x});",
      "trf:ty": "transform: translateY(${1:y});",
      "trfo": "transform-origin:|;",
      "trfs": "transform-style:${1:preserve-3d};",
      "trs": "transition:${1:prop} ${2:time};",
      "trsde": "transition-delay:${1:time};",
      "trsdu": "transition-duration:${1:time};",
      "trsp": "transition-property:${1:prop};",
      "trstf": "transition-timing-function:${1:tfunc};",
      "lh": "line-height:|;",
      "whs": "white-space:|;",
      "whs:n": "white-space:normal;",
      "whs:p": "white-space:pre;",
      "whs:nw": "white-space:nowrap;",
      "whs:pw": "white-space:pre-wrap;",
      "whs:pl": "white-space:pre-line;",
      "whsc": "white-space-collapse:|;",
      "whsc:n": "white-space-collapse:normal;",
      "whsc:k": "white-space-collapse:keep-all;",
      "whsc:l": "white-space-collapse:loose;",
      "whsc:bs": "white-space-collapse:break-strict;",
      "whsc:ba": "white-space-collapse:break-all;",
      "wob": "word-break:|;",
      "wob:n": "word-break:normal;",
      "wob:k": "word-break:keep-all;",
      "wob:l": "word-break:loose;",
      "wob:bs": "word-break:break-strict;",
      "wob:ba": "word-break:break-all;",
      "wos": "word-spacing:|;",
      "wow": "word-wrap:|;",
      "wow:nm": "word-wrap:normal;",
      "wow:n": "word-wrap:none;",
      "wow:u": "word-wrap:unrestricted;",
      "wow:s": "word-wrap:suppress;",
      "lts": "letter-spacing:|;",
      "f": "font:|;",
      "f+": "font:${1:1em} ${2:Arial,sans-serif};",
      "fw": "font-weight:|;",
      "fw:n": "font-weight:normal;",
      "fw:b": "font-weight:bold;",
      "fw:br": "font-weight:bolder;",
      "fw:lr": "font-weight:lighter;",
      "fs": "font-style:${italic};",
      "fs:n": "font-style:normal;",
      "fs:i": "font-style:italic;",
      "fs:o": "font-style:oblique;",
      "fv": "font-variant:|;",
      "fv:n": "font-variant:normal;",
      "fv:sc": "font-variant:small-caps;",
      "fz": "font-size:|;",
      "fza": "font-size-adjust:|;",
      "fza:n": "font-size-adjust:none;",
      "ff": "font-family:|;",
      "ff:s": "font-family:serif;",
      "ff:ss": "font-family:sans-serif;",
      "ff:c": "font-family:cursive;",
      "ff:f": "font-family:fantasy;",
      "ff:m": "font-family:monospace;",
      "fef": "font-effect:|;",
      "fef:n": "font-effect:none;",
      "fef:eg": "font-effect:engrave;",
      "fef:eb": "font-effect:emboss;",
      "fef:o": "font-effect:outline;",
      "fem": "font-emphasize:|;",
      "femp": "font-emphasize-position:|;",
      "femp:b": "font-emphasize-position:before;",
      "femp:a": "font-emphasize-position:after;",
      "fems": "font-emphasize-style:|;",
      "fems:n": "font-emphasize-style:none;",
      "fems:ac": "font-emphasize-style:accent;",
      "fems:dt": "font-emphasize-style:dot;",
      "fems:c": "font-emphasize-style:circle;",
      "fems:ds": "font-emphasize-style:disc;",
      "fsm": "font-smooth:|;",
      "fsm:a": "font-smooth:auto;",
      "fsm:n": "font-smooth:never;",
      "fsm:aw": "font-smooth:always;",
      "fst": "font-stretch:|;",
      "fst:n": "font-stretch:normal;",
      "fst:uc": "font-stretch:ultra-condensed;",
      "fst:ec": "font-stretch:extra-condensed;",
      "fst:c": "font-stretch:condensed;",
      "fst:sc": "font-stretch:semi-condensed;",
      "fst:se": "font-stretch:semi-expanded;",
      "fst:e": "font-stretch:expanded;",
      "fst:ee": "font-stretch:extra-expanded;",
      "fst:ue": "font-stretch:ultra-expanded;",
      "op": "opacity:|;",
      "op:ie": "filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);",
      "op:ms": "-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';",
      "rsz": "resize:|;",
      "rsz:n": "resize:none;",
      "rsz:b": "resize:both;",
      "rsz:h": "resize:horizontal;",
      "rsz:v": "resize:vertical;",
      "cur": "cursor:${pointer};",
      "cur:a": "cursor:auto;",
      "cur:d": "cursor:default;",
      "cur:c": "cursor:crosshair;",
      "cur:ha": "cursor:hand;",
      "cur:he": "cursor:help;",
      "cur:m": "cursor:move;",
      "cur:p": "cursor:pointer;",
      "cur:t": "cursor:text;",
      "pgbb": "page-break-before:|;",
      "pgbb:au": "page-break-before:auto;",
      "pgbb:al": "page-break-before:always;",
      "pgbb:l": "page-break-before:left;",
      "pgbb:r": "page-break-before:right;",
      "pgbi": "page-break-inside:|;",
      "pgbi:au": "page-break-inside:auto;",
      "pgbi:av": "page-break-inside:avoid;",
      "pgba": "page-break-after:|;",
      "pgba:au": "page-break-after:auto;",
      "pgba:al": "page-break-after:always;",
      "pgba:l": "page-break-after:left;",
      "pgba:r": "page-break-after:right;",
      "orp": "orphans:|;",
      "us": "user-select:${none};",
      "wid": "widows:|;",
      "wfsm": "-webkit-font-smoothing:${antialiased};",
      "wfsm:a": "-webkit-font-smoothing:antialiased;",
      "wfsm:s": "-webkit-font-smoothing:subpixel-antialiased;",
      "wfsm:sa": "-webkit-font-smoothing:subpixel-antialiased;",
      "wfsm:n": "-webkit-font-smoothing:none;"
    }
  },

  "html": {
    "filters": "html",
    "profile": "html",
    "snippets": {
      "!!!":    "<!doctype html>",
      "!!!4t":  "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">",
      "!!!4s":  "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">",
      "!!!xt":  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">",
      "!!!xs":  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
      "!!!xxs": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">",

      "c": "<!-- |${child} -->",
      "cc:ie6": "<!--[if lte IE 6]>\n\t${child}|\n<![endif]-->",
      "cc:ie": "<!--[if IE]>\n\t${child}|\n<![endif]-->",
      "cc:noie": "<!--[if !IE]><!-->\n\t${child}|\n<!--<![endif]-->"
    },

    "abbreviations": {
      "!": "html:5",
      "a": "<a href=\"\">",
      "a:link": "<a href=\"http://|\">",
      "a:mail": "<a href=\"mailto:|\">",
      "abbr": "<abbr title=\"\">",
      "acronym": "<acronym title=\"\">",
      "base": "<base href=\"\" />",
      "bdo": "<bdo dir=\"\">",
      "bdo:r": "<bdo dir=\"rtl\">",
      "bdo:l": "<bdo dir=\"ltr\">",
      "link": "<link rel=\"stylesheet\" href=\"\" />",
      "link:css": "<link rel=\"stylesheet\" href=\"${1:style}.css\" media=\"all\" />",
      "link:print": "<link rel=\"stylesheet\" href=\"${1:print}.css\" media=\"print\" />",
      "link:favicon": "<link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"${1:favicon.ico}\" />",
      "link:touch": "<link rel=\"apple-touch-icon\" href=\"${1:favicon.png}\" />",
      "link:rss": "<link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"${1:rss.xml}\" />",
      "link:atom": "<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Atom\" href=\"${1:atom.xml}\" />",
      "meta:utf": "<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />",
      "meta:win": "<meta http-equiv=\"Content-Type\" content=\"text/html;charset=windows-1251\" />",
      "meta:vp": "<meta name=\"viewport\" content=\"width=${1:device-width}, user-scalable=${2:no}, initial-scale=${3:1.0}, maximum-scale=${4:1.0}, minimum-scale=${5:1.0}\" />",
      "meta:compat": "<meta http-equiv=\"X-UA-Compatible\" content=\"${1:IE=7}\" />",
      "style": "<style>",
      "script": "<script>",
      "script:src": "<script src=\"\">",
      "img": "<img src=\"\" alt=\"\" />",
      "iframe": "<iframe src=\"\" frameborder=\"0\">",
      "embed": "<embed src=\"\" type=\"\" />",
      "object": "<object data=\"\" type=\"\">",
      "param": "<param name=\"\" value=\"\" />",
      "map": "<map name=\"\">",
      "area": "<area shape=\"\" coords=\"\" href=\"\" alt=\"\" />",
      "area:d": "<area shape=\"default\" href=\"\" alt=\"\" />",
      "area:c": "<area shape=\"circle\" coords=\"\" href=\"\" alt=\"\" />",
      "area:r": "<area shape=\"rect\" coords=\"\" href=\"\" alt=\"\" />",
      "area:p": "<area shape=\"poly\" coords=\"\" href=\"\" alt=\"\" />",
      "form": "<form action=\"\">",
      "form:get": "<form action=\"\" method=\"get\">",
      "form:post": "<form action=\"\" method=\"post\">",
      "label": "<label for=\"\">",
      "input": "<input type=\"${1:text}\" />",
      "inp": "<input type=\"${1:text}\" name=\"\" id=\"\" />",
      "input:hidden": "input[type=hidden name]",
      "input:h": "input:hidden",
      "input:text": "inp",
      "input:t": "inp",
      "input:search": "inp[type=search]",
      "input:email": "inp[type=email]",
      "input:url": "inp[type=url]",
      "input:password": "inp[type=password]",
      "input:p": "input:password",
      "input:datetime": "inp[type=datetime]",
      "input:date": "inp[type=date]",
      "input:datetime-local": "inp[type=datetime-local]",
      "input:month": "inp[type=month]",
      "input:week": "inp[type=week]",
      "input:time": "inp[type=time]",
      "input:number": "inp[type=number]",
      "input:color": "inp[type=color]",
      "input:checkbox": "inp[type=checkbox]",
      "input:c": "input:checkbox",
      "input:radio": "inp[type=radio]",
      "input:r": "input:radio",
      "input:range": "inp[type=range]",
      "input:file": "inp[type=file]",
      "input:f": "input:file",
      "input:submit": "<input type=\"submit\" value=\"\" />",
      "input:s": "input:submit",
      "input:image": "<input type=\"image\" src=\"\" alt=\"\" />",
      "input:i": "input:image",
      "input:button": "<input type=\"button\" value=\"\" />",
      "input:b": "input:button",
      "input:reset": "input:button[type=reset]",
      "select": "<select name=\"\" id=\"\">",
      "option": "<option value=\"\">",
      "textarea": "<textarea name=\"\" id=\"\" cols=\"${1:30}\" rows=\"${2:10}\">",
      "menu:context": "menu[type=context]>",
      "menu:c": "menu:context",
      "menu:toolbar": "menu[type=toolbar]>",
      "menu:t": "menu:toolbar",
      "video": "<video src=\"\">",
      "audio": "<audio src=\"\">",
      "html:xml": "<html xmlns=\"http://www.w3.org/1999/xhtml\">",

      "bq": "blockquote",
      "acr": "acronym",
      "fig": "figure",
      "figc": "figcaption",
      "ifr": "iframe",
      "emb": "embed",
      "obj": "object",
      "src": "source",
      "cap": "caption",
      "colg": "colgroup",
      "fst": "fieldset",
      "btn": "button",
      "optg": "optgroup",
      "opt": "option",
      "tarea": "textarea",
      "leg": "legend",
      "sect": "section",
      "art": "article",
      "hdr": "header",
      "ftr": "footer",
      "adr": "address",
      "dlg": "dialog",
      "str": "strong",
      "prog": "progress",
      "fset": "fieldset",
      "datag": "datagrid",
      "datal": "datalist",
      "kg": "keygen",
      "out": "output",
      "det": "details",
      "cmd": "command",
      "doc": "html>(head>meta[charset=UTF-8]+title{${1:Document}})+body",
      "doc4": "html>(head>meta[http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\"]+title{${1:Document}})",

      "html:4t":  "!!!4t+doc4[lang=${lang}]",
      "html:4s":  "!!!4s+doc4[lang=${lang}]",
      "html:xt":  "!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]",
      "html:xs":  "!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]",
      "html:xxs": "!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]",
      "html:5":   "!!!+doc[lang=${lang}]",

      "ol+": "ol>li",
      "ul+": "ul>li",
      "dl+": "dl>dt+dd",
      "map+": "map>area",
      "table+": "table>tr>td",
      "colgroup+": "colgroup>col",
      "colg+": "colgroup>col",
      "tr+": "tr>td",
      "select+": "select>option",
      "optgroup+": "optgroup>option",
      "optg+": "optgroup>option"
    }
  },

  "xml": {
    "extends": "html",
    "profile": "xml",
    "filters": "html"
  },

  "xsl": {
    "extends": "html",
    "profile": "xml",
    "filters": "html, xsl",
    "abbreviations": {
      "tm": "<xsl:template match=\"\" mode=\"\">",
      "tmatch": "tm",
      "tn": "<xsl:template name=\"\">",
      "tname": "tn",
      "call": "<xsl:call-template name=\"\"/>",
      "ap": "<xsl:apply-templates select=\"\" mode=\"\"/>",
      "api": "<xsl:apply-imports/>",
      "imp": "<xsl:import href=\"\"/>",
      "inc": "<xsl:include href=\"\"/>",

      "ch": "<xsl:choose>",
      "xsl:when": "<xsl:when test=\"\">",
      "wh": "xsl:when",
      "ot": "<xsl:otherwise>",
      "if": "<xsl:if test=\"\">",

      "par": "<xsl:param name=\"\">",
      "pare": "<xsl:param name=\"\" select=\"\"/>",
      "var": "<xsl:variable name=\"\">",
      "vare": "<xsl:variable name=\"\" select=\"\"/>",
      "wp": "<xsl:with-param name=\"\" select=\"\"/>",
      "key": "<xsl:key name=\"\" match=\"\" use=\"\"/>",

      "elem": "<xsl:element name=\"\">",
      "attr": "<xsl:attribute name=\"\">",
      "attrs": "<xsl:attribute-set name=\"\">",

      "cp": "<xsl:copy select=\"\"/>",
      "co": "<xsl:copy-of select=\"\"/>",
      "val": "<xsl:value-of select=\"\"/>",
      "each": "<xsl:for-each select=\"\">",
      "for": "each",
      "tex": "<xsl:text></xsl:text>",

      "com": "<xsl:comment>",
      "msg": "<xsl:message terminate=\"no\">",
      "fall": "<xsl:fallback>",
      "num": "<xsl:number value=\"\"/>",
      "nam": "<namespace-alias stylesheet-prefix=\"\" result-prefix=\"\"/>",
      "pres": "<xsl:preserve-space elements=\"\"/>",
      "strip": "<xsl:strip-space elements=\"\"/>",
      "proc": "<xsl:processing-instruction name=\"\">",
      "sort": "<xsl:sort select=\"\" order=\"\"/>",

      "choose+": "xsl:choose>xsl:when+xsl:otherwise",
      "xsl": "!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\n|}"
    },
    "snippets": {
      "!!!": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
    }
  },

  "haml": {
    "filters": "haml",
    "extends": "html",
    "profile": "xml"
  },

  "scss": {
    "extends": "css"
  },

  "sass": {
    "extends": "css"
  },

  "less": {
    "extends": "css"
  },

  "stylus": {
    "extends": "css"
  }
}
, 'system');});/**
 * Implementation of {@link IEmmetEditor} interface for CodeMirror2
 * @param {Function} require
 * @param {Underscore} _
 */
emmet.define('cm-editor-proxy', function(require, _) {
  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var keymap = {
    'Cmd-E': 'expand_abbreviation',
    'Tab': 'expand_abbreviation_with_tab',
    'Cmd-D': 'match_pair_outward',
    'Shift-Cmd-D': 'match_pair_inward',
    'Cmd-T': 'matching_pair',
    'Shift-Cmd-A': 'wrap_with_abbreviation',
    'Ctrl-Alt-Right': 'next_edit_point',
    'Ctrl-Alt-Left': 'prev_edit_point',
    'Cmd-L': 'select_line',
    'Cmd-Shift-M': 'merge_lines',
    'Cmd-/': 'toggle_comment',
    'Cmd-J': 'split_join_tag',
    'Cmd-K': 'remove_tag',
    'Shift-Cmd-Y': 'evaluate_math_expression',

    'Ctrl-Up': 'increment_number_by_1',
    'Ctrl-Down': 'decrement_number_by_1',
    'Alt-Up': 'increment_number_by_01',
    'Alt-Down': 'decrement_number_by_01',
    'Ctrl-Alt-Up': 'increment_number_by_10',
    'Ctrl-Alt-Down': 'decrement_number_by_10',

    'Shift-Cmd-.': 'select_next_item',
    'Shift-Cmd-,': 'select_previous_item',
    'Cmd-B': 'reflect_css_value',

    'Enter': 'insert_formatted_line_break_only'
  };

  var modeMap = {
    'text/html': 'html',
    'application/xml': 'xml',
    'text/xsl': 'xsl',
    'text/css': 'css',
    'text/x-less': 'less'
  };

  // add â€œprofileâ€ property to CodeMirror defaults so in wonâ€™t be lost
  // then CM instance is instantiated with â€œprofileâ€ property
  if (CodeMirror.defineOption) {
    CodeMirror.defineOption('profile', 'html');
  } else {
    CodeMirror.defaults.profile = 'html';
  }

  var editorProxy = {
    context: null,

    getSelectionRange: function() {
      var caretPos = this.getCaretPos();
      return {
        start: caretPos,
        end: caretPos + this.getSelection().length
      };
    },

    createSelection: function(start, end) {
      if (start == end) {
        this.context.setCursor(this.context.posFromIndex(start));
      } else {
        this.context.setSelection(this.context.posFromIndex(start), this.context.posFromIndex(end));
      }
    },

    getCurrentLineRange: function() {
      var caret = this.context.getCursor(true);
      return {
        start: this.context.indexFromPos({line: caret.line, ch: 0}),
        end:   this.context.indexFromPos({line: caret.line, ch: this.context.getLine(caret.line).length})
      };
    },

    getCaretPos: function(){
      return this.context.indexFromPos(this.context.getCursor(true));
    },

    setCaretPos: function(pos){
      this.createSelection(pos, pos);
    },

    getCurrentLine: function() {
      return this.context.getLine( this.context.getCursor(true).line ) || '';
    },

    replaceContent: function(value, start, end, noIndent) {

      if (_.isUndefined(end))
        end = _.isUndefined(start) ? content.length : start;
      if (_.isUndefined(start)) start = 0;
      var utils = require('utils');

      // indent new value
      if (!noIndent) {
        value = utils.padString(value, utils.getLinePaddingFromPosition(this.getContent(), start));
      }

      // find new caret position
      var tabstopData = require('tabStops').extract(value, {
        escape: function(ch) {
          return ch;
        }
      });
      value = tabstopData.text;
      var firstTabStop = tabstopData.tabstops[0];

      if (firstTabStop) {
        firstTabStop.start += start;
        firstTabStop.end += start;
      } else {
        firstTabStop = {
          start: value.length + start,
          end: value.length + start
        };
      }

      // do a compound change to record all changes into single undo event
      var that = this;
      var op = this.context.operation || this.context.compoundChange;
      op.call(this.context, function() {
        that.context.replaceRange(value, that.context.posFromIndex(start), that.context.posFromIndex(end));
        that.createSelection(firstTabStop.start, firstTabStop.end);
      });
    },

    getContent: function(){
      return this.context.getValue();
    },

    getSyntax: function() {
      var syntax = this.context.getOption('mode');
      if (syntax in modeMap) {
        syntax = modeMap[syntax];
      }

      return require('actionUtils').detectSyntax(this, syntax);
    },

    /**
     * Returns current output profile name (@see emmet#setupProfile)
     * @return {String}
     */
    getProfileName: function() {
      if (this.context.getOption('profile'))
        return this.context.getOption('profile');

      return require('actionUtils').detectProfile(this);
    },

    /**
     * Ask user to enter something
     * @param {String} title Dialog title
     * @return {String} Entered data
     * @since 0.65
     */
    prompt: function(title) {
      return prompt(title);
    },

    /**
     * Returns current selection
     * @return {String}
     * @since 0.65
     */
    getSelection: function() {
      return this.context.getSelection() || '';
    },

    /**
     * Returns current editor's file path
     * @return {String}
     * @since 0.65
     */
    getFilePath: function() {
      return location.href;
    },

    setupContext: function(ctx) {
      this.context = ctx;
      var indentation = '\t';
      if (!ctx.getOption('indentWithTabs')) {
        indentation = require('utils').repeatString(' ', ctx.getOption('indentUnit'));
      }

      require('resources').setVariable('indentation', indentation);
    },

    addAction: function(commandName, keybinding, target) {
      // register Emmet command as predefined CodeMirror command
      // for latter use
      var cmCommand = 'emmet.' + commandName;
      if (!CodeMirror.commands[cmCommand]) {
        CodeMirror.commands[cmCommand] = function(editor) {
          return runEmmetCommand(commandName, editor);
        };
      }

      if (keybinding) {
        if (!target) {
          // check out CM3 keymap style
          if (CodeMirror.keyMap && CodeMirror.keyMap['default']) {
            target = CodeMirror.keyMap['default'];
          } else {
            if (!CodeMirror.defaults.extraKeys) {
              CodeMirror.defaults.extraKeys = {};
            }

            target = CodeMirror.defaults.extraKeys;
          }
        }

        if (!mac) {
          keybinding = keybinding.replace('Cmd', 'Ctrl');
        }

        if (target) {
          target[keybinding] = cmCommand;
        }
      }
    }
  };

  function isValidSyntax() {
    var syntax = editorProxy.getSyntax();
    return require('resources').hasSyntax(syntax);
  }

  function noop() {
    if (CodeMirror.version >= '3.1') {
      return CodeMirror.Pass;
    }

    throw CodeMirror.Pass;
  }

  function runEmmetCommand(name, editor) {
    editorProxy.setupContext(editor);
    if (name == 'expand_abbreviation_with_tab' && (editorProxy.getSelection() || !isValidSyntax())) {
      // pass through Tab key handler if there's a selection
      return noop();
    }

    var success = true;

    try {
      var result = require('actions').run(name, editorProxy);
      // a bit weird fix for the following action (actually, for their
      // keybindings) to prevent CM2 from inserting block characters
      if (name == 'next_edit_point' || name == 'prev_edit_point') {
        editor.replaceSelection('');
      }

      if (!result && name == 'insert_formatted_line_break_only') {
        success = false;
      }
    } catch (e) {}

    if (!success) {
      return noop();
    }
  }

  // add keybindings to CodeMirror
  if (typeof emmetKeymap != 'undefined') {
    keymap = emmetKeymap;
  }

  _.each(keymap, function(commandName, keybinding) {
    keymap, editorProxy.addAction(commandName, keybinding);
  });

  return editorProxy;
});;(function(){
  var Pos = CodeMirror.Pos;

  function SearchCursor(cm, query, pos, caseFold) {
    this.atOccurrence = false; this.cm = cm;
    if (caseFold == null && typeof query == "string") caseFold = false;

    pos = pos ? cm.clipPos(pos) : Pos(0, 0);
    this.pos = {from: pos, to: pos};

    // The matches method is filled in based on the type of query.
    // It takes a position and a direction, and returns an object
    // describing the next occurrence of the query, or null if no
    // more matches were found.
    if (typeof query != "string") { // Regexp match
      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "ig" : "g");
      this.matches = function(reverse, pos) {
        if (reverse) {
          query.lastIndex = 0;
          var line = cm.getLine(pos.line).slice(0, pos.ch), match = query.exec(line), start = 0;
          while (match) {
            start += match.index + 1;
            line = line.slice(start);
            query.lastIndex = 0;
            var newmatch = query.exec(line);
            if (newmatch) match = newmatch;
            else break;
          }
          start--;
        } else {
          query.lastIndex = pos.ch;
          var line = cm.getLine(pos.line), match = query.exec(line),
          start = match && match.index;
        }
        if (match && match[0])
          return {from: Pos(pos.line, start),
                  to: Pos(pos.line, start + match[0].length),
                  match: match};
      };
    } else { // String query
      if (caseFold) query = query.toLowerCase();
      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};
      var target = query.split("\n");
      // Different methods for single-line and multi-line queries
      if (target.length == 1) {
        if (!query.length) {
          // Empty string would match anything and never progress, so
          // we define it to match nothing instead.
          this.matches = function() {};
        } else {
          this.matches = function(reverse, pos) {
            var line = fold(cm.getLine(pos.line)), len = query.length, match;
            if (reverse ? (pos.ch >= len && (match = line.lastIndexOf(query, pos.ch - len)) != -1)
                        : (match = line.indexOf(query, pos.ch)) != -1)
              return {from: Pos(pos.line, match),
                      to: Pos(pos.line, match + len)};
          };
        }
      } else {
        this.matches = function(reverse, pos) {
          var ln = pos.line, idx = (reverse ? target.length - 1 : 0), match = target[idx], line = fold(cm.getLine(ln));
          var offsetA = (reverse ? line.indexOf(match) + match.length : line.lastIndexOf(match));
          if (reverse ? offsetA >= pos.ch || offsetA != match.length
              : offsetA <= pos.ch || offsetA != line.length - match.length)
            return;
          for (;;) {
            if (reverse ? !ln : ln == cm.lineCount() - 1) return;
            line = fold(cm.getLine(ln += reverse ? -1 : 1));
            match = target[reverse ? --idx : ++idx];
            if (idx > 0 && idx < target.length - 1) {
              if (line != match) return;
              else continue;
            }
            var offsetB = (reverse ? line.lastIndexOf(match) : line.indexOf(match) + match.length);
            if (reverse ? offsetB != line.length - match.length : offsetB != match.length)
              return;
            var start = Pos(pos.line, offsetA), end = Pos(ln, offsetB);
            return {from: reverse ? end : start, to: reverse ? start : end};
          }
        };
      }
    }
  }

  SearchCursor.prototype = {
    findNext: function() {return this.find(false);},
    findPrevious: function() {return this.find(true);},

    find: function(reverse) {
      var self = this, pos = this.cm.clipPos(reverse ? this.pos.from : this.pos.to);
      function savePosAndFail(line) {
        var pos = Pos(line, 0);
        self.pos = {from: pos, to: pos};
        self.atOccurrence = false;
        return false;
      }

      for (;;) {
        if (this.pos = this.matches(reverse, pos)) {
          if (!this.pos.from || !this.pos.to) { console.log(this.matches, this.pos); }
          this.atOccurrence = true;
          return this.pos.match || true;
        }
        if (reverse) {
          if (!pos.line) return savePosAndFail(0);
          pos = Pos(pos.line-1, this.cm.getLine(pos.line-1).length);
        }
        else {
          var maxLine = this.cm.lineCount();
          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);
          pos = Pos(pos.line + 1, 0);
        }
      }
    },

    from: function() {if (this.atOccurrence) return this.pos.from;},
    to: function() {if (this.atOccurrence) return this.pos.to;},

    replace: function(newText) {
      if (!this.atOccurrence) return;
      var lines = CodeMirror.splitLines(newText);
      this.cm.replaceRange(lines, this.pos.from, this.pos.to);
      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
    }
  };

  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this, query, pos, caseFold);
  });
})();
;(function() {
  CodeMirror.simpleHint = function(editor, getHints, givenOptions) {
    // Determine effective options based on given values and defaults.
    var options = {}, defaults = CodeMirror.simpleHint.defaults;
    for (var opt in defaults)
      if (defaults.hasOwnProperty(opt))
        options[opt] = (givenOptions && givenOptions.hasOwnProperty(opt) ? givenOptions : defaults)[opt];

    function collectHints(previousToken) {
      // We want a single cursor position.
      if (editor.somethingSelected()) return;

      var tempToken = editor.getTokenAt(editor.getCursor());

      // JSBIN CUSTOM CHANGE
      if (tempToken.state.mode === 'html' || tempToken.string.trim() === '') {
        return CodeMirror.Pass;
      }

      // Don't show completions if token has changed and the option is set.
      if (options.closeOnTokenChange && previousToken != null &&
          (tempToken.start != previousToken.start || tempToken.type != previousToken.type)) {
        return;
      }

      var result = getHints(editor, givenOptions);
      if (!result || !result.list.length) return;
      var completions = result.list;
      function insert(str) {
        editor.replaceRange(str, result.from, result.to);
      }
      // When there is only one completion, use it directly.
      if (options.completeSingle && completions.length == 1) {
        insert(completions[0]);
        return true;
      }

      // Build the select widget
      var complete = document.createElement("div");
      complete.className = "CodeMirror-completions";
      var sel = complete.appendChild(document.createElement("select"));
      // Opera doesn't move the selection when pressing up/down in a
      // multi-select, but it does properly support the size property on
      // single-selects, so no multi-select is necessary.
      if (!window.opera) sel.multiple = true;
      for (var i = 0; i < completions.length; ++i) {
        var opt = sel.appendChild(document.createElement("option"));
        opt.appendChild(document.createTextNode(completions[i]));
      }
      sel.firstChild.selected = true;
      sel.size = Math.min(10, completions.length);
      var pos = editor.cursorCoords(options.alignWithWord ? result.from : null);
      complete.style.left = pos.left + "px";
      complete.style.top = pos.bottom + "px";
      document.body.appendChild(complete);
      // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
      var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
      if(winW - pos.left < sel.clientWidth)
        complete.style.left = (pos.left - sel.clientWidth) + "px";
      // Hack to hide the scrollbar.
      if (completions.length <= 10)
        complete.style.width = (sel.clientWidth - 1) + "px";

      var done = false;
      function close() {
        if (done) return;
        done = true;
        complete.parentNode.removeChild(complete);
      }
      function pick() {
        insert(completions[sel.selectedIndex]);
        close();
        setTimeout(function(){editor.focus();}, 50);
      }
      CodeMirror.on(sel, "blur", close);
      CodeMirror.on(sel, "keydown", function(event) {
        var code = event.keyCode;
        // Enter
        if (code == 13) {CodeMirror.e_stop(event); pick();}
        // Escape
        else if (code == 27) {CodeMirror.e_stop(event); close(); editor.focus();}
        else if (code != 38 && code != 40 && code != 33 && code != 34 && !CodeMirror.isModifierKey(event)) {
          close(); editor.focus();
          // Pass the event to the CodeMirror instance so that it can handle things like backspace properly.
          editor.triggerOnKeyDown(event);
          // Don't show completions if the code is backspace and the option is set.
          if (!options.closeOnBackspace || code != 8) {
            setTimeout(function(){collectHints(tempToken);}, 50);
          }
        }
      });
      CodeMirror.on(sel, "dblclick", pick);

      sel.focus();
      // Opera sometimes ignores focusing a freshly created node
      if (window.opera) setTimeout(function(){if (!done) sel.focus();}, 100);
      return true;
    }
    return collectHints();
  };
  CodeMirror.simpleHint.defaults = {
    closeOnBackspace: true,
    closeOnTokenChange: false,
    completeSingle: true,
    alignWithWord: true
  };
})();
;(function () {
  var Pos = CodeMirror.Pos;

  function forEach(arr, f) {
    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);
  }

  function arrayContains(arr, item) {
    if (!Array.prototype.indexOf) {
      var i = arr.length;
      while (i--) {
        if (arr[i] === item) {
          return true;
        }
      }
      return false;
    }
    return arr.indexOf(item) != -1;
  }

  function scriptHint(editor, keywords, getToken, options) {
    // Find the token at the cursor
    var cur = editor.getCursor(), token = getToken(editor, cur), tprop = token;
    // If it's not a 'word-style' token, ignore the token.
    if (!/^[\w$_]*$/.test(token.string)) {
      token = tprop = {start: cur.ch, end: cur.ch, string: "", state: token.state,
                       type: token.string == "." ? "property" : null};
    }
    // If it is a property, find out what it is a property of.
    while (tprop.type == "property") {
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if (tprop.string != ".") return;
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if (tprop.string == ')') {
        var level = 1;
        do {
          tprop = getToken(editor, Pos(cur.line, tprop.start));
          switch (tprop.string) {
          case ')': level++; break;
          case '(': level--; break;
          default: break;
          }
        } while (level > 0);
        tprop = getToken(editor, Pos(cur.line, tprop.start));
  if (tprop.type.indexOf("variable") === 0)
    tprop.type = "function";
  else return; // no clue
      }
      if (!context) var context = [];
      context.push(tprop);
    }
    return {list: getCompletions(token, context, keywords, options),
            from: Pos(cur.line, token.start),
            to: Pos(cur.line, token.end)};
  }

  CodeMirror.javascriptHint = function(editor, options) {
    // JSBIN EDIT (note: dedupe is in jsbin.js)
    var keywords = dedupe(javascriptKeywords.concat(editor.getCode().replace(/\W/g, ' ').replace(/\s+/g, ' ').trim().split(' '))).sort(function (a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    });

    var cur = editor.getCursor();
    var token = editor.getTokenAt(cur);
    keywords.splice(keywords.indexOf(token.string), 1);

    return scriptHint(editor, keywords,
                      function (e, cur) {return e.getTokenAt(cur);},
                      options);
  };

  function getCoffeeScriptToken(editor, cur) {
  // This getToken, it is for coffeescript, imitates the behavior of
  // getTokenAt method in javascript.js, that is, returning "property"
  // type and treat "." as indepenent token.
    var token = editor.getTokenAt(cur);
    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {
      token.end = token.start;
      token.string = '.';
      token.type = "property";
    }
    else if (/^\.[\w$_]*$/.test(token.string)) {
      token.type = "property";
      token.start++;
      token.string = token.string.replace(/\./, '');
    }
    return token;
  }

  CodeMirror.coffeescriptHint = function(editor, options) {
    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);
  };

  var stringProps = ("charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight " +
                     "toUpperCase toLowerCase split concat match replace search").split(" ");
  var arrayProps = ("length concat join splice push pop shift unshift slice reverse sort indexOf " +
                    "lastIndexOf every some filter forEach map reduce reduceRight ").split(" ");
  var funcProps = "prototype apply call bind".split(" ");
  var javascriptKeywords = ("break case catch continue debugger default delete do else false finally for function " +
                  "if in instanceof new null return switch throw true try typeof var void while with").split(" ");
  var coffeescriptKeywords = ("and break catch class continue delete do else extends false finally for " +
                  "if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes").split(" ");

  function getCompletions(token, context, keywords, options) {
    var found = [], start = token.string;
    function maybeAdd(str) {
      if (str.indexOf(start) == 0 && !arrayContains(found, str) && str !== start) found.push(str);
      // if (str.indexOf(start) == 0 && !arrayContains(found, str)) found.push(str);
    }
    function gatherCompletions(obj) {
      if (typeof obj == "string") forEach(stringProps, maybeAdd);
      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);
      else if (obj instanceof Function) forEach(funcProps, maybeAdd);
      for (var name in obj) maybeAdd(name);
    }

    if (context) {
      // If this is a property, see if it belongs to some object we can
      // find in the current environment.
      var obj = context.pop(), base;
      if (obj.type.indexOf("variable") === 0) {
        if (options && options.additionalContext)
          base = options.additionalContext[obj.string];
        base = base || window[obj.string];
      } else if (obj.type == "string") {
        base = "";
      } else if (obj.type == "atom") {
        base = 1;
      } else if (obj.type == "function") {
        if (window.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&
            (typeof window.jQuery == 'function'))
          base = window.jQuery();
        else if (window._ != null && (obj.string == '_') && (typeof window._ == 'function'))
          base = window._();
      }
      while (base != null && context.length)
        base = base[context.pop().string];
      if (base != null) gatherCompletions(base);

      // JSBIN edit
      if (found.length === 0) {
        forEach(keywords, maybeAdd);
      }
    }
    else {
      // If not, just look in the window object and any local scope
      // (reading into JS mode internals to get at the local and global variables)
      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);
      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);
      gatherCompletions(window);
      forEach(keywords, maybeAdd);
    }

    return found;
  }
})();
;(function() {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
    (document.documentMode == null || document.documentMode < 8);

  var Pos = CodeMirror.Pos;
  // Disable brace matching in long lines, since it'll cause hugely slow updates
  var maxLineLen = 1000;

  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};
  function findMatchingBracket(cm) {
    var cur = cm.getCursor(), line = cm.getLineHandle(cur.line), pos = cur.ch - 1;
    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];
    if (!match) return null;
    var forward = match.charAt(1) == ">", d = forward ? 1 : -1;
    var style = cm.getTokenAt(Pos(cur.line, pos + 1)).type;

    var stack = [line.text.charAt(pos)], re = /[(){}[\]]/;
    function scan(line, lineNo, start) {
      if (!line.text) return;
      var pos = forward ? 0 : line.text.length - 1, end = forward ? line.text.length : -1;
      if (start != null) pos = start + d;
      for (; pos != end; pos += d) {
        var ch = line.text.charAt(pos);
        if (re.test(ch) && cm.getTokenAt(Pos(lineNo, pos + 1)).type == style) {
          var match = matching[ch];
          if (match.charAt(1) == ">" == forward) stack.push(ch);
          else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};
          else if (!stack.length) return {pos: pos, match: true};
        }
      }
    }
    for (var i = cur.line, found, e = forward ? Math.min(i + 100, cm.lineCount()) : Math.max(-1, i - 100); i != e; i+=d) {
      if (i == cur.line) found = scan(line, i, pos);
      else found = scan(cm.getLineHandle(i), i);
      if (found) break;
    }
    return {from: Pos(cur.line, pos), to: found && Pos(i, found.pos), match: found && found.match};
  }

  function matchBrackets(cm, autoclear) {
    var found = findMatchingBracket(cm);
    if (!found || cm.getLine(found.from.line).length > maxLineLen ||
       found.to && cm.getLine(found.to.line).length > maxLineLen)
      return;

    var style = found.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
    var one = cm.markText(found.from, Pos(found.from.line, found.from.ch + 1), {className: style});
    var two = found.to && cm.markText(found.to, Pos(found.to.line, found.to.ch + 1), {className: style});
    // Kludge to work around the IE bug from issue #1193, where text
    // input stops going to the textare whever this fires.
    if (ie_lt8 && cm.state.focused) cm.display.input.focus();
    var clear = function() {
      cm.operation(function() { one.clear(); two && two.clear(); });
    };
    if (autoclear) setTimeout(clear, 800);
    else return clear;
  }

  var currentlyHighlighted = null;
  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
      if (!cm.somethingSelected()) currentlyHighlighted = matchBrackets(cm, false);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function(cm, val) {
    if (val) cm.on("cursorActivity", doMatchBrackets);
    else cm.off("cursorActivity", doMatchBrackets);
  });

  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
  CodeMirror.defineExtension("findMatchingBracket", function(){return findMatchingBracket(this);});
})();
;// the tagRangeFinder function is
//   Copyright (C) 2011 by Daniel Glazman <daniel@glazman.org>
// released under the MIT license (../../LICENSE) like the rest of CodeMirror
CodeMirror.tagRangeFinder = function(cm, start) {
  var nameStartChar = "A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\-\:\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var xmlNAMERegExp = new RegExp("^[" + nameStartChar + "][" + nameChar + "]*");

  var lineText = cm.getLine(start.line);
  var found = false;
  var tag = null;
  var pos = start.ch;
  while (!found) {
    pos = lineText.indexOf("<", pos);
    if (-1 == pos) // no tag on line
      return;
    if (pos + 1 < lineText.length && lineText[pos + 1] == "/") { // closing tag
      pos++;
      continue;
    }
    // ok we seem to have a start tag
    if (!lineText.substr(pos + 1).match(xmlNAMERegExp)) { // not a tag name...
      pos++;
      continue;
    }
    var gtPos = lineText.indexOf(">", pos + 1);
    if (-1 == gtPos) { // end of start tag not in line
      var l = start.line + 1;
      var foundGt = false;
      var lastLine = cm.lineCount();
      while (l < lastLine && !foundGt) {
        var lt = cm.getLine(l);
        gtPos = lt.indexOf(">");
        if (-1 != gtPos) { // found a >
          foundGt = true;
          var slash = lt.lastIndexOf("/", gtPos);
          if (-1 != slash && slash < gtPos) {
            var str = lineText.substr(slash, gtPos - slash + 1);
            if (!str.match( /\/\s*\>/ )) // yep, that's the end of empty tag
              return;
          }
        }
        l++;
      }
      found = true;
    }
    else {
      var slashPos = lineText.lastIndexOf("/", gtPos);
      if (-1 == slashPos) { // cannot be empty tag
        found = true;
        // don't continue
      }
      else { // empty tag?
        // check if really empty tag
        var str = lineText.substr(slashPos, gtPos - slashPos + 1);
        if (!str.match( /\/\s*\>/ )) { // finally not empty
          found = true;
          // don't continue
        }
      }
    }
    if (found) {
      var subLine = lineText.substr(pos + 1);
      tag = subLine.match(xmlNAMERegExp);
      if (tag) {
        // we have an element name, wooohooo !
        tag = tag[0];
        // do we have the close tag on same line ???
        if (-1 != lineText.indexOf("</" + tag + ">", pos)) // yep
        {
          found = false;
        }
        // we don't, so we have a candidate...
      }
      else
        found = false;
    }
    if (!found)
      pos++;
  }

  if (found) {
    var startTag = "(\\<\\/" + tag + "\\>)|(\\<" + tag + "\\>)|(\\<" + tag + "\\s)|(\\<" + tag + "$)";
    var startTagRegExp = new RegExp(startTag);
    var endTag = "</" + tag + ">";
    var depth = 1;
    var l = start.line + 1;
    var lastLine = cm.lineCount();
    while (l < lastLine) {
      lineText = cm.getLine(l);
      var match = lineText.match(startTagRegExp);
      if (match) {
        for (var i = 0; i < match.length; i++) {
          if (match[i] == endTag)
            depth--;
          else
            depth++;
          if (!depth) return {from: CodeMirror.Pos(start.line, gtPos + 1),
                              to: CodeMirror.Pos(l, match.index)};
        }
      }
      l++;
    }
    return;
  }
};

CodeMirror.braceRangeFinder = function(cm, start) {
  var line = start.line, lineText = cm.getLine(line);
  var at = lineText.length, startChar, tokenType;
  for (;;) {
    var found = lineText.lastIndexOf("{", at);
    if (found < start.ch) break;
    tokenType = cm.getTokenAt(CodeMirror.Pos(line, found + 1)).type;
    if (!/^(comment|string)/.test(tokenType)) { startChar = found; break; }
    at = found - 1;
  }
  if (startChar == null || lineText.lastIndexOf("}") > startChar) return;
  var count = 1, lastLine = cm.lineCount(), end, endCh;
  outer: for (var i = line + 1; i < lastLine; ++i) {
    var text = cm.getLine(i), pos = 0;
    for (;;) {
      var nextOpen = text.indexOf("{", pos), nextClose = text.indexOf("}", pos);
      if (nextOpen < 0) nextOpen = text.length;
      if (nextClose < 0) nextClose = text.length;
      pos = Math.min(nextOpen, nextClose);
      if (pos == text.length) break;
      if (cm.getTokenAt(CodeMirror.Pos(i, pos + 1)).type == tokenType) {
        if (pos == nextOpen) ++count;
        else if (!--count) { end = i; endCh = pos; break outer; }
      }
      ++pos;
    }
  }
  if (end == null || end == line + 1) return;
  return {from: CodeMirror.Pos(line, startChar + 1),
          to: CodeMirror.Pos(end, endCh)};
};

CodeMirror.indentRangeFinder = function(cm, start) {
  var tabSize = cm.getOption("tabSize"), firstLine = cm.getLine(start.line);
  var myIndent = CodeMirror.countColumn(firstLine, null, tabSize);
  for (var i = start.line + 1, end = cm.lineCount(); i < end; ++i) {
    var curLine = cm.getLine(i);
    if (CodeMirror.countColumn(curLine, null, tabSize) < myIndent &&
        CodeMirror.countColumn(cm.getLine(i-1), null, tabSize) > myIndent)
      return {from: CodeMirror.Pos(start.line, firstLine.length),
              to: CodeMirror.Pos(i, curLine.length)};
  }
};

CodeMirror.newFoldFunction = function(rangeFinder, widget) {
  if (widget == null) widget = "\u2194";
  if (typeof widget == "string") {
    var text = document.createTextNode(widget);
    widget = document.createElement("span");
    widget.appendChild(text);
    widget.className = "CodeMirror-foldmarker";
  }

  return function(cm, pos) {
    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);
    var range = rangeFinder(cm, pos);
    if (!range) return;

    var present = cm.findMarksAt(range.from), cleared = 0;
    for (var i = 0; i < present.length; ++i) {
      if (present[i].__isFold) {
        ++cleared;
        present[i].clear();
      }
    }
    if (cleared) return;

    var myWidget = widget.cloneNode(true);
    CodeMirror.on(myWidget, "mousedown", function() {myRange.clear();});
    var myRange = cm.markText(range.from, range.to, {
      replacedWith: myWidget,
      clearOnEnter: true,
      __isFold: true
    });
  };
};
;// Because sometimes you need to style the cursor's line.
//
// Adds an option 'styleActiveLine' which, when enabled, gives the
// active line's wrapping <div> the CSS class "CodeMirror-activeline",
// and gives its background <div> the class "CodeMirror-activeline-background".

(function() {
  "use strict";
  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";

  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {
    var prev = old && old != CodeMirror.Init;
    if (val && !prev) {
      updateActiveLine(cm);
      cm.on("cursorActivity", updateActiveLine);
    } else if (!val && prev) {
      cm.off("cursorActivity", updateActiveLine);
      clearActiveLine(cm);
      delete cm._activeLine;
    }
  });

  function clearActiveLine(cm) {
    if ("_activeLine" in cm) {
      cm.removeLineClass(cm._activeLine, "wrap", WRAP_CLASS);
      cm.removeLineClass(cm._activeLine, "background", BACK_CLASS);
    }
  }

  function updateActiveLine(cm) {
    var line = cm.getLineHandle(cm.getCursor().line);
    if (cm._activeLine == line) return;
    clearActiveLine(cm);
    cm.addLineClass(line, "wrap", WRAP_CLASS);
    cm.addLineClass(line, "background", BACK_CLASS);
    cm._activeLine = line;
  }
})();
;// Highlighting text that matches the selection
//
// Defines an option highlightSelectionMatches, which, when enabled,
// will style strings that match the selection throughout the
// document.
//
// The option can be set to true to simply enable it, or to a
// {minChars, style} object to explicitly configure it. minChars is
// the minimum amount of characters that should be selected for the
// behavior to occur, and style is the token style to apply to the
// matches. This will be prefixed by "cm-" to create an actual CSS
// class name.

(function() {
  var DEFAULT_MIN_CHARS = 2;
  var DEFAULT_TOKEN_STYLE = "matchhighlight";

  function State(options) {
    this.minChars = typeof options == "object" && options.minChars || DEFAULT_MIN_CHARS;
    this.style = typeof options == "object" && options.style || DEFAULT_TOKEN_STYLE;
    this.overlay = null;
  }

  CodeMirror.defineOption("highlightSelectionMatches", false, function(cm, val, old) {
    var prev = old && old != CodeMirror.Init;
    if (val && !prev) {
      cm._matchHighlightState = new State(val);
      cm.on("cursorActivity", highlightMatches);
    } else if (!val && prev) {
      var over = cm._matchHighlightState.overlay;
      if (over) cm.removeOverlay(over);
      cm._matchHighlightState = null;
      cm.off("cursorActivity", highlightMatches);
    }
  });

  function highlightMatches(cm) {
    cm.operation(function() {
      var state = cm._matchHighlightState;
      if (state.overlay) {
        cm.removeOverlay(state.overlay);
        state.overlay = null;
      }

      if (!cm.somethingSelected()) return;
      var selection = cm.getSelection().replace(/^\s+|\s+$/g, "");
      if (selection.length < state.minChars) return;

      cm.addOverlay(state.overlay = makeOverlay(selection, state.style));
    });
  }

  function makeOverlay(query, style) {
    return {token: function(stream) {
      if (stream.match(query)) return style;
      stream.next();
      stream.skipTo(query.charAt(0)) || stream.skipToEnd();
    }};
  }
})();
;/*
    json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());;// Copyright (C) 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// RS modified to support any element being passed in (and compressed)

(function(){function s(b,d){if(undefined===d)throw new Error("BAD");if("number"!=typeof b)throw new Error("BAD");this.end=b;this.style=d}function p(b,d){if(undefined===d)throw new Error("BAD");this.token=b;this.style=d}function v(){this.next=0;this.ch="\u0000"}function w(b){return b>="a"&&b<="z"||b>="A"&&b<="Z"}function z(b){return w(b)||b=="_"||b=="$"||b=="@"}function Q(b){return z(b)||x(b)}function t(b){return"\t \r\n".indexOf(b)>=0}function x(b){return b>="0"&&b<="9"}function I(b){for(var d=0,
a=b.length-1;d<=a&&t(b.charAt(d));)++d;for(;a>d&&t(b.charAt(a));)--a;return b.substring(d,a+1)}function y(b,d){return b.length>=d.length&&d==b.substring(0,d.length)}function R(b,d){return b.length>=d.length&&d==b.substring(b.length-d.length,b.length)}function A(b,d,a){if(d<a.length)return false;d=0;for(var c=a.length;d<c;++d)if(a.charAt(d)!=b[d])return false;return true}function S(b){return b.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\"/g,"&quot;").replace(/\xa0/,"&nbsp;")}
function J(b){return b.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\xa0/g,"&nbsp;")}function K(b){return"XMP"==b.tagName}function T(b){if(null==E){var d=document.createElement("PRE");d.appendChild(document.createTextNode('<!DOCTYPE foo PUBLIC "foo bar">\n<foo />'));E=!/</.test(d.innerHTML)}if(E){d=b.innerHTML;if(K(b))d=J(d);return d}d=[];for(b=b.firstChild;b;b=b.nextSibling)F(b,d);return d.join("")}function F(b,d){switch(b.nodeType){case 1:var a=b.tagName.toLowerCase();
d.push("<",a);for(var c=0;c<b.attributes.length;++c){var i=b.attributes[c];if(i.specified){d.push(" ");F(i,d)}}d.push(">");for(c=b.firstChild;c;c=c.nextSibling)F(c,d);if(b.firstChild||!/^(?:br|link|img)$/.test(a))d.push("</",a,">");break;case 2:d.push(b.name.toLowerCase(),'="',S(b.value),'"');break;case 3:case 4:d.push(J(b.nodeValue));break}}function U(b,d){for(var a=0,c=new v,i=[],h=0;h<b.length;++h){var j=b[h];if(j.style==null)i.push(j);else{for(var e=j.token,f=0,g=[],k=0,m=e.length;k<m;k=c.next){c.decode(e,
k);switch(c.ch){case "\t":g.push(e.substring(f,k));f=d-a%d;for(a+=f;f>=0;f-=16)g.push("                ".substring(0,f));f=c.next;break;case "\n":case "\r":a=0;break;default:++a}}g.push(e.substring(f));i.push(new p(g.join(""),j.style))}}return i}function V(b){b=b.match(/(?:[^<]+|<\/?[a-zA-Z][^>]*>|<)/g);var d=[];if(b)for(var a=null,c=0,i=b.length;c<i;++c){var h=b[c];if(h.length<2||h.charAt(0)!=="<"){if(a&&a.style===n){a.token+=h;continue}a=n}else a=null;a=new p(h,a);d.push(a)}return d}function L(b,
d){for(var a=[],c=0,i=0,h=0,j=new p("",null),e=0,f=d.length;e<f;++e){var g=d[e],k=g.end;if(k!==0){for(var m=k-i,q=j.token.length-h;q<=m;){if(q>0)a.push(new p(j.token.substring(h,j.token.length),null==j.style?null:g.style));i+=q;h=0;if(c<b.length)j=b[c++];m=k-i;q=j.token.length-h}if(m){a.push(new p(j.token.substring(h,h+m),g.style));i+=m;h+=m}}}return a}function W(b){for(var d=[],a=0,c=0,i=-1,h=new Array(12),j=0,e=null,f=new v,g=0,k=b.length;g<k;++g){var m=b[g];if(n==m.style)for(var q=m.token,l=0,
X=q.length;l<X;){f.decode(q,l);var o=f.ch,M=f.next,u=null;switch(a){case 0:if("<"==o)a=1;break;case 1:j=0;if("/"==o)a=7;else if(null==e)if("!"==o)a=2;else if(w(o))a=8;else if("?"==o)a=9;else if("%"==o)a=11;else{if("<"!=o)a=0}else if("<"!=o)a=0;break;case 2:a="-"==o?4:w(o)?3:"<"==o?1:0;break;case 3:if(">"==o){a=0;u=Y}break;case 4:if("-"==o)a=5;break;case 5:if("-"==o)a=6;break;case 6:if(">"==o){a=0;u=B}else a="-"==o?6:4;break;case 7:a=w(o)?8:"<"==o?1:0;break;case 8:if(">"==o){a=0;u=r}break;case 9:if("?"==
o)a=10;break;case 10:if(">"==o){a=0;u=C}else if("?"!=o)a=9;break;case 11:if("%"==o)a=12;break;case 12:if(">"==o){a=0;u=C}else if("%"!=o)a=11;break}if(j<h.length)h[j++]=o.toLowerCase();if(1==a)i=c+l;l=M;if(u!=null){if(null!=u){if(e){if(A(h,j,e))e=null}else if(A(h,j,"script"))e="/script";else if(A(h,j,"style"))e="/style";else if(A(h,j,"xmp"))e="/xmp";if(e&&j&&"/"==h[0])u=null}if(null!=u){d.push(new s(i,n));d.push(new s(c+M,u))}}}c+=m.token.length}d.push(new s(c,n));return d}function Z(b){for(var d=
[],a=0,c=-1,i=0,h=0,j=b.length;h<j;++h){var e=b[h],f=e.token;if(n==e.style){e=new v;for(var g=-1,k,m=0,q=f.length;m<q;g=m,m=k){e.decode(f,m);var l=e.ch;k=e.next;if(0==a)if(l=='"'||l=="'"||l=="`"){d.push(new s(i+m,n));a=1;c=l}else if(l=="/")a=3;else{if(l=="#"){d.push(new s(i+m,n));a=4}}else if(1==a)if(l==c){a=0;d.push(new s(i+k,N))}else{if(l=="\\")a=2}else if(2==a)a=1;else if(3==a)if(l=="/"){a=4;d.push(new s(i+g,n))}else if(l=="*"){a=5;d.push(new s(i+g,n))}else{a=0;k=m}else if(4==a){if(l=="\r"||l==
"\n"){a=0;d.push(new s(i+m,B))}}else if(5==a){if(l=="*")a=6}else if(6==a)if(l=="/"){a=0;d.push(new s(i+k,B))}else if(l!="*")a=5}}i+=f.length}switch(a){case 1:case 2:a=N;break;case 4:case 5:case 6:a=B;break;default:a=n;break}d.push(new s(i,a));return L(b,d)}function $(b,d){for(var a=0,c=0,i=new v,h,j=0;j<=b.length;j=h){if(j==b.length){f=-2;h=j+1}else{i.decode(b,j);h=i.next;var e=i.ch,f=c;switch(c){case 0:if(z(e))f=1;else if(x(e))f=2;else t(e)||(f=3);if(f&&a<j){e=b.substring(a,j);d.push(new p(e,n));
a=j}break;case 1:Q(e)||(f=-1);break;case 2:x(e)||w(e)||e=="_"||(f=-1);break;case 3:if(z(e)||x(e)||t(e))f=-1;break}}if(f!=c){if(f<0){if(j>a){e=b.substring(a,j);a=new v;a.decode(e,0);var g=a.ch;c=a.next==e.length;if(z(g))if(O[e])c=aa;else if(g==="@")c=P;else{var k=false;if(g>="A"&&g<="Z"){for(g=a.next;g<e.length;g=a.next){a.decode(e,g);g=a.ch;if(g>="a"&&g<="z"){k=true;break}}if(!k&&!c&&e.substring(e.length-2)=="_t")k=true}c=k?ba:n}else c=x(g)?P:t(g)?n:ca;a=j;d.push(new p(e,c))}c=0;if(f==-1){h=j;continue}}c=
f}}}function da(b){if(!(b&&b.length))return b;var d=W(b);return L(b,d)}function ea(b){for(var d=[],a=0,c=r,i=null,h=new v,j=0;j<b.length;++j){var e=b[j];if(r==e.style){e=e.token;for(var f=0,g=0;g<e.length;){h.decode(e,g);var k=h.ch,m=h.next,q=null,l=null;if(k==">"){if(r!=c){q=g;l=r}}else switch(a){case 0:if("<"==k)a=1;break;case 1:if(t(k))a=2;break;case 2:if(!t(k)){l=G;q=g;a=3}break;case 3:if("="==k){q=g;l=r;a=5}else if(t(k)){q=g;l=r;a=4}break;case 4:if("="==k)a=5;else if(!t(k)){q=g;l=G;a=3}break;
case 5:if('"'==k||"'"==k){q=g;l=D;a=6;i=k}else if(!t(k)){q=g;l=D;a=7}break;case 6:if(k==i){q=m;l=r;a=2}break;case 7:if(t(k)){q=g;l=r;a=2}break}if(q){if(q>f){d.push(new p(e.substring(f,q),c));f=q}c=l}g=m}e.length>f&&d.push(new p(e.substring(f,e.length),c))}else{if(e.style){a=0;c=r}d.push(e)}}return d}function fa(b){for(var d=[],a=null,c=new v,i=null,h=0,j=b.length;;++h){var e;if(h<j){e=b[h];if(null==e.style){b.push(e);continue}}else if(a)e=new p("",null);else break;var f=e.token;if(null==a)if(C==e.style){if("<"==
c.decode(f,0)){c.decode(f,c.next);if("%"==c.ch||"?"==c.ch){a=c.ch;d.push(new p(f.substring(0,c.next),r));f=f.substring(c.next,f.length)}}}else if(r==e.style)if("<"==c.decode(f,0)&&"/"!=f.charAt(c.next)){var g=f.substring(c.next).toLowerCase();if(y(g,"script")||y(g,"style")||y(g,"xmp"))a="/"}if(null!=a){g=null;if(C==e.style){if(a=="%"||a=="?"){e=f.lastIndexOf(a);if(e>=0&&">"==c.decode(f,e+1)&&f.length==c.next){g=new p(f.substring(e,f.length),r);f=f.substring(0,e)}}if(null==i)i=[];i.push(new p(f,n))}else if(n==
e.style){if(null==i)i=[];i.push(e)}else if(r==e.style)if("<"==c.decode(e.token,0)&&e.token.length>c.next&&"/"==c.decode(e.token,c.next))g=e;else d.push(e);else if(h>=j)g=e;else i?i.push(e):d.push(e);if(g){if(i){a=H(i);d.push(new p("<span class=embsrc>",null));i=0;for(f=a.length;i<f;++i)d.push(a[i]);d.push(new p("</span>",null));i=null}g.token&&d.push(g);a=null}}else d.push(e)}return d}function ga(b){for(var d=null,a=null,c=0;c<b.length;++c)if(n==b[c].style){d=c;break}for(c=b.length;--c>=0;)if(n==
b[c].style){a=c;break}if(null==d)return b;c=new v;var i=b[d].token,h=c.decode(i,0);if('"'!=h&&"'"!=h)return b;var j=c.next,e=b[a].token,f=e.lastIndexOf("&");if(f<0)f=e.length-1;var g=c.decode(e,f);if(g!=h||c.next!=e.length){g=null;f=e.length}h=[];for(c=0;c<d;++c)h.push(b[c]);h.push(new p(i.substring(0,j),D));if(a==d)h.push(new p(i.substring(j,f),n));else{h.push(new p(i.substring(j,i.length),n));for(c=d+1;c<a;++c)h.push(b[c]);g?b.push(new p(e.substring(0,f),n)):b.push(b[a])}g&&h.push(new p(e.substring(f,
e.length),n));for(c=a+1;c<b.length;++c)h.push(b[c]);return h}function ha(b){for(var d=[],a=null,c=false,i="",h=0,j=b.length;h<j;++h){var e=b[h],f=d;if(r==e.style)if(c){c=false;i="";if(a){d.push(new p("<span class=embsrc>",null));a=H(ga(a));for(var g=0,k=a.length;g<k;++g)d.push(a[g]);d.push(new p("</span>",null));a=null}}else if(i&&e.token.indexOf("=")>=0){g=i.toLowerCase();if(y(g,"on")||"style"==g)c=true}else i="";else if(G==e.style)i+=e.token;else if(D==e.style){if(c){if(null==a)a=[];f=a;e=new p(e.token,
n)}}else if(a)f=a;f.push(e)}return d}function H(b){b=Z(b);for(var d=[],a=0;a<b.length;++a){var c=b[a];n===c.style?$(c.token,d):d.push(c)}return d}function ia(b){b=da(b);b=ea(b);b=fa(b);return b=ha(b)}function ja(b){b=U(V(b),ka);for(var d=false,a=0;a<b.length;++a)if(n==b[a].style){if(y(I(b[a].token),"&lt;"))for(a=b.length;--a>=0;)if(n==b[a].style){d=R(I(b[a].token),"&gt;");break}break}return d?ia(b):H(b)}function la(b){try{for(var d=ja(b),a=[],c=null,i=0;i<d.length;i++){var h=d[i];if(h.style!=c){c!=
null&&a.push("</span>");h.style!=null&&a.push("<span class=",h.style,">");c=h.style}var j=h.token;if(null!=h.style)j=j.replace(/(\r\n?|\n| ) /g,"$1&nbsp;").replace(/\r\n?|\n/g,"<br>");a.push(j)}c!=null&&a.push("</span>");return a.join("")}catch(e){if("console"in window){console.log(e);console.trace()}return b}}function ma(b){function d(){for(var j=(new Date).getTime()+250;h<b.length&&(new Date).getTime()<j;h++){for(var e=b[h],f=false,g=e.parentNode;g!=null;g=g.parentNode)if((g.tagName=="pre"||g.tagName==
"code"||g.tagName=="xmp")&&g.className&&g.className.indexOf("prettyprint")>=0||1){f=true;break}if(!f){f=T(e);f=f.replace(/(?:\r\n?|\n)$/,"");f=la(f);if(K(e)){g=document.createElement("PRE");for(var k=0;k<e.attributes.length;++k){var m=e.attributes[k];m.specified&&g.setAttribute(m.name,m.value)}g.innerHTML=f;e.parentNode.replaceChild(g,e)}else e.innerHTML=f}}h<b.length&&setTimeout(d,250)}var a=[];b=b||[];if(b.length==0){a=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),
document.getElementsByTagName("xmp")];for(var c=0;c<a.length;++c)for(var i=0;i<a[c].length;++i)b.push(a[c][i]);a=null}var h=0;d()}var O={};(function(){for(var b=["abstract bool break case catch char class const const_cast continue default delete deprecated dllexport dllimport do double dynamic_cast else enum explicit extern false float for friend goto if inline int long mutable naked namespace new noinline noreturn nothrow novtable operator private property protected public register reinterpret_cast return selectany short signed sizeof static static_cast struct switch template this thread throw true try typedef typeid typename union unsigned using declaration, directive uuid virtual void volatile while typeof",
"as base by byte checked decimal delegate descending event finally fixed foreach from group implicit in interface internal into is lock null object out override orderby params readonly ref sbyte sealed stackalloc string select uint ulong unchecked unsafe ushort var","package synchronized boolean implements import throws instanceof transient extends final strictfp native super","debugger export function with NaN Infinity","require sub unless until use elsif BEGIN END","and assert def del elif except exec global lambda not or pass print raise yield False True None",
"then end begin rescue ensure module when undef next redo retry alias defined","done fi"],d=0;d<b.length;d++)for(var a=b[d].split(" "),c=0;c<a.length;c++)if(a[c])O[a[c]]=true}).call(this);var N="str",aa="kwd",B="com",ba="typ",P="lit",ca="pun",n="pln",r="tag",Y="dec",C="src",G="atn",D="atv",ka=2;s.prototype.toString=function(){return"[PR_TokenEnd "+this.end+(this.style?":"+this.style:"")+"]"};p.prototype.toString=function(){return"[PR_Token "+this.token+(this.style?":"+this.style:"")+"]"};var na={lt:"<",
gt:">",quot:'"',apos:"'",amp:"&"};v.prototype.decode=function(b,d){var a=d+1,c=b.charAt(d);if("&"===c){var i=b.indexOf(";",a);if(i>=0&&i<a+4){a=b.substring(a,i);c=null;if(a.charAt(0)==="#"){var h=a.charAt(1);h=h==="x"||h==="X"?parseInt(a.substring(2),16):parseInt(a.substring(1),10);isNaN(h)||(c=String.fromCharCode(h))}c||(c=na[a.toLowerCase()]);if(c){c=c;a=i+1}else{a=d+1;c="\u0000"}}}this.next=a;return this.ch=c};var E=null;window.prettyPrint=ma})();;/**
 * Protect against infinite loops.
 * Look for for, while and do loops, and insert a check function at the start of
 * the loop. If the check function is called many many times then it returns
 * true, preventing the loop from running again.
 */
var loopProtect = (function () {

  var debug = false ? function () {
    console.log.apply(console, [].slice.apply(arguments));
  } : function () {};

  var loopProtect = {};

  // used in the loop detection
  loopProtect.counters = {};

  /**
   * Look for for, while and do loops, and inserts *just* at the start of the
   * loop, a check function.
   */
  loopProtect.rewriteLoops = function (code, offset) {
    var recompiled = [],
        lines = code.split('\n'),
        re = /\b(for|while|do)\b/g;

    if (!offset) offset = 0;

    var disableLoopProtection = false;

    var method = 'window.runnerWindow.protect';
    var ignore = {},
        pushonly = {};

    var insertReset = function (lineNum, line, matchPosition) {
      // recompile the line with the reset **just** before the actual loop
      // so that we insert in to the correct location (instead of possibly
      // outside the logic
      return line.slice(0, matchPosition) + ';' + method + '({ line: ' + lineNum + ', reset: true }); ' + line.slice(matchPosition);
    };

    lines.forEach(function (line, lineNum) {
      // reset our regexp each time.
      re.lastIndex = 0;

      if (disableLoopProtection) {
        return;
      }

      if (line.toLowerCase().indexOf('noprotect') !== -1) {
        disableLoopProtection = true;
      }

      var next = line,
          index = -1,
          matchPosition = -1,
          originalLineNum = lineNum,
          printLineNumber = lineNum - offset + 1, // +1 since we're humans and don't read lines numbers from zero
          character = '',
          dofound = false, // special case for `do` loops, as they're tailed with `while`
          findwhile = false,
          cont = true,
          oneliner = false,
          terminator = false,
          matches = line.match(re) || [],
          match = matches.length ? matches[0] : '',
          openBrackets = 0,
          openBraces = 0;

      if (ignore[lineNum]) {
        debug(' -exit: ignoring line ' + lineNum +': ' + line);
        return;
      }

      if (pushonly[lineNum]) {
        debug('- exit: ignoring, but adding line ' + lineNum + ': ' + line);
        recompiled.push(line);
        return;
      }

      // if there's more than one match, we just ignore this kind of loop
      // otherwise I'm going to be writing a full JavaScript lexer...and god
      // knows I've got better things to be doing.
      if (match && matches.length === 1 && line.indexOf('jsbin') === -1) {
        debug('match on ' + match + '\n');

        // there's a special case for protecting `do` loops, we need to first
        // prtect the `do`, but then ignore the closing `while` statement, so
        // we reset the search state for this special case.
        dofound = match === 'do';

        // make sure this is an actual loop command by searching backwards
        // to ensure it's not a string, comment or object property
        matchPosition = index = line.indexOf(match);

        // first we need to walk backwards to ensure that our match isn't part
        // of a string or part of a comment
        while (--index > -1) {
          character = line.substr(index, 1);
          if (character === '"' || character === "'" || character === '.') {
            // our loop keyword was actually either in a string or a property, so let's exit and ignore this line
            debug('- exit: matched inside a string or property key');
            recompiled.push(line);
            return;
          }
          if (character === '/' || character === '*') {
            // looks like a comment, go back one to confirm or not
            --index;
            if (character === '/') {
              // we've found a comment, so let's exit and ignore this line
              debug('- exit: part of a comment');
              recompiled.push(line);
              return;
            }
          }
        }

        // it's quite possible we're in the middle of a multiline
        // comment, so we'll cycle up looking for an opening comment,
        // and if there's one (and not a closing `*/`), then we'll
        // ignore this line as a comment
        if (lineNum > 0) {
          var j = lineNum,
              closeCommentTags = 1, // let's assume we're inside a comment
              closePos = -1,
              openPos = -1;
          do {
            j -= 1;
            debug('looking backwards ' + lines[j]);
            closePos = lines[j].indexOf('*/');
            openPos = lines[j].indexOf('/*');

            if (closePos !== -1) {
              closeCommentTags++;
            }

            if (openPos !== -1) {
              closeCommentTags--;

              if (closeCommentTags === 0) {
                debug('- exit: part of a multiline comment');
                recompiled.push(line);
                return;
              }
            }
          } while (j !== 0);
        }

        // now work our way forward to look for '{'
        index = line.indexOf(match) + match.length;

        if (index === line.length) {
          if (index === line.length && lineNum < (lines.length-1)) {
            // move to the next line
            debug('- moving to next line');
            recompiled.push(line);
            lineNum++;
            line = lines[lineNum];
            ignore[lineNum] = true;
            index = 0;
          }

        }

        while (index < line.length) {
          character = line.substr(index, 1);
          debug(character, index);

          if (character === '(') {
            openBrackets++;
          }

          if (character === ')') {
            openBrackets--;

            if (openBrackets === 0 && terminator === false) {
              terminator = index;
            }
          }

          if (character === '{') {
            openBraces++;
          }

          if (character === '}') {
            openBraces--;
          }

          if (openBrackets === 0 && (character === ';' || character === '{')) {
            // if we're a non-curlies loop, then convert to curlies to get our code inserted
            if (character === ';') {
              if (lineNum !== originalLineNum) {
                debug('- multiline inline loop');
                // affect the compiled line
                recompiled[originalLineNum] = recompiled[originalLineNum].substring(0, terminator + 1) + '{\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\n';
                line += '\n}\n';
              } else {
                // simpler
                debug('- single line inline loop');
                line = line.substring(0, terminator + 1) + '{\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\n' + line.substring(terminator + 1) + '\n}\n';
              }

            } else if (character === '{') {
              debug('- multiline with braces');
              var insert = ';\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\n';
              line = line.substring(0, index + 1) + insert + line.substring(index + 1);

              index += insert.length;
            }

            // work out where to put the reset
            if (lineNum === originalLineNum) {
              debug('- simple reset insert');
              line = insertReset(printLineNumber, line, matchPosition);
              index += (';' + method + '({ line: ' + lineNum + ', reset: true }); ').length;
            } else {
              // insert the reset above the originalLineNum
              debug('- reset inserted above original line');
              recompiled[originalLineNum] = insertReset(printLineNumber, recompiled[originalLineNum], matchPosition);
            }

            recompiled.push(line);

            if (!dofound) {
              return;
            } else {
              debug('searching for closing `while` statement for: ' + line);
              // cycle forward until we find the close brace, after which should
              // be our while statement to ignore
              var findwhile = false;
              while (index < line.length) {
                character = line.substr(index, 1);

                if (character === '{') {
                  openBraces++;
                }

                if (character === '}') {
                  openBraces--;
                }

                debug(character, openBraces);

                if (openBraces === 0) {
                  findwhile = true;
                } else {
                  findwhile = false;
                }

                if (openBraces === 0) {
                  debug('outside of closure, looking for `while` statement: ' + line);
                }

                if (findwhile && line.indexOf('while') !== -1) {
                  debug('- exit as we found `while`: ' + line)
                  pushonly[lineNum] = true;
                  return;
                }

                index++;

                if (index === line.length && lineNum < (lines.length-1)) {
                  lineNum++;
                  line = lines[lineNum];
                  debug(line);
                  index = 0;
                }
              }
              return;
            }
          }

          index++;

          if (index === line.length && lineNum < (lines.length-1)) {
            // move to the next line
            debug('- moving to next line');
            recompiled.push(line);
            lineNum++;
            line = lines[lineNum];
            ignore[lineNum] = true;
            index = 0;
          }
        }
      } else {
        // else we're a regular line, and we shouldn't be touched
        debug('regular line ' + line);
        recompiled.push(line);
      }
    });

    return disableLoopProtection ? code : recompiled.join('\n');
  };

  /**
   * Injected code in to user's code to **try** to protect against infinite
   * loops cropping up in the code, and killing the browser. Returns true
   * when the loops has been running for more than 100ms.
   */
  loopProtect.protect = function (state) {
    loopProtect.counters[state.line]  = loopProtect.counters[state.line] || {};
    var line = loopProtect.counters[state.line];
    if (state.reset) {
      line.time = +new Date;
      line.hit = 0;
      line.last = 0;
    }
    line.hit++;
    if ((+new Date - line.time) > 100) {//} && line.hit !== line.last+1) {
      // We've spent over 100ms on this loop... smells infinite.
      var msg = 'Exiting potential infinite loop at line ' + state.line + '. To disable loop protection: add "// noprotect" to your code';
      if (window.proxyConsole) {
        window.proxyConsole.error(msg);
      } else console.error(msg);
      // Returning true prevents the loop running again
      return true;
    }
    line.last++;
    return false;
  };

  loopProtect.reset = function () {
    // reset the counters
    loopProtect.counters = {};
  };

  return loopProtect;

}());

if (typeof exports !== 'undefined') {
  module.exports = loopProtect;
}
;function hasStore(type) {
  try {
    return type in window && window[type] !== null;
  } catch(e) {
    return false;
  }
}

var store = (function () {
  "use strict";
  var polyfill = false;

  // Firefox with Cookies disabled triggers a security error when we probe window.sessionStorage
  // currently we're just disabling all the session features if that's the case.
  var sessionStorage;
  var localStorage;

  if (!hasStore('sessionStorage')) {
    polyfill = true;
    sessionStorage = (function () {
      var data = window.top.name ? JSON.parse(window.top.name) : {};

      return {
        clear: function () {
          data = {};
          window.top.name = '';
        },
        getItem: function (key) {
          return data[key] || null;
        },
        removeItem: function (key) {
          delete data[key];
          window.top.name = JSON.stringify(data);
        },
        setItem: function (key, value) {
          data[key] = value;
          window.top.name = JSON.stringify(data);
        }
      };
    })();
  }

  if (!hasStore('localStorage')) {
    // dirty, but will do for our purposes
    localStorage = $.extend({}, sessionStorage);
  } else if (hasStore('localStorage')) {
    localStorage = window.localStorage;
  }

  return { polyfill: polyfill, sessionStorage: sessionStorage, localStorage: localStorage };

})();

// because: I want to hurt you firefox, that's why.
store.backup = {};

// if (hasStore('localStorage')) {
//   store.backup.localStorage = window.localStorage;
//   store.backup.sessionStorage = window.sessionStorage;
// }

// var sessionStorage = {}, localStorage = {};

if (store.polyfill === true) {
  window.sessionStorage = store.sessionStorage;
  window.localStorage = store.localStorage;
};try {
  console.log('init');
} catch (e) {
  var console = {
    log: function () {
      // alert([].slice.call(arguments).join('\n'));
    }
  };
}

// required because jQuery 1.4.4 lost ability to search my object property :( (i.e. a[host=foo.com])
jQuery.expr[':'].host = function(obj, index, meta, stack) {
  return obj.host == meta[3];
};

function throttle(fn, delay) {
  var timer = null;
  var throttled = function () {
    var context = this, args = arguments;
    throttled.cancel();
    throttled.timer = setTimeout(function () {
      fn.apply(context, args);
    }, delay);
  };

  throttled.cancel = function () {
    clearTimeout(throttled.timer);
  };

  return throttled;
}

function escapeHTML(html){
  return String(html)
    .replace(/&(?!\w+;)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};

function dedupe(array) {
  var hash    = {},
      results = [],
      hasOwn  = Object.prototype.hasOwnProperty,
      i, item, len;

  for (i = 0, len = array.length; i < len; i += 1) {
    item = array[i];

    if (!hasOwn.call(hash, item)) {
      hash[item] = 1;
      results.push(item);
    }
  }

  return results;
}


window['jsbin'] || (window.jsbin = {});
// dodgy?
var storedSettings = localStorage.getItem('settings');
if (storedSettings === "undefined") {
  // yes, equals the *string* "undefined", then something went wrong
  storedSettings = null;
}
window.jsbin.settings = $.extend(JSON.parse(storedSettings || '{}'), jsbin.settings);

// if the above code isn't dodgy, this for hellz bells is:
jsbin.mobile = /WebKit.*Mobile.*|Android/.test(navigator.userAgent);
jsbin.tablet = /iPad/i.test(navigator.userAgent); // sue me.
// IE detect - sadly uglify is compressing the \v1 trick to death :(
// via @padolsey & @jdalton - https://gist.github.com/527683
jsbin.ie = (function(){
  var undef,
      v = 3,
      div = document.createElement('div'),
      all = div.getElementsByTagName('i');
  while (
    div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',
    all[0]
  );
  return v > 4 ? v : undef;
}());

if (!storedSettings && (location.origin + location.pathname) === jsbin.root + '/') {
  // first timer - let's welcome them shall we, Dave?
  localStorage.setItem('settings', '{}');
  if (!jsbin.custom) {
    window.location = jsbin.root + '/welcome/edit?html,live'
      + (location.search.indexOf('api=') !== -1 ?  ',&' + location.search.substring(1) : '');
  }
}

if (!jsbin.settings.editor) {
  // backward compat with jsbin-v2
  jsbin.settings.editor = {};
}

if (jsbin.settings.codemirror) {
  $.extend(jsbin.settings.editor, jsbin.settings.codemirror);
}

if (jsbin.settings.editor.theme) {
  $(document.documentElement).addClass('cm-s-' + jsbin.settings.editor.theme);
}

// Add a pre-filter to all ajax requests to add a CSRF header to prevent
// malicious form submissions from other domains.
jQuery.ajaxPrefilter(function (options, original, xhr) {
  var skip = {head: 1, get: 1};
  if (!skip[options.type.toLowerCase()] &&
      !options.url.match(/^https:\/\/api.github.com/)) {
    xhr.setRequestHeader('X-CSRF-Token', jsbin.state.token);
  }
});

jsbin.getURL = function (withoutRoot) {
  var url = withoutRoot ? '' : jsbin.root,
      state = jsbin.state;

  if (state.code) {
    url += '/' + state.code;

    if (state.revision) { //} && state.revision !== 1) {
      url += '/' + state.revision;
    }
  }
  return url;
};

function objectValue(path, context) {
  var props = path.split('.'),
      length = props.length,
      i = 1,
      currentProp = context || window,
      value = currentProp[path];
  try {
    if (currentProp[props[0]] !== undefined) {
      currentProp = currentProp[props[0]];
      for (; i < length; i++) {
        if (currentProp[props[i]] === undefined) {
          break;
        } else if (i === length - 1) {
          value = currentProp[props[i]];
        }
        currentProp = currentProp[props[i]];
      }
    }
  } catch (e) {
    value = undefined;
  }

  return value;
}


var $window = $(window),
    $body = $('body'),
    $document = $(document),
    debug = jsbin.settings.debug === undefined ? false : jsbin.settings.debug,
    documentTitle = 'JS Bin',
    $bin = $('#bin'),
    loadGist,
    // splitterSettings = JSON.parse(localStorage.getItem('splitterSettings') || '[ { "x" : null }, { "x" : null } ]'),
    unload = function () {
      // sessionStorage.setItem('javascript', editors.javascript.getCode());
      if (jsbin.panels.focused.editor) {
        try { // this causes errors in IE9 - so we'll use a try/catch to get through it
          sessionStorage.setItem('line', jsbin.panels.focused.editor.getCursor().line);
          sessionStorage.setItem('character', jsbin.panels.focused.editor.getCursor().ch);
        } catch (e) {
          sessionStorage.setItem('line', 0);
          sessionStorage.setItem('character', 0);
        }
      }

      sessionStorage.setItem('url', jsbin.getURL());
      localStorage.setItem('settings', JSON.stringify(jsbin.settings));

      // if (jsbin.panels.saveOnExit) ;
      jsbin.panels.save();
      jsbin.panels.savecontent();

      var panel = jsbin.panels.focused;
      if (panel) sessionStorage.setItem('panel', panel.id);
    };

$window.unload(unload);

// hack for Opera because the unload event isn't firing to capture the settings, so we put it on a timer
if ($.browser.opera) {
  setInterval(unload, 500);
}

if (location.search.indexOf('api=') !== -1) {
  (function () {
    var urlParts = location.search.substring(1).split(','),
        newUrlParts = [],
        i = urlParts.length,
        apiurl = '';

    while (i--) {
      if (urlParts[i].indexOf('api=') !== -1) {
        apiurl = urlParts[i].replace(/&?api=/, '');
      } else {
        newUrlParts.push(urlParts[i]);
      }
    }

    $.getScript(jsbin.root + '/js/chrome/sandbox.js', function () {
      var sandbox = new Sandbox(apiurl);
      sandbox.get('settings', function (data) {
        $.extend(jsbin.settings, data);
        unload();
        window.location = location.pathname + (newUrlParts.length ? '?' + newUrlParts.join(',') : '');
      });
    });

  }());
}


$document.one('jsbinReady', function () {
  $bin.removeAttr('style');
  $body.addClass('ready');
});

if (navigator.userAgent.indexOf(' Mac ') !== -1) (function () {
  var el = $('#keyboardHelp')[0];
  el.innerHTML = el.innerHTML.replace(/ctrl/g, 'cmd').replace(/Ctrl/g, 'ctrl');
})();

if (false) { //window.top !== window && location.pathname.indexOf('/embed') === -1) {
  // we're framed, to switch in to embed mode
  jsbin.embed = true;
  jsbin.saveDisabled = true;
  $('#saveform').attr('target', '_blank');
  $('html').addClass('embed');
  // remove elements that we don't need
  $('#homemenu').closest('.menu').remove();
  $('#login').closest('.menu').remove();
  $('#register').closest('.menu').remove();
  $('#library').closest('.menu').remove();
  $('#sharemenu').remove();
  $('a.brand').removeClass('button-dropdown').click(function (event) {
    this.hash = '';
    event.stopImmediatePropagation();
    return true;
  }).after('<a href="' + jsbin.getURL() + '/save" target="_blank" class="button save">Save</a>');
}

if (jsbin.embed) {
  $window.on('focus', function () {
    return false;
  });
};// yeah, nasty, but it allows me to switch from a RTF to plain text if we're running a iOS
var noop = function () {},
    rootClassName = document.body.className;

if (jsbin.mobile || jsbin.tablet || rootClassName.indexOf('ie6') !== -1 || rootClassName.indexOf('ie7') !== -1) {
  $('body').addClass('mobile');
  jsbin.lameEditor = true;
  Editor = function (el, options) {
    this.textarea = el;
    this.win = { document : this.textarea };
    this.ready = true;
    this.wrapping = document.createElement('div');

    var textareaParent = this.textarea.parentNode;
    this.wrapping.appendChild(this.textarea);
    textareaParent.appendChild(this.wrapping);

    this.textarea.style.opacity = 1;
    // this.textarea.style.width = '100%';

    $(this.textarea).blur(throttle(function () {
      $(document).trigger('codeChange', { panelId: el.id });
    }, 200));

    options.initCallback && $(options.initCallback);
  };

  Editor.prototype = {
    getWrapperElement: function () {
      return this.wrapping;
    },
    getScrollerElement: function () {
      return this.textarea;
    },
    setOption: function (type, handler) {
      if (type == 'onChange') {
        $(this.textarea).change(handler);
      }
    },
    setCode: function (code) {
      this.textarea.value = code;
    },
    getCode: function () {
      return this.textarea.value;
    },
    getValue: function () {
      return this.textarea.value;
    },
    setValue: function (code)  {
      this.textarea.value = code;
    },
    focus: noop,
    getCursor: function () {
      return { line: 0, ch: 0 };
    },
    setCursor: noop,
    currentLine: function () {
      return 0;
    },
    cursorPosition: function () {
      return { character: 0 };
    },
    nthLine: noop,
    refresh: noop,
    selectLines: noop,
    on: noop
  };

  var _oldCM = CodeMirror;

  CodeMirror = noop;

  for (var key in _oldCM) {
    CodeMirror[key] = noop;
  }

  CodeMirror.fromTextArea = function (el, options) {
      return new Editor(el, options);
  };

  CodeMirror.keyMap = { basic: {} };

};  $.fn.splitter = function () {
  var $document = $(document),
      $blocker = $('<div class="block"></div>'),
      $body = $('body');
      // blockiframe = $blocker.find('iframe')[0];

  var splitterSettings = JSON.parse(localStorage.getItem('splitterSettings') || '[]');
  return this.each(function () {
    var $el = $(this),
        $originalContainer = $(this),
        guid = $.fn.splitter.guid++,
        $parent = $el.parent(),
        type = 'x',
        $prev = type === 'x' ? $el.prevAll(':visible:first') : $el.nextAll(':visible:first'),
        $handle = $('<div class="resize"></div>'),
        dragging = false,
        width = $parent.width(),
        parentOffset = $parent.offset(),
        left = parentOffset.left,
        top = parentOffset.top, // usually zero :(
        props = {
          x: {
            currentPos: $parent.offset().left,
            multiplier: 1,
            cssProp: 'left',
            otherCssProp: 'right',
            size: $parent.width(),
            sizeProp: 'width',
            moveProp: 'pageX',
            init: {
              top: 0,
              bottom: 0,
              width: jsbin.mobile ? 44 : 8,
              'margin-left': jsbin.mobile ? '-22px' : '-4px',
              height: '100%',
              left: 'auto',
              right: 'auto',
              opacity: 0,
              position: 'absolute',
              cursor: 'ew-resize',
              // 'border-top': '0',
              'border-left': '1px solid rgba(218, 218, 218, 0.5)',
              'z-index': 99999
            }
          },
          y: {
            currentPos: $parent.offset().top,
            multiplier: -1,
            size: $parent.height(),
            cssProp: 'bottom',
            otherCssProp: 'top',
            sizeProp: 'height',
            moveProp: 'pageY',
            init: {
              top: 'auto',
              cursor: 'ns-resize',
              bottom: 'auto',
              height: 8,
              width: '100%',
              left: 0,
              right: 0,
              opacity: 0,
              position: 'absolute',
              border: 0,
              // 'border-top': '1px solid rgba(218, 218, 218, 0.5)',
              'z-index': 99999
            }
          }
        },
        refreshTimer = null,
        settings = splitterSettings[guid] || {};

    var tracker = {
      down: { x: null, y: null },
      delta: { x: null, y: null },
      track: false,
      timer: null
    };
    $handle.bind('mousedown', function (event) {
      tracker.down.x = event.pageX;
      tracker.down.y = event.pageY;
      tracker.delta = { x: null, y: null };
      tracker.target = $handle[type == 'x' ? 'height' : 'width']() * 0.25;
    });

    $document.bind('mousemove', function (event) {
      if (dragging) {
        tracker.delta.x = tracker.down.x - event.pageX;
        tracker.delta.y = tracker.down.y - event.pageY;
        clearTimeout(tracker.timer);
        tracker.timer = setTimeout(function () {
          tracker.down.x = event.pageX;
          tracker.down.y = event.pageY;
        }, 250);
        var targetType = type == 'x' ? 'y' : 'x';
        if (Math.abs(tracker.delta[targetType]) > tracker.target) {
          $handle.trigger('change', targetType, event[props[targetType].moveProp]);
          tracker.down.x = event.pageX;
          tracker.down.y = event.pageY;
        }
      }
    });

    function moveSplitter(pos) {
      if (type === 'y') {
        pos -= top;
      }
      var v = pos - props[type].currentPos,
          split = 100 / props[type].size * v,
          delta = (pos - settings[type]) * props[type].multiplier,
          prevSize = $prev[props[type].sizeProp](),
          elSize = $el[props[type].sizeProp]();

      if (type === 'y') {
        split = 100 - split;
      }

      // if prev panel is too small and delta is negative, block
      if (prevSize < 100 && delta < 0) {
        // ignore
      } else if (elSize < 100 && delta > 0) {
        // ignore
      } else {
        // allow sizing to happen
        $el.css(props[type].cssProp, split + '%');
        $prev.css(props[type].otherCssProp, (100 - split) + '%');
        var css = {};
        css[props[type].cssProp] = split + '%';
        $handle.css(css);
        settings[type] = pos;
        splitterSettings[guid] = settings;
        localStorage.setItem('splitterSettings', JSON.stringify(splitterSettings));

        // wait until animations have completed!
        if (moveSplitter.timer) clearTimeout(moveSplitter.timer);
        moveSplitter.timer = setTimeout(function () {
          $document.trigger('sizeeditors');
        }, 120);
      }
    }

    function resetPrev() {
      $prev = type === 'x' ? $handle.prevAll(':visible:first') : $handle.nextAll(':visible:first');
    }

    $document.bind('mouseup touchend', function () {
      if (dragging) {
        dragging = false;
        $blocker.remove();
        // $handle.css( 'opacity', '0');
        $body.removeClass('dragging');
      }
    }).bind('mousemove touchmove', function (event) {
      if (dragging) {
        moveSplitter(event[props[type].moveProp] || event.originalEvent.touches[0][props[type].moveProp]);
      }
    });

    $blocker.bind('mousemove touchmove', function (event) {
      if (dragging) {
        moveSplitter(event[props[type].moveProp] || event.originalEvent.touches[0][props[type].moveProp]);
      }
    });

    $handle.bind('mousedown touchstart', function (e) {
      dragging = true;
      $body.append($blocker).addClass('dragging');
      props[type].size = $parent[props[type].sizeProp]();
      props[type].currentPos = 0; // is this really required then?

      resetPrev();
      e.preventDefault();
    });

    /*
    .hover(function () {
      $handle.css('opacity', '1');
    }, function () {
      if (!dragging) {
        $handle.css('opacity', '0');
      }
    })
  */

    $handle.bind('init', function (event, x) {
      $handle.css(props[type].init);
      props[type].size = $parent[props[type].sizeProp]();
      resetPrev();

      // can only be read at init
      top = $parent.offset().top;

      $blocker.css('cursor', type == 'x' ? 'ew-resize' : 'ns-resize');

      if (type == 'y') {
        $el.css('border-right', 0);
        $prev.css('border-left', 0);
        $prev.css('border-top', '2px solid #ccc');
      } else {
        // $el.css('border-right', '1px solid #ccc');
        $el.css('border-top', 0);
        // $prev.css('border-right', '2px solid #ccc');
      }

      if ($el.is(':hidden')) {
        $handle.hide();
      } else {
        if ($prev.length) {
          $el.css('border-' + props[type].cssProp, '1px solid #ccc');
        } else {
          $el.css('border-' + props[type].cssProp, '0');
        }
        moveSplitter(x !== undefined ? x : $el.offset()[props[type].cssProp]);
      }
    }); //.trigger('init', settings.x || $el.offset().left);

    $handle.bind('change', function (event, toType, value) {
      $el.css(props[type].cssProp, '0');
      $prev.css(props[type].otherCssProp, '0');
      $el.css('border-' + props[type].cssProp, '0');

      if (toType === 'y') {
        // 1. drop inside of a new div that encompases the elements
        $el = $el.find('> *');
        $handle.appendTo($prev);
        $el.appendTo($prev);
        $prev.css('height', '100%');
        $originalContainer.hide();
        $handle.css('margin-left', 0);
        $handle.css('margin-top', 5);

        $handle.addClass('vertical');

        delete settings.x;

        $originalContainer.nextAll(':visible:first').trigger('init');
        // 2. change splitter to the right to point to new block div
      } else {
        $el = $prev;
        $prev = $tmp;

        $el.appendTo($originalContainer);
        $handle.insertBefore($originalContainer);
        $handle.removeClass('vertical');
        $el.css('border-top', 0);
        $el = $originalContainer;
        $originalContainer.show();
        $handle.css('margin-top', 0);
        $handle.css('margin-left', -4);
        delete settings.y;

        setTimeout(function() {
          $originalContainer.nextAll(':visible:first').trigger('init');
        }, 0);
      }

      resetPrev();

      type = toType;

      // if (type == 'y') {
        // FIXME $prev should check visible
        var $tmp = $el;
        $el = $prev;
        $prev = $tmp;
      // } else {

      // }

      $el.css(props[type].otherCssProp, '0');
      $prev.css(props[type].cssProp, '0');
      // TODO
      // reset top/bottom positions
      // reset left/right positions

      if ($el.is(':visible')) {
        // find all other handles and recalc their height
        if (type === 'y') {
          var otherhandles = $el.find('.resize');

          otherhandles.each(function (i) {
            // find the top of the
            var $h = $(this);
            if (this === $handle[0]) {
              // ignore
            } else {
              // TODO change to real px :(
              $h.trigger('init', 100 / (otherhandles - i - 1));
            }
          });
        }
        $handle.trigger('init', value || $el.offset()[props[type].cssProp] || props[type].size / 2);
      }
    });


    $prev.css('width', 'auto');
    $prev.css('height', 'auto');
    $el.data('splitter', $handle);
    $el.before($handle);

    // if (settings.y) {
    //   $handle.trigger('change', 'y');
    // }
  });
};

$.fn.splitter.guid = 0;
;var analytics = {
  track: function (category, action, label, value) {
    var data = ['_trackEvent', category, action];
    if (label) {
      data.push(label);
    }
    if (value) {
      data.push(value);
    }

    // console.log(data, (new Error()).stack);
    window._gaq && _gaq.push(data);
  },
  library: function (action, value) {
    analytics.track('menu', action, 'library', value);
  },
  embed: function () {
    analytics.track('state', 'embed');
    try {
      analytics.track('state', 'embed', window.top.location);
    } catch (e) {};
  },
  milestone: function () {
    analytics.track('bin', 'save', window.location.pathname);
  },
  clone: function () {
    analytics.track('bin', 'clone', window.location.pathname);
  },
  lock: function () {
    analytics.track('bin', 'lock', window.location.pathname);
  },
  openShare: function () {
    analytics.track('menu', 'open', 'share');
  },
  saveTemplate: function () {
    analytics.track('menu', 'select', 'save-template');
  },
  createNew: function (from) {
    analytics.track(from || 'menu', 'select', 'new');
  },
  open: function (from) {
    analytics.track(from || 'menu', 'select', 'open');
  },
  openFromAvatar: function () {
    analytics.track('menu', 'select', 'open via avatar');
  },
  openMenu: function (label) {
    analytics.track('menu', 'open', label);
  },
  closeMenu: function (label) {
    analytics.track('menu', 'close', label);
  },
  selectMenu: function (item) {
    if (item) {
      analytics.track('menu', 'select', item);
    }
  },
  share: function (action, label) {
    analytics.track('share', action, label);
  },
  download: function (from) {
    analytics.track(from || 'menu', 'select', 'download');
  },
  showPanel: function (panelId) {
    analytics.track('panel', 'show', panelId);
  },
  hidePanel: function (panelId) {
    analytics.track('panel', 'hide', panelId);
  },
  logout: function () {
    analytics.track('menu', 'select', 'logout');
  },
  register: function (success) {
    if (success === undefined) {
      analytics.track('menu', 'open', 'login');
    } else {
      analytics.track('user', 'register', ok ? 'success' : 'fail');
    }
  },
  login: function (ok) {
    if (ok === undefined) {
      analytics.track('menu', 'open', 'login');
    } else {
      analytics.track('user', 'login', ok ? 'success' : 'fail');
    }
  },
  enableLiveJS: function (ok) {
    analytics.track('button', 'auto-run js', ok ? 'on' : 'off');
  },
  archiveView: function (visible) {
    analytics.track('button', 'view archive', visible ? 'on' : 'off');
  },
  archive: function (url) {
    analytics.track('button', 'archive', url);
  },
  unarchive: function (url) {
    analytics.track('button', 'unarchive', url);
  },
  loadGist: function (id) {
    analytics.track('state', 'load gist', id);
  },
  layout: function (panelsVisible) {
    var layout = [], panel = '';

    for (panel in panelsVisible) {
      layout.push(panel.id);
    }

    analytics.track('layout', 'update', layout.sort().join(',') || 'none');
  },
  run: function (from) {
    analytics.track(from || 'button', 'run with js');
  },
  runconsole: function (from) {
    analytics.track(from || 'button', 'run console');
  }
};

/* TODO
- run js
- run console
- final splitter and panel config & positions!!!
*/
;/** =========================================================================
 * font
 * Reads user setting and configures the CodeMirror font size
 * ========================================================================== */
/*global jsbin:true*/
var font = (function (document) {
  var head = document.getElementsByTagName('head')[0],
      selectors = '#output li, #exec, .fakeInput, #history, .fakeInput:before, #exec:before, .editbox .CodeMirror',
      size = jsbin.settings.font || 14;

  // via http://stackoverflow.com/questions/2041495/create-dynamic-inline-stylesheet
  function font(size) {
    var cssText = selectors + '{ font-size: ' + size + 'px; }',
        el = document.createElement('style');

    el.type= 'text/css';
    if (el.styleSheet) {
      el.styleSheet.cssText = cssText;//IE only
    } else {
      el.appendChild(document.createTextNode(cssText));
    }
    head.appendChild(el);
  }

  if (Object.defineProperty && jsbin.settings) {
    try {
      Object.defineProperty(jsbin.settings, 'font', {
        configurable: true,
        enumerable: true,
        get: function () {
          return size;
        },
        set: function (val) {
          size = val * 1;
          font(size);
        }
      });
    } catch (e) {
      // IE8 seems to attempt the code above, but it totally fails
    }
  }

  font(size);

  return font;
})(document);;var sourceURLctr = 1;

var getPreparedCode = (function () {

  var consoleTest = /(^.|\b)console\./,
      re = {
        docReady: /\$\(document\)\.ready/,
        shortDocReady: /\$\(function/,
        console: /(^.|\b)console\.(\S+)/g,
        script: /<\/script/ig,
        code: /%code%/,
        csscode: /%css%/,
        title: /<title>(.*)<\/title>/i,
        winLoad: /window\.onload\s*=/,
        scriptopen: /<script/gi
      };

  var two = function (i) {
    return ('0'+i).slice(-2);
  };

  return function (nojs) {
    // reset all the regexp positions for reuse
    re.docReady.lastIndex = 0;
    re.shortDocReady.lastIndex = 0;
    re.console.lastIndex = 0;
    re.script.lastIndex = 0;
    re.code.lastIndex = 0;
    re.csscode.lastIndex = 0;
    re.title.lastIndex = 0;
    re.winLoad.lastIndex = 0;
    re.scriptopen.lastIndex = 0;

    var parts = [],
        source = '',
        js = '',
        css = '',
        close = '',
        hasHTML = false,
        hasCSS = false,
        hasJS = false,
        date = new Date();

    try {
      source = editors.html.render();
    } catch (e) {
      if (editors.html.processor.id) {
        window.console && window.console.warn(editors.html.processor.id + ' processor compilation failed');
      }
      window.console && window.console.error(e.message);
    }

    hasHTML = !!$.trim(source);

    if (!nojs) {
      try { // the try/catch is to catch and preprocessor errors
        js = editors.javascript.render();
        var sourceURL = 'sourceURL=jsbin' + jsbin.getURL(true).replace(/\//g, '.') + '-' + sourceURLctr + '.js';
        if (js.trim()) js = js + '\n\n//# ' + sourceURL + '\n//@ ' + sourceURL;
        sourceURLctr++;
      } catch (e) {
        if (editors.javascript.processor.id) {
          window.console && window.console.warn(editors.javascript.processor.id + ' processor compilation failed');
        }

        window.console && window.console.error(e.message);
      }
    }

    try {
      css = editors.css.render();
    } catch (e) {
      if (editors.css.processor.id) {
        window.console && window.console.warn(editors.css.processor.id + ' processor compilation failed');
      }

      window.console && window.console.error(e.message);
    }

    // set the flags *before* we tweak the code with loop protection, etc.
    hasJS = !!js.trim();
    hasCSS = !!$.trim(css);

    // Rewrite loops to detect infiniteness.
    // This is done by rewriting the for/while/do loops to perform a check at
    // the start of each iteration.
    js = loopProtect.rewriteLoops(js);

    // escape any script tags in the JS code, because that'll break the mushing together
    js = js.replace(re.script, '<\\/script');

    // redirect console logged to our custom log while debugging
    if (re.console.test(js)) {
      var replaceWith = 'window.runnerWindow.proxyConsole.';
      // yes, this code looks stupid, but in fact what it does is look for
      // 'console.' and then checks the position of the code. If it's inside
      // an openning script tag, it'll change it to window.top._console,
      // otherwise it'll leave it.
      js = js.replace(re.console, function (all, str, arg, pos) {
        return replaceWith + arg;
      });
    }

    // note that I'm using split and reconcat instead of replace, because if the js var
    // contains '$$' it's replaced to '$' - thus breaking Prototype code. This method
    // gets around the problem.
    if (!hasHTML && hasJS) {
      source = "<pre>\n" + js.replace(/[<>&]/g, function (m) {
        if (m == '<') return '&lt;';
        if (m == '>') return '&gt;';
        // if (m == '"') return '&quot;';
        if (m == '&') return '&amp;';
      }) + "</pre>";
    } else if (re.code.test(source)) {
      parts = source.split('%code%');
      source = parts[0] + js + parts[1];
    } else if (hasJS) {
      close = '';
      if (source.indexOf('</body>') !== -1) {
        parts.push(source.substring(0, source.lastIndexOf('</body>')));
        parts.push(source.substring(source.lastIndexOf('</body>')));

        source = parts[0];
        close = parts.length == 2 && parts[1] ? parts[1] : '';
      }

      // RS: not sure why I ran this in closure, but it means the expected globals are no longer so
      // js = "window.onload = function(){" + js + "\n}\n";
      var type = jsbin.panels.panels.javascript.type ? ' type="text/' + jsbin.panels.panels.javascript.type + '"' : '';

      source += "<script" + type + ">" + js + "\n</script>\n" + close;
    }

    // reapply the same proxyConsole - but to all the source code, since
    if (re.console.test(source)) {
      var replaceWith = 'window.runnerWindow.proxyConsole.';
      // yes, this code looks stupid, but in fact what it does is look for
      // 'console.' and then checks the position of the code. If it's inside
      // an openning script tag, it'll change it to window.top._console,
      // otherwise it'll leave it.
      source = source.replace(re.console, function (all, str, arg, pos) {
        var open = source.lastIndexOf('<script', pos),
            close = source.lastIndexOf('</script', pos);

        if (open > close) {
          return replaceWith + arg;
        } else {
          return all;
        }
      });
    }

    if (!hasHTML && !hasJS && hasCSS) {
      source = "<pre>\n" + css.replace(/[<>&]/g, function (m) {
            if (m == '<') return '&lt;';
            if (m == '>') return '&gt;';
            if (m == '"') return '&quot;';
          }) + "</pre>";
    } else if (re.csscode.test(source)) {
      parts = source.split('%css%');
      source = parts[0] + css + parts[1];
    } else if (css && hasHTML) {
      parts = [];
      close = '';
      if (source.indexOf('</head>') !== -1) {
        parts.push(source.substring(0, source.lastIndexOf('</head>')));
        parts.push(source.substring(source.lastIndexOf('</head>')));

        source = parts[0];
        close = parts.length == 2 && parts[1] ? parts[1] : '';
      }
      source += '<style>\n' + css + '\n</style>\n' + close;
    }

    // Add defer to all inline script tags in IE.
    // This is because IE runs scripts as it loads them, so variables that
    // scripts like jQuery add to the global scope are undefined.
    // See http://jsbin.com/ijapom/5
    if (jsbin.ie && re.scriptopen.test(source)) {
      source = source.replace(/<script(.*?)>/gi, function (all, match) {
        if (match.indexOf('src') !== -1) {
          return all;
        } else {
          return '<script defer' + match + '>';
        }
      });
    }

    // read the element out of the source code and plug it in to our document.title
    var newDocTitle = source.match(re.title);
    if (newDocTitle !== null && newDocTitle[1] !== documentTitle) {
      documentTitle = newDocTitle[1].trim();
      if (documentTitle) {
        document.title = documentTitle + ' - ' + 'JS Bin';
      } else {
        document.title = 'JS Bin';
      }
    }

    return source;
  }

}());
;var $live = $('#live'),
    showlive = $('#showlive')[0];

/**
 * Defer callable. Kinda tricky to explain. Basically:
 *  "Don't make newFn callable until I tell you via this trigger callback."
 *
 * Example:

      // Only start logging after 3 seconds
      var log = function (str) { console.log(str); };
      var deferredLog = deferCallable(log, function (done) {
        setTimeout(done, 3000);
      });

      setInterval(function () {
        deferredLog(Date.now(), 500);
      });

 */
var deferCallable = function (newFn, trigger) {
  var args,
      pointerFn = function () {
        // Initially, the pointer basically does nothing, waiting for the
        // trigger to fire, but we save the arguments that wrapper was called
        // with so that they can be passed to the newFn when it's ready.
        args = [].slice.call(arguments);
      };

  // Immediately call the trigger so that the user can inform us of when
  // the newFn is callable.
  // When it is, swap round the pointers and, if the wrapper was aleady called,
  // immediately call the pointerFn.
  trigger(function () {
    pointerFn = newFn;
    if (args) {
      pointerFn.apply(null, args);
    }
  });

  // Wrapper the pointer function. This means we can swap pointerFn around
  // without breaking external references.
  return function wrapper() {
    return pointerFn.apply(null, [].slice.call(arguments));
  };
};

/**
 * =============================================================================
 * =============================================================================
 * =============================================================================
 */

function sendReload() {
  if (saveChecksum) {
    $.ajax({
      url: jsbin.getURL() + '/reload',
      data: {
        code: jsbin.state.code,
        revision: jsbin.state.revision,
        checksum: saveChecksum
      },
      type: 'post'
    });
  }
}

function codeChangeLive(event, data) {
  clearTimeout(deferredLiveRender);

  var editor,
      line,
      panel = jsbin.panels.panels.live;

  if (jsbin.panels.ready) {
    if (jsbin.settings.includejs === false && data.panelId === 'javascript') {
      // ignore
    } else if (panel.visible) {
      // test to see if they're write a while loop
      if (!jsbin.lameEditor && jsbin.panels.focused && jsbin.panels.focused.id === 'javascript') {
        // check the current line doesn't match a for or a while or a do - which could trip in to an infinite loop
        editor = jsbin.panels.focused.editor;
        line = editor.getLine(editor.getCursor().line);
        if (ignoreDuringLive.test(line) === true) {
          // ignore
          throttledPreview.cancel();
          deferredLiveRender = setTimeout(function () {
            codeChangeLive(event, data);
          }, 1000);
        } else {
          throttledPreview();
        }
      } else {
        throttledPreview();
      }
    }
  }
}

/** ============================================================================
 * JS Bin Renderer
 * Messages to and from the runner.
 * ========================================================================== */

var renderer = (function () {

  var renderer = {};

  /**
   * Store what runner origin *should* be
   * TODO this should allow anything if x-origin protection should be disabled
   */
  renderer.runner = {};
  renderer.runner.origin = '*';

  /**
   * Setup the renderer
   */
  renderer.setup = function (runnerFrame) {
    renderer.runner.window = runnerFrame.contentWindow;
    renderer.runner.iframe = runnerFrame;
  };

  /**
   * Log error messages, indicating that it's from the renderer.
   */
  renderer.error = function () {
    // it's quite likely that the error that fires on this handler actually comes
    // from another service on the page, like a browser plugin, which we can
    // safely ignore.
    window.console.warn.apply(console, ['Renderer:'].concat([].slice.call(arguments)));
  };

  /**
   * Handle all incoming postMessages to the renderer
   */
  renderer.handleMessage = function (event) {
    if (!event.origin) return;
    var data = event.data;
    try {
      data = JSON.parse(event.data);
    } catch (e) {
      return renderer.error('Error parsing event data:', e.message);
    }
    if (typeof renderer[data.type] !== 'function') {
      return renderer.error('No matching event handler:', data.type);
    }
    try {
      renderer[data.type](data.data);
    } catch (e) {
      renderer.error(e.message);
    }
  };

  /**
   * Send message to the runner window
   */
  renderer.postMessage = function (type, data) {
    if (!renderer.runner.window) {
      return renderer.error('postMessage: No connection to runner window.');
    }
    renderer.runner.window.postMessage(JSON.stringify({
      type: type,
      data: data
    }), renderer.runner.origin);
  };

  /**
   * When the iframe resizes, update the size text
   */
  renderer.resize = (function () {
    var size = $live.find('.size');

    var hide = throttle(function () {
      size.fadeOut(200);
    }, 2000);

    return function (data) {
      if (!jsbin.embed) {
        // Display the iframe size in px in the JS Bin UI
        size.show().html(data.width + 'px');
        hide();
      }
      if (jsbin.embed) {
        // Inform the outer page of a size change
        var height = ($body.outerHeight(true) - $(renderer.runner.iframe).height()) + data.offsetHeight;
        window.parent.postMessage({ height: height }, '*');
      }
    };
  }());

  /**
   * When the iframe focuses, simulate that here
   */
  renderer.focus = function () {
    $('#live').focus();
    // also close any open dropdowns
    closedropdown();
  };

  /**
   * Proxy console logging to JS Bin's console
   */
  renderer.console = function (data) {
    var method = data.method,
        args = data.args;
    if (!window._console) return;
    if (!window._console[method]) method = 'log';
    window._console[method].apply(window._console, args);
  };

  /**
   * Load scripts into rendered iframe
   */
  renderer['console:load:script:success'] = function (url) {
    $document.trigger('console:load:script:success', url);
  };

  renderer['console:load:script:error'] = function (err) {
    $document.trigger('console:load:script:error', err);
  };

  /**
   * Load DOME into rendered iframe
   * TODO abstract these so that they are automatically triggered
   */
  renderer['console:load:dom:success'] = function (url) {
    $document.trigger('console:load:dom:success', url);
  };

  renderer['console:load:dom:error'] = function (err) {
    $document.trigger('console:load:dom:error', err);
  };

  return renderer;

}());

/** ============================================================================
 * Live rendering.
 *
 * Comes in two tasty flavours. Basic mode, which is essentially an IE7
 * fallback. Take a look at https://github.com/remy/jsbin/issues/651 for more.
 * It uses the iframe's name and JS Bin's event-stream support to keep the
 * page up-to-date.
 *
 * The second mode uses postMessage to inform the runner of changes to code,
 * config and anything that affects rendering, and also listens for messages
 * coming back to update the JS Bin UI.
 * ========================================================================== */

/**
 * Render live preview.
 * Create the runner iframe, and if postMe wait until the iframe is loaded to
 * start postMessaging the runner.
 */
var renderLivePreview = (function () {

  // Runner iframe
  var iframe;

  // Basic mode
  // This adds the runner iframe to the page. It's only run once.
  if (!$live.find('iframe').length) {
    iframe = document.createElement('iframe');
    iframe.setAttribute('class', 'stretch');
    iframe.setAttribute('sandbox', 'allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts');
    iframe.setAttribute('frameBorder', '0');
    $live.prepend(iframe);
    iframe.src = jsbin.runner;
    try {
      iframe.contentWindow.name = '/' + jsbin.state.code + '/' + jsbin.state.revision;
    } catch (e) {
      // ^- this shouldn't really fail, but if we're honest, it's a fucking mystery as to why it even works.
      // problem is: if this throws (because iframe.contentWindow is undefined), then the execution exits
      // and `var renderLivePreview` is set to undefined. The knock on effect is that the calls to renderLivePreview
      // then fail, and jsbin doesn't boot up. Tears all round, so we catch.
    }
  }

  // The big daddy that handles postmessaging the runner.
  var renderLivePreview = function (requested) {
    // No postMessage? Don't render â€“ the event-stream will handle it.
    if (!window.postMessage) return;

    var source = getPreparedCode(),
        includeJsInRealtime = jsbin.settings.includejs;
    // Inform other pages event streaming render to reload
    if (requested) sendReload();

    // Tell the iframe to reload
    renderer.postMessage('render', {
      source: source,
      options: {
        requested: requested,
        debug: jsbin.settings.debug,
        includeJsInRealtime: jsbin.settings.includejs
      }
    });
  };

  /**
   * Events
   */

  // Listen for console input and post it to the iframe
  $document.on('console:run', function (event, cmd) {
    renderer.postMessage('console:run', cmd);
  });

  $document.on('console:load:script', function (event, url) {
    renderer.postMessage('console:load:script', url);
  });

  $document.on('console:load:dom', function (event, html) {
    renderer.postMessage('console:load:dom', html);
  });

  // When the iframe loads, swap round the callbacks and immediately invoke
  // if renderLivePreview was called already.
  return deferCallable(renderLivePreview, function (done) {
    iframe.onload = function () {
      if (window.postMessage) {
        // Setup postMessage listening to the runner
        $window.on('message', function (event) {
          renderer.handleMessage(event.originalEvent);
        });
        renderer.setup(iframe);
      }
      done();
    };
  });

}());


// this needs to be after renderLivePreview is set (as it's defined using
// var instead of a first class function).
var throttledPreview = throttle(renderLivePreview, 200),
    liveScrollTop = null;

// timer value: used in the delayed render (because iframes don't have
// innerHeight/Width) in Chrome & WebKit
var deferredLiveRender = null;

$document.bind('codeChange.live', codeChangeLive);
;//= require "autocomplete"
//= require "../chrome/esc"

var keyboardHelpVisible = false;

var customKeys = objectValue('jsbin.settings.keys') || {};

$('#enablealt').attr('checked', customKeys.useAlt ? true : false).change(function () {
  if (!jsbin.settings.keys) {
    jsbin.settings.keys = {};
  }
  jsbin.settings.keys.useAlt = this.checked;
});

if (!customKeys.disabled) $body.keydown(keycontrol);

var panelShortcuts = {}
//   49: 'javascript', // 1
//   50: 'css', // 2
//   51: 'html', // 3
//   52: 'console', // 4
//   53: 'live' // 5
// };
panelShortcuts.start = 48;

// work out the browser platform
var ua = navigator.userAgent;
if (/macintosh|mac os x/.test(ua)) {
  $.browser.platform = 'mac';
} else if (/windows|win32/.test(ua)) {
  $.browser.platform = 'win';
} else if (/linux/.test(ua)) {
  $.browser.platform = 'linux';
} else {
  $.browser.platform = '';
}

// var closekey = $.browser.platform == 'mac' ? 167 : 192;

if (!customKeys.disabled) $document.keydown(function (event) {
  var includeAltKey = customKeys.useAlt ? event.altKey : !event.altKey,
      closekey = customKeys.closePanel ? customKeys.closePanel : 192;

  if (event.ctrlKey) event.metaKey = true;

  if (event.metaKey && event.which == 79) { // open
    $('.homebtn').trigger('click', 'keyboard');
    event.preventDefault();
  } else if (event.metaKey && event.which == 83) { // save
    if (event.shiftKey == false) {
      if (saveChecksum) {
        saveChecksum = false;
      } else {
        // trigger an initial save
        $('a.save:first').click();
      }
      event.preventDefault();
    } else if (event.shiftKey == true) { // shift+s = clone
      $('.clone').click();
      event.preventDefault();
    }
  } else if (event.which === closekey && event.metaKey && includeAltKey && jsbin.panels.focused) {
    jsbin.panels.hide(jsbin.panels.focused.id);
  } else if (event.which === 220 && (event.metaKey || event.ctrlKey)) {
    jsbin.settings.hideheader = !jsbin.settings.hideheader;
    $body[jsbin.settings.hideheader ? 'addClass' : 'removeClass']('hideheader');
  } else if (event.which === 76 && event.ctrlKey && jsbin.panels.panels.console.visible) {
    if (event.shiftKey) {
      // reset
      jsconsole.reset();
    } else {
      // clear
      jsconsole.clear();
    }
  }
});

var ignoreNextKey = false;

function keycontrol(event) {
  event = normalise(event);

  var panel = {};

  if (jsbin.panels.focused && jsbin.panels.focused.editor) {
    panel = jsbin.panels.focused.editor;
  } else if (jsbin.panels.focused) {
    panel = jsbin.panels.focused;
  }

  var codePanel = { css: 1, javascript: 1, html: 1}[panel.id],
      hasRun = false;

  var includeAltKey = customKeys.useAlt ? event.altKey : !event.altKey;

  if (event.which === 27 && !ignoreNextKey) {
    ignoreNextKey = true;
    return;
  } else if (ignoreNextKey && panelShortcuts[event.which] !== undefined && event.metaKey && includeAltKey) {
    ignoreNextKey = false;
    return;
  } else if (!event.metaKey) {
    ignoreNextKey = false;
  }

  // these should fire when the key goes down
  if (event.type == 'keydown') {
    if (codePanel) {
      if (event.metaKey && event.which == 13) {
        if (editors.console.visible && !editors.live.visible) {
          hasRun = true;
          // editors.console.render();
          $('#runconsole').trigger('click', 'keyboard');
        } else if (editors.live.visible) {
          // editors.live.render(true);
          $('#runwithalerts').trigger('click', 'keyboard');
          hasRun = true;
        } else {
          $('#runwithalerts').trigger('click', 'keyboard');
          hasRun = true;
        }

        if (hasRun) {
          event.stop();
        } else {
          // if we have write access - do a save - this will make this bin our latest for use with
          // /<user>/last/ - useful for phonegap inject
          sendReload();
        }
      }
    }

    // shortcut for showing a panel
    if (panelShortcuts[event.which] !== undefined && event.metaKey && includeAltKey) {
      if (jsbin.panels.focused.id === panelShortcuts[event.which]) {
        // hide
        jsbin.panels.hide(panelShortcuts[event.which]);
      } else {
        // show
        jsbin.panels.show(panelShortcuts[event.which]);
      }
      event.stop();
    }

    if (event.which == 191 && event.metaKey && event.shiftKey) {
      // show help
      $body.toggleClass('keyboardHelp');
      keyboardHelpVisible = $body.is('.keyboardHelp');
      if (keyboardHelpVisible) {
        analytics.track('keyboard', 'select', 'help');
      }
      event.stop();
    } else if (event.which == 27 && keyboardHelpVisible) {
      $body.removeClass('keyboardHelp');
      keyboardHelpVisible = false;
      event.stop();
    } else if (event.which == 27 && jsbin.panels.focused && codePanel) {
      // event.stop();
      // return CodeMirror.commands.autocomplete(jsbin.panels.focused.editor);
    } else if (event.which == 190 && includeAltKey && event.metaKey && panel.id == 'html') {
      // auto close the element
      if (panel.somethingSelected()) return;
      // Find the token at the cursor
      var cur = panel.getCursor(false), token = panel.getTokenAt(cur), tprop = token;
      // If it's not a 'word-style' token, ignore the token.
      if (!/^[\w$_]*$/.test(token.string)) {
        token = tprop = {start: cur.ch, end: cur.ch, string: "", state: token.state,
                         className: token.string == "." ? "js-property" : null};
      }

      panel.replaceRange('</' + token.state.htmlState.context.tagName + '>', {line: cur.line, ch: token.end}, {line: cur.line, ch: token.end});
      event.stop();
    } else if (event.which == 188 && event.ctrlKey && event.shiftKey && codePanel) {
      // start a new tag
      event.stop();
      return startTagComplete(panel);
    }
  }
  // return true;

  if (event.stopping) {
    return false;
  }
}

function normalise(event) {
  var myEvent = {
    type: event.type,
    which: event.which,
    metaKey: event.metaKey,
    shiftKey: event.shiftKey,
    ctrlKey: event.ctrlKey,
    altKey: event.altKey,
    orig: event
  };

  if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
    myEvent.which = event.charCode != null ? event.charCode : event.keyCode;
  }

  // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
  if ( !event.metaKey && event.ctrlKey ) {
    myEvent.metaKey = event.ctrlKey;
  }

  // this is retarded - I'm having to mess with the event just to get Firefox
  // to send through the right value. i.e. when you include a shift key modifier
  // in Firefox, if it's punctuation - event.which is zero :(
  // Note that I'm only doing this for the ? symbol + ctrl + shift
  if (event.which === 0 && event.ctrlKey === true && event.shiftKey === true && event.type == 'keydown') {
    myEvent.which = 191;
  }

  var oldStop = event.stop;
  myEvent.stop = function () {
    myEvent.stopping = true;
    oldStop && oldStop.call(event);
  };

  return myEvent;
}
;var jsconsole = (function (window) {

// Key-code library
var keylib={left:37,up:38,right:39,down:40,space:32,
            alt:18,ctrl:17,shift:16,tab:9,enter:13,webkitEnter:10,
            escape:27,backspace:8,
            zero:48,one:49, two:50,three:51,four:52,
            five:53,six:57,seven:58,eight:59,nine:60,
            a:65,b:66,c:67,d:68,e:69,f:70,g:71,h:72,i:73,j:74,k:75,
            l:76,m:77,n:78,o:79,p:80,q:81,r:82,s:83,t:84,u:85,v:86,
            w:87,x:88,y:89,z:90};

function cleanse(s) {
  return (s||'').replace(/[<&]/g, function (m) { return {'&':'&amp;','<':'&lt;'}[m];});
}

/**
 * Run a console command.
 */
var run = function (cmd, cb) {
  var internalCmd = internalCommand(cmd);
  if (internalCmd) {
    return cb(['info', internalCmd]);
  }
  $document.trigger('console:run', cmd);
};

/**
 * Run and show response to a command fired from the console
 */
var post = function (cmd, blind, response) {
  var toecho = '';
  if (typeof cmd !== 'string') {
    toecho = cmd.echo;
    blind = cmd.blind;
    response = cmd.response;
    cmd = cmd.cmd;
  } else {
    toecho = cmd;
  }

  cmd = trim(cmd);

  // Add the command to the user's history â€“ unless this was blind
  if (!blind) {
    history.push(cmd.trim());
    setHistory(history);
  }

  // Show the user what they typed
  echo(toecho.trim());

  // If we were handed a response, show the response straight away â€“ otherwise
  // runs it
  if (response) return showResponse(response);
  run(cmd, showResponse);

};

/**
 * Display the result of a command to the user
 */
var showResponse = function (response) {

  // order so it appears at the top
  var el = document.createElement('div'),
      li = document.createElement('li'),
      span = document.createElement('span'),
      parent = output.parentNode;

  pos = history.length;

  if (typeof response === 'undefined') return;

  el.className = 'response';
  span.innerHTML = response[1];

  if (response[0] != 'info') prettyPrint([span]);
  el.appendChild(span);

  li.className = response[0];
  li.innerHTML = '<span class="gutter"></span>';
  li.appendChild(el);

  appendLog(li);

  exec.value = '';
  if (enableCC) {
    try {
      if (jsbin.panels && jsbin.panels.focused.id === 'console') {
        if (!jsbin.embed) {
          getCursor().focus();
        }
        document.execCommand('selectAll', false, null);
        document.execCommand('delete', false, null);
      }
    } catch (e) {}
  }

};

function log(msg, className) {
  var li = document.createElement('li'),
      div = document.createElement('div');

  div.innerHTML = msg;
  prettyPrint([div]);
  li.className = className || 'log';
  li.innerHTML = '<span class="gutter"></span>';
  li.appendChild(div);

  appendLog(li);
}

function echo(cmd) {
  var li = document.createElement('li');

  li.className = 'echo';
  li.innerHTML = '<span class="gutter"></span><div>' + cleanse(cmd) + '</div>';

  logAfter = null;

  // logAfter = $(output).find('li.echo:first')[0] || null;

  // logAfter = output.querySelector('li.echo') || null;
  appendLog(li, true);
}

window.info = function(cmd) {
  var li = document.createElement('li');

  li.className = 'info';
  li.innerHTML = '<span class="gutter"></span><div>' + cleanse(cmd) + '</div>';

  // logAfter = output.querySelector('li.echo') || null;
  // appendLog(li, true);
  appendLog(li);
};

function appendLog(el, echo) {
  output.appendChild(el);
  output.parentNode.scrollTop = output.parentNode.scrollHeight + 1000;
  return;

  if (echo) {
    if (!output.firstChild) {
      output.appendChild(el);
    } else {
      output.insertBefore(el, output.firstChild);
    }
  } else {
    if (!output.lastChild) {
      output.appendChild(el);
    } else {
      // console.log(output.lastChild.nextSibling);
      output.insertBefore(el, logAfter ? logAfter : output.lastChild.nextSibling); //  ? output.lastChild.nextSibling : output.firstChild
    }
  }
}

function internalCommand(cmd) {
  var parts = [], c;
  if (cmd.substr(0, 1) == ':') {
    parts = cmd.substr(1).split(' ');
    c = parts.shift();
    return (commands[c] || noop).apply(this, parts);
  }
}

function noop() {}

function showhelp() {
  var commands = [
    ':reset - destroy state and start afresh',
    ':history - list current session history',
    ':load &lt;url&gt; - to inject new DOM',
    ':load &lt;script_url&gt; - to inject external library',
    '      load also supports following shortcuts: <br />      jquery, underscore, prototype, mootools, dojo, rightjs, coffeescript, yui.<br />      eg. :load jquery',
    ':clear - to clear contents of the console',
    ':about jsconsole'
  ];
  return commands.join('\n');
}

/**
 * Handle loading scripts and DOM into dynamic iframe with event listeners
 */
var load = (function () {

  $document.on('console:load:script:error', function (event, err) {
    showResponse(['error', err]);
  });

  $document.on('console:load:script:success', function (event, url) {
    showResponse(['response', 'Loaded "' + url + '"']);
  });

  $document.on('console:load:dom:error', function (event, err) {
    showResponse(['error', err]);
  });

  $document.on('console:load:dom:success', function (event, url) {
    showResponse(['response', 'Loaded DOM.']);
  });

  return function (url) {
    if (navigator.onLine) {
      if (arguments.length > 1 || libraries[url] || url.indexOf('.js') !== -1) {
        return loadScript.apply(this, arguments);
      } else {
        return loadDOM(url);
      }
    } else {
      return "You need to be online to use :load";
    }
  }
}());

function loadScript() {
  for (var i = 0; i < arguments.length; i++) {
    (function (url) {
      $document.trigger('console:load:script', url);
    })(libraries[arguments[i]] || arguments[i]);
  }
  return "Loading script...";
}

function loadDOM(url) {
  var script = document.createElement('script'),
      cb = 'loadDOM' + +new Date;

  script.src = 'http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20html%20where%20url%3D%22' + encodeURIComponent(url) + '%22&format=xml&callback=' + cb;

  window[cb] = function (yql) {
    if (yql.results.length) {
      var html = yql.results[0].replace(/type="text\/javascript"/ig,'type="x"').replace(/<body.*?>/, '').replace(/<\/body>/, '');

      $document.trigger('console:load:dom', html);
    } else {
      log('Failed to load DOM', 'error');
    }
    try {
      window[cb] = null;
      delete window[cb];
    } catch (e) {}

  };

  document.body.appendChild(script);

  return "Loading URL into DOM...";
}

function trim(s) {
  return (s||"").replace(/^\s+|\s+$/g,"");
}

var ccCache = {};
var ccPosition = false;

window._console = {
  clear: function () {
    output.innerHTML = '';
  },
  log: function () {
    var l = arguments.length, i = 0;
    for (; i < l; i++) {
      log(''+arguments[i], true);
    }
  },
  dir: function () {
    var l = arguments.length, i = 0;
    for (; i < l; i++) {
      log(arguments[i]);
    }
  },
  props: function (obj) {
    var props = [], realObj;
    try {
      for (var p in obj) props.push(p);
    } catch (e) {}
    return props;
  },
  error: function (err) {
    log(err.message || err, 'error');
  }
};

// give info support too
window._console.info = window._console.log;

function about() {
  return 'Ported to JS Bin from <a target="_new" href="http://jsconsole.com">jsconsole.com</a>';
}

function setHistory(history) {
  if (typeof JSON == 'undefined') return;

  try {
    // because FF with cookies disabled goes nuts, and because sometimes WebKit goes nuts too...
    sessionStorage.setItem('history', JSON.stringify(history));
  } catch (e) {}
}

function getHistory() {
  var history = [''];

  if (typeof JSON == 'undefined') return history;

  try {
    // because FF with cookies disabled goes nuts, and because sometimes WebKit goes nuts too...
    history = JSON.parse(sessionStorage.getItem('history') || '[""]');
  } catch (e) {}
  return history;
}

function showHistory() {
  var h = getHistory();
  h.shift();
  return h.join("\n");
}

var exec = document.getElementById('exec'),
    form = exec.form || {},
    output = null,
    history = getHistory(),
    fakeConsole = 'window.parent._console',
    libraries = {
        jquery: 'http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js',
        prototype: 'http://ajax.googleapis.com/ajax/libs/prototype/1/prototype.js',
        dojo: 'http://ajax.googleapis.com/ajax/libs/dojo/1/dojo/dojo.xd.js',
        mootools: 'http://ajax.googleapis.com/ajax/libs/mootools/1/mootools-yui-compressed.js',
        underscore: 'http://documentcloud.github.com/underscore/underscore-min.js',
        rightjs: 'http://rightjs.org/hotlink/right.js',
        coffeescript: 'http://jashkenas.github.com/coffee-script/extras/coffee-script.js',
        yui: 'http://yui.yahooapis.com/3.9.1/build/yui/yui-min.js'
    },
    body = document.getElementsByTagName('body')[0],
    logAfter = null,
    lastCmd = null,
    wait = false,
    commandPresent = /:((?:help|about|load|clear|reset|wait|history)(?:.*))\n/gi,
    commands = {
      history: showHistory,
      help: showhelp,
      about: about,
      load: load,
      wait: function () {
        wait = true;
        return '';
      },
      clear: function () {
        setTimeout(function () { output.innerHTML = ''; }, 10);
        return 'clearing...';
      },
      reset: function () {
        output.innerHTML = '';
        jsconsole.init(output, true);
        return 'Context reset';
      }
    },
    fakeInput = null,
    getCursor = (function () {
      var cursor;
      return function () {
        if (cursor) return cursor;
        return document.getElementById('cursor');
      };
    }()),
    // I hate that I'm browser sniffing, but there's issues with Firefox and execCommand so code completion won't work
    iOSMobile = navigator.userAgent.indexOf('AppleWebKit') !== -1 && navigator.userAgent.indexOf('Mobile') !== -1,
    // FIXME Remy, seriously, don't sniff the agent like this, it'll bite you in the arse.
    enableCC = navigator.userAgent.indexOf('AppleWebKit') !== -1 && navigator.userAgent.indexOf('Mobile') === -1 || navigator.userAgent.indexOf('OS 5_') !== -1;

if (enableCC) {
  var autofocus = jsbin.embed ? '' : 'autofocus';
  exec.parentNode.innerHTML = '<div ' + autofocus + ' id="exec" autocapitalize="off" spellcheck="false"><span id="cursor" spellcheck="false" autocapitalize="off" autocorrect="off"' + (iOSMobile ? '' : ' contenteditable') + '></span></div>';
  exec = document.getElementById('exec');
} else {
  $('#console').addClass('plain');
}

if (enableCC && iOSMobile) {
  fakeInput = document.createElement('input');
  fakeInput.className = 'fakeInput';
  fakeInput.setAttribute('spellcheck', 'false');
  fakeInput.setAttribute('autocorrect', 'off');
  fakeInput.setAttribute('autocapitalize', 'off');
  exec.parentNode.appendChild(fakeInput);
}

function whichKey(event) {
  var keys = {38:1, 40:1, Up:38, Down:40, Enter:10, 'U+0009':9, 'U+0008':8, 'U+0190':190, 'Right':39,
      // these two are ignored
      'U+0028': 57, 'U+0026': 55 };
  return keys[event.keyIdentifier] || event.which || event.keyCode;
}

function setCursorTo(str) {
  str = enableCC ? cleanse(str) : str;
  exec.value = str;

  if (enableCC) {
    document.execCommand('selectAll', false, null);
    document.execCommand('delete', false, null);
    document.execCommand('insertHTML', false, str);
  } else {
    var rows = str.match(/\n/g);
    exec.setAttribute('rows', rows !== null ? rows.length + 1 : 1);
  }
  getCursor().focus();
}

exec.ontouchstart = function () {
  window.scrollTo(0,0);
};

function findNode(list, node) {
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    if (list[i] == node) {
      return pos;
    }
    pos += list[i].nodeValue.length;
  }
  return -1;
};

/**
 * Handle keydown events in the console - the money shot.
 */
exec.onkeydown = function (event) {
  event = event || window.event;
  var keys = {38:1, 40:1},
      wide = body.className == 'large',
      which = whichKey(event),
      enterDown = (which == keylib.enter || which == keylib.webkitEnter);

  if (typeof which == 'string') which = which.replace(/\/U\+/, '\\u');
  // Is this a special key?
  if (keys[which]) {
    if (event.shiftKey) return;
    // History cycle

    // Allow user to navigate multiline pieces of code
    if (window.getSelection) {
      window.selObj = window.getSelection();
      var selRange = selObj.getRangeAt(0),
          cursorPos =  findNode(selObj.anchorNode.parentNode.childNodes, selObj.anchorNode) + selObj.anchorOffset;

      var value = exec.value,
          firstNewLine = value.indexOf('\n'),
          lastNewLine = value.lastIndexOf('\n');

      if (firstNewLine !== -1) {
        if (which == keylib.up && cursorPos > firstNewLine) {
          return;
        } else if (which == keylib.down && cursorPos < value.length) {
          return;
        }
      }
    }

    // Up
    if (which == keylib.up) {
      pos--;
      // Don't go past the start
      if (pos < 0) pos = 0; //history.length - 1;
    }
    // Down
    if (which == keylib.down) {
      pos++;
      // Don't go past the end
      if (pos >= history.length) pos = history.length; //0;
    }
    if (history[pos] != undefined && history[pos] !== '') {
      setCursorTo(history[pos]);
      return false;
    } else if (pos == history.length) {
      setCursorTo('');
      return false;
    }
  }

  // Execute the code
  else if (enterDown && event.shiftKey == false) { // enter (what about the other one)
    var command = exec.textContent || exec.value;
    // ======================================================================
    if (command.length) post(command);
    // ======================================================================
    return false;
  }

  // Expand the textarea
  else if (enterDown && event.shiftKey == true) {
    var rows = exec.value.match(/\n/g);
    rows = rows != null ? rows.length + 2 : 2;
    exec.setAttribute('rows', rows);
  }

  // Clear the console.
  // Ctrl+L or Meta+Shift+Backspace
  else if ((event.shiftKey && event.metaKey && which == keylib.backspace) ||
           (event.ctrlKey && which == keylib.l)) {
    output.innerHTML = '';
  }
};

if (enableCC && iOSMobile) {
  fakeInput.onkeydown = function (event) {
    var which = whichKey(event),
        enterDown = (which == keylib.enter || which == keylib.webkitEnter)

    if (enterDown) {
      post(this.value);
      this.value = '';
      getCursor().innerHTML = '';
      return false;
    }
  };
}

form.onsubmit = function (event) {
  event = event || window.event;
  event.preventDefault && event.preventDefault();
  post(exec.textContent || exec.value);
  return false;
};

document.onkeydown = function (event) {
  event = event || window.event;
  var which = event.which || event.keyCode;

  if (event.shiftKey && event.metaKey && which == 8) {
    output.innerHTML = '';
    getCursor().focus();
  } else if (event.target == output.parentNode && which == 32) { // space
    output.parentNode.scrollTop += 5 + output.parentNode.offsetHeight * (event.shiftKey ? -1 : 1);
  }
};

exec.onclick = function () {
  getCursor().focus();
};

var jsconsole = {
  run: post,
  clear: commands.clear,
  reset: function () {
    this.run(':reset');
  },
  focus: function () {
    if (enableCC) {
      getCursor().focus();
    } else {
      $(exec).focus();
    }
  },
  echo: echo,
  _onloadQueue: [],
  onload: function (fn) {
    var i = 0, length = this._onloadQueue.length;
    if (this.ready === false && fn) { // if not ready and callback passed - cache it
      this._onloadQueue.push(fn);
    } else if (this.ready === true && !fn) { // if ready and not callback - flush cache
      for (; i < length; i++) {
        this._onloadQueue[i].call(this);
      }
      this._onloadQueue = [];
    } else if (fn) { // if callback and ready - run callback
      fn.call(this);
    }
  },
  init: function (outputElement, nohelp) {
    output = outputElement;

    jsconsole.ready = true;
    jsconsole.onload();

    if (nohelp === undefined) post(':help', true);
  },
  rawMessage: function (data) {
    if (data.type && data.type == 'error') {
      post(data.cmd, true, ['error', data.response]);
    } else if (data.type && data.type == 'info') {
      window.top.info(data.response);
    } else {
      if (data.cmd.indexOf('console.log') === -1) data.response = data.response.substr(1, data.response.length - 2); // fiddle to remove the [] around the repsonse
      echo(data.cmd);
      log(data.response, 'response');
    }
  }
};

return jsconsole;

})(this);

var msgType = '';

jsconsole.init(document.getElementById('output'));

function upgradeConsolePanel(console) {
    console.$el.click(function () {
      jsconsole.focus();
    });
    console.reset = function () {
      jsconsole.reset();
    };
    console.settings.render = function (withAlerts) {
      var html = editors.html.render().trim();
      if (html === "") {
        var echo = editors.javascript.render().trim();
        var code = getPreparedCode().replace(/<pre>/, '').replace(/<\/pre>/, '');

        // Tell the iframe to reload
        renderer.postMessage('render', {
          source: '<html>'
        });

        setTimeout(function() {
          jsconsole.run({
            echo: echo,
            cmd: code
          });
        }, 0);
      } else {
        renderLivePreview(withAlerts || false);
      }
    };
    console.settings.show = function () {
      jsconsole.clear();
      // renderLivePreview(true);
      // setTimeout because the renderLivePreview creates the iframe after a timeout
      setTimeout(function () {
        if (editors.console.ready && !jsbin.embed) jsconsole.focus();
      }, 0);
    };
    console.settings.hide = function () {
      // Removal code is commented out so that the
      // output iframe is never removed
      if (!editors.live.visible) {
        // $live.find('iframe').remove();
      }
    };

    $document.one('jsbinReady', function () {
      var hidebutton = function () {
        $('#runconsole')[this.visible ? 'hide' : 'show']();
      };

      jsbin.panels.panels.live.on('show', hidebutton).on('hide', hidebutton);

      if (jsbin.panels.panels.live.visible) {
        $('#runconsole').hide();
      }

    });
}
;/*globals $:true, JSHINT:true, editors:true, $document:true, escapeHTML:true, jsbin:true, throttle:true */

var jshint = function () {
  var source = editors.javascript.editor.getCode();
  var ok = JSHINT(source);

  return ok ? true : JSHINT.data();
};

var jshintEnabled = true;

var detailsSupport = 'open' in document.createElement('details');

// yeah, this is happening. Fucking IE...sheesh.
var html = $.browser.msie && $.browser.version < 9 ? '<div class="details"><div class="summary">warnings</div>' : '<details><summary class="summary">warnings</summary></details>';

var $error = $(html).appendTo('.panel.javascript').hide();

$error.find('.summary').click(function () {
  if (!detailsSupport) {
    $(this).nextAll().toggle();
    $error[0].open = !$error[0].open;
  }
  // trigger a resize after the click has completed and the details is close
  setTimeout(function () {
    $document.trigger('sizeeditors');
  }, 10);
});

if (!detailsSupport) {
  $error[0].open = false;
}

// modify JSHINT to only return errors that are of value (to me, for displaying)
JSHINT._data = JSHINT.data;
JSHINT.data = function (onlyErrors) {
  var data = JSHINT._data(),
      errors = [];

  if (onlyErrors && data.errors) {
    for (var i = 0; i < data.errors.length; i++) {
      if (data.errors[i] !== null && data.errors[i].evidence) { // ignore JSHINT just quitting
        errors.push(data.errors[i]);
      } else if (data.errors[i] !== null && data.errors[i].reason.indexOf('Stopping') === 0) {
        errors.push('Fatal errors, unable to continue');
      }
    }
    return {
      errors: errors
    };
  } else {
    data.errors = [];
    return data;
  }
};

$error.delegate('li', 'click', function () {
  var errors = JSHINT.data(true).errors;
  if (errors.length) {
    var i = $error.find('li').index(this);
    if (errors[i].reason) {
      editors.javascript.editor.setSelection({ line: errors[i].line - 1, ch: 0 }, { line: errors[i].line - 1 });
      editors.javascript.editor.focus();
    }
    // var line = editors.javascript.nthLine(errors[0].line);
    // editors.javascript.jumpToLine(line);
    // editors.javascript.selectLines(line, 0, editors.javascript.nthLine(errors[0].line + 1), 0);
    return false;
  }
});

var checkForErrors = function () {
  // exit if the javascript panel isn't visible or jshint is disabled (for example by the user or when using a js preprocessor)
  if (!editors.javascript.visible || !jshintEnabled) return;

  var hint = jshint(),
      jshintErrors = JSHINT.data(true),
      errors = '',
      visible = $error.is(':visible');

  if (hint === true && visible) {
    $error.hide();
    $document.trigger('sizeeditors');
  } else if (jshintErrors.errors.length) {
    var html = ['<ol>'];
    errors = jshintErrors.errors;
    for (var i = 0; i < errors.length; i++) {
      if (typeof errors[i] === 'string') {
        html.push(escapeHTML(errors[i]));
      } else {
        html.push('Line ' + errors[i].line + ': ' + escapeHTML(errors[i].evidence) + ' --- ' + escapeHTML(errors[i].reason));
      }
    }

    html = html.join('<li>') + '</ol>';

    $error.find('.summary').text(jshintErrors.errors.length === 1 ? '1 warning' : jshintErrors.errors.length + ' warnings');
    $error.find('ol').remove();

    if (!detailsSupport && $error[0].open === false) html = $(html).hide();

    $error.append(html).show();
    $document.trigger('sizeeditors');
  }
};

if (jsbin.settings.jshint === true || jsbin.settings.jshint === undefined) {
  $(document).bind('codeChange', throttle(checkForErrors, 1000));
  $(document).bind('jsbinReady', checkForErrors);
}

// })();
;var processors = jsbin.processors = (function () {
  /*
   * Debugging note: to emulate a slow connection, or a processor taking too
   * long to load, find the processor in question, and change the `init` method
   * to setTimeout(getScript, n seconds) - this will give you an idea of how
   * jsbin behaves when the processor isn't ready and the user makes calls to it
   */


  /**
   * Add properties to a function using underscore
   */
  var extendFn = function (fn, obj) {
    return _.extend(fn, obj);
  };

  var passthrough = function (ready) { return ready(); };
  var defaultProcessor = function (source) {
    return source;
  };

  /**
   * Cache extension ids by their file extensions
   */
  var processorBy = {
    extension: {}
  };

  /**
   * Create a processor â€“ accepts an object containing:
   *
   *    id          Processor name. Required.
   *    target      The target panel. Optional - defaults to the id.
   *    extensions  Possible file extensions for this processor (for gist i/o).
   *                Optional. Defaults to the id.
   *    url         URL of the loader script file. Optional.
   *    init        Setup the processor here. Optional â€“ defaults to the
   *                passthrough (above).
   *    handler     Where the magic happens. Do all processing in here.
   *                Optional - defaults to the defaultProcessor (above).
   */
  var createProcessor = function (opts) {
    var url = opts.url,
        init = opts.init || passthrough,
        handler = opts.handler || defaultProcessor,
        processorData = _.pick(opts, 'id', 'target', 'extensions');

    opts.extensions = opts.extensions || [];
    if (!opts.extensions.length) opts.extensions = [opts.id];

    opts.extensions.forEach(function (ext) {
      processorBy.extension[ext] = opts.id;
    });

    // This actually loads in the processor â€“ script files & init code
    var loadProcessor = function (ready) {

      var failed = false;

      // Overwritten when the script loads
      var callback = function () {
        window.console && window.console.warn('Processor is not ready yet - trying again');
        failed = true;
        return '';
      };

      // Script has loaded.
      // Run any init code, and swap the callback. If we failed, try again.
      var scriptCB = function () {
        init(function () {
          callback = handler;
          if (failed) {
            renderLivePreview();
          }
          ready();
        });
      };

      if (url) {
        // Load the processor's script
        $.getScript(url, scriptCB);
      } else {
        // No url, go straight on
        init(function () {
          callback = handler;
          ready();
        });
      }

      // Create a proxy function that holds the handler in scope so that, when
      // the callbacks are swapped, rendering still works.
      var proxyCallback = function () {
        return callback.apply(this, arguments);
      };

      // Return the method that will be used to render
      return extendFn(proxyCallback, processorData);;
    };

    // Processor fucntion also has the important data on it
    return extendFn(loadProcessor, processorData);
  };

  /**
   * JS Bin's processors
   */
  var processors = {

    html: createProcessor({
      id: 'html'
    }),

    css: createProcessor({
      id: 'css'
    }),

    javascript: createProcessor({
      id: 'javascript',
      extensions: ['js']
    }),

    coffeescript: createProcessor({
      id: 'coffeescript',
      target: 'javascript',
      extensions: ['coffee'],
      url: jsbin.static + '/js/vendor/coffee-script.js',
      init: function (ready) {
        $.getScript(jsbin.static + '/js/vendor/codemirror3/mode/coffeescript/coffeescript.js', ready);
      },
      handler: function (source) {
        var renderedCode = '';
        try {
          renderedCode = CoffeeScript.compile(source, {
            bare: true
          });
        } catch (e) {
          throw new Error(e);
        }
        return renderedCode;
      }
    }),

    typescript: createProcessor({
      id: 'typescript',
      target: 'javascript',
      extensions: ['ts'],
      url: jsbin.static + '/js/vendor/typescript.min.js',
      init: passthrough,
      handler: function (source) {
        var noop = function () {};
        var outfile = {
          source: "",
          Write: function (s) {
            this.source += s;
          },
          WriteLine: function (s) {
            this.source += s + "\n";
          },
          Close: noop
        };

        var outerr = {
          Write: noop,
          WriteLine: noop,
          Close: noop
        };

        var parseErrors = [];

        var compiler = new TypeScript.TypeScriptCompiler(outfile, outerr);

        compiler.setErrorCallback(function (start, len, message) {
          parseErrors.push({ start: start, len: len, message: message });
        });
        compiler.parser.errorRecovery = true;

        compiler.addUnit(source, 'jsbin.ts');
        compiler.typeCheck();
        compiler.reTypeCheck();
        compiler.emit();

        for (var i = 0, len = parseErrors.length; i < len; i++) {
          console.log('Error Message: ' + parseErrors[i].message);
          console.log('Error Start: ' + parseErrors[i].start);
          console.log('Error Length: ' + parseErrors[i].len);
        }

        return outfile.source;
      }
    }),

    markdown: createProcessor({
      id: 'markdown',
      target: 'html',
      extensions: ['md', 'markdown', 'mdown'],
      url: jsbin.static + '/js/vendor/markdown.js',
      init: function (ready) {
        $.getScript(jsbin.static + '/js/vendor/codemirror3/mode/markdown/markdown.js', ready);
      },
      handler: function (source) {
        return markdown.toHTML(source);
      }
    }),

    processing: createProcessor({
      id: 'processing',
      target: 'javascript',
      extensions: ['pde'],
      url: jsbin.static + '/js/vendor/processing.min.js',
      init: function (ready) {
        $('#library').val( $('#library').find(':contains("Processing")').val() ).trigger('change');
        // init and expose jade
        $.getScript(jsbin.static + '/js/vendor/codemirror3/mode/clike/clike.js', ready);
      },
      handler: function (source) {
        source = [
          '(function(){',
          '  var canvas = document.querySelector("canvas");',
          '  if (!canvas) {',
          '    canvas = document.createElement("canvas");',
          '    (document.body || document.documentElement).appendChild(canvas);',
          '  }',
          '  canvas.width = window.innerWidth;',
          '  canvas.height = window.innerHeight;',
          '  var sketchProc = ' + Processing.compile(source).sourceCode + ';',
          '  var p = new Processing(canvas, sketchProc);',
          '})();'
        ].join('\n');

        return source;
      }
    }),

    jade: createProcessor({
      id: 'jade',
      target: 'html',
      extensions: ['jade'],
      url: jsbin.static + '/js/vendor/jade.js',
      init: function (ready) {
        // init and expose jade
        window.jade = require('jade');
        ready();
      },
      handler: function (source) {
        return jade.compile(source, { pretty: true })();
      }
    }),

    less: createProcessor({
      id: 'less',
      target: 'css',
      extensions: ['less'],
      url: jsbin.static + '/js/vendor/less-1.4.2.min.js',
      init: function (ready) {
        $.getScript(jsbin.static + '/js/vendor/codemirror3/mode/less/less.js', ready);
      },
      handler: function (source) {
        var css = '';

        less.Parser().parse(source, function (err, result) {
          if (err) {
            throw new Error(err);
          }
          css = $.trim(result.toCSS());
        });
        return css;
      }
    }),

    stylus: createProcessor({
      id: 'stylus',
      target: 'css',
      extensions: ['styl'],
      url: jsbin.static + '/js/vendor/stylus.js',
      init: passthrough,
      handler: function (source) {
        var css = '';

        stylus(source).render(function (err, result) {
          if (err) {
            throw new Error(err);
            return;
          }
          css = $.trim(result);
        });
        return css;
      }
    }),

    traceur: (function () {
      var SourceMapConsumer,
          SourceMapGenerator,
          ProjectWriter,
          ErrorReporter,
          hasError;
      return createProcessor({
        id: 'traceur',
        target: 'javascript',
        extensions: ['traceur'],
        url: jsbin.static + '/js/vendor/traceur.js',
        init: function (ready) {
          // Only create these once, when the processor is loaded
          $('#library').val( $('#library').find(':contains("Traceur")').val() ).trigger('change');
          SourceMapConsumer = traceur.outputgeneration.SourceMapConsumer;
          SourceMapGenerator = traceur.outputgeneration.SourceMapGenerator;
          ProjectWriter = traceur.outputgeneration.ProjectWriter;
          ErrorReporter = traceur.util.ErrorReporter;
          ready();
        },
        handler: function (source) {
          hasError = false;

          var reporter = new ErrorReporter();
          reporter.reportMessageInternal = function(location, kind, format, args) {
            throw new Error(ErrorReporter.format(location, format, args));
          };

          var url = location.href;
          var project = new traceur.semantics.symbols.Project(url);
          var name = 'jsbin';

          var sourceFile = new traceur.syntax.SourceFile(name, source);
          project.addFile(sourceFile);
          var res = traceur.codegeneration.Compiler.compile(reporter, project, false);

          var msg = '/*\nIf you\'ve just translated to JS, make sure traceur is in the HTML panel.\nThis is terrible, sorry, but the only way we could get around race conditions.\n\nHugs & kisses,\nDave xox\n*/\ntry{window.traceur = top.traceur;}catch(e){}\n';
          return msg + ProjectWriter.write(res);
        }
      });
    }())

  };

  var render = function() {
    if (jsbin.panels.ready) {
      editors.console.render();
    }
  };

  var $processorSelectors = $('div.processorSelector').each(function () {
    var panelId = this.getAttribute('data-type'),
        $el = $(this),
        $label = $el.closest('.label').find('strong a'),
        originalLabel = $label.text();

    $el.find('a').click(function (e) {
      var panel = jsbin.panels.panels[panelId];

      e.preventDefault();
      var target = this.hash.substring(1),
          label = $(this).text(),
          code;
      if (target !== 'convert') {
        $label.text(label);
        if (target === panelId) {
          jsbin.processors.reset(panelId);
          render();
        } else {
          jsbin.processors.set(panelId, target, render);
        }
      } else {
        $label.text(originalLabel);
        panel.setCode(panel.render());
        jsbin.processors.reset(panelId);
      }
    }).bind('select', function (event, value) {
      if (value === this.hash.substring(1)) {
        $label.text($(this).text());
      }
    });
  });

  processors.set = function (panelId, processorName, callback) {
    var panel;

    // panelId can be id or instance of a panel.
    // this is kinda nasty, but it allows me to set panel processors during boot
    if (panelId instanceof Panel) {
      panel = panelId;
      panelId = panel.id;
    } else {
      panel = jsbin.panels.panels[panelId];
    }

    if (!jsbin.state.processors) {
      jsbin.state.processors = {};
    }

    var cmMode = processorName ? editorModes[processorName] || editorModes[panelId] : editorModes[panelId];

    if (!panel) return;

    panel.trigger('processor', processorName || 'none');
    if (processorName && processors[processorName]) {
      jsbin.state.processors[panelId] = processorName;
      panel.processor = processors[processorName](function () {
        // processor is ready
        panel.editor.setOption('mode', cmMode);
        $processorSelectors.find('a').trigger('select', [processorName]);
        if (callback) callback();
      });
    } else {
      // remove the preprocessor
      panel.editor.setOption('mode', cmMode);

      panel.processor = defaultProcessor;
      delete jsbin.state.processors[panelId];
      delete panel.type;
    }
  };

  processors.reset = function (panelId) {
    processors.set(panelId);
  };

  /**
   * Find the processor that uses the given file extension
   */
  processors.findByExtension = function (ext) {
    var id = processorBy.extension[ext];
    if (!id) return defaultProcessor;
    return jsbin.processors[id];
  };

  processors.by = processorBy;

  return processors;

}());;var $document = $(document),
    $source = $('#source');

var editorModes = {
  html: 'htmlmixed',
  javascript: 'javascript',
  css: 'css',
  typescript: 'javascript',
  markdown: 'markdown',
  coffeescript: 'coffeescript',
  less: 'less',
  processing: 'text/x-csrc'
};

var badChars = new RegExp('[\u200B\u0080-\u00a0]', 'g');

if (jsbin.settings.editor.tabMode === 'default') {
  CodeMirror.keyMap.basic.Tab = undefined;
} else if (jsbin.settings.editor.tabMode !== 'classic') {
  CodeMirror.keyMap.basic.Tab = 'indentMore';
}

if (!CodeMirror.commands) {
  CodeMirror.commands = {};
}

CodeMirror.commands.autocomplete = function(cm) {
  return CodeMirror.simpleHint(cm, CodeMirror.javascriptHint);
};

var foldFunc = {
  css: CodeMirror.newFoldFunction(CodeMirror.braceRangeFinder),
  javascript: CodeMirror.newFoldFunction(CodeMirror.braceRangeFinder),
  html: CodeMirror.newFoldFunction(CodeMirror.tagRangeFinder)
};

// this is a bit of a fudge to get multiline commenting working
// for JavaScript. It's a fudge because emmet doesn't support
// JavaScript as a language at all, so we inherit code our own comment style.
var vocab = emmet.require('resources').getVocabulary('system');
vocab.javascript = 'javascript';
emmet.require('resources').setVocabulary(vocab, 'system');

// totally over the top - but cleanest way to add comments to JavaScript
var emmetToggleComment = emmet.require('actions').get('toggle_comment');
emmet.require('actions').add('toggle_comment', function(editor) {
  var info = emmet.require('editorUtils').outputInfo(editor);
  if (info.syntax == 'javascript') {
    // in case our editor is good enough and can recognize syntax from
    // current token, we have to make sure that cursor is not inside
    // 'style' attribute of html element
    var editorUtils = emmet.require('editorUtils');
    var selection = editor.getSelection();
    var range = editor.getCurrentLineRange();
    var line = editor.getCurrentLine();
    var caretPos = editor.getCaretPos();
    var tag = emmet.require('htmlMatcher').tag(info.content, caretPos);
    if ((selection.length) || (tag && tag.open.range.inside(caretPos))) {
      return emmetToggleComment.fn(editor);
    } else {
      if (line.trim().indexOf('//') == 0) {
        editor.setCaretPos(caretPos);
        editor.replaceContent(editorUtils.unindent(editor, line.replace(/(\s*?)\/\/\s?/, '$1')), range.start, range.end, false);
        editor.setCaretPos(caretPos - 3);
      } else {
        editor.setCaretPos(caretPos);
        editor.replaceContent(editorUtils.unindent(editor, '// ' + line), range.start, range.end, false);
        editor.setCaretPos(caretPos + 3);
      }
    }
  } else {
    return emmetToggleComment.fn(editor);
  }
});



var Panel = function (name, settings) {
  var panel = this,
      showPanelButton = true,
      $panel = null,
      splitterSettings = {},
      cmSettings = {},
      panelLanguage = name;

  panel.settings = settings = settings || {};
  panel.id = panel.name = name;
  $panel = $('.panel.' + name);
  $panel.data('name', name);
  panel.$el = $panel.detach();
  panel.$el.appendTo($source);
  panel.$el.wrapAll('<div class="stretch panelwrapper">');
  panel.$panel = panel.$el;
  panel.$el = panel.$el.parent().hide();
  panel.el = document.getElementById(name);
  panel.order = ++Panel.order;

  panel.$el.data('panel', panel);

  this._eventHandlers = {};

  // keyboard shortcut (set in keyboardcontrol.js)
  panelShortcuts[panelShortcuts.start + panel.order] = panel.id;

  if (panel.order === 1) {
    settings.nosplitter = true;
  }

  // this is nasty and wrong, but I'm going to put here anyway .i..
  if (this.id === 'javascript') {
    this.on('processor', function (e, preprocessor) {
      if (preprocessor === 'none') {
        jshintEnabled = true;
        checkForErrors();
      } else {
        jshintEnabled = false;
        $error.hide();
      }
    });
  }

  if (jsbin.state.processors && jsbin.state.processors[name]) {
    panelLanguage = jsbin.state.processors[name];
    jsbin.processors.set(panel, jsbin.state.processors[name]);
  } else if (settings.processor) { // FIXME is this even used?
    panelLanguage = settings.processors[settings.processor];
    jsbin.processors.set(panel, settings.processor);
  } else {
    panel.processor = function (str) { return str; };
  }

  if (settings.editor) {
    cmSettings = {
      parserfile: [],
      readOnly: jsbin.state.embed ? 'nocursor' : false,
      dragDrop: false, // we handle it ourselves
      mode: editorModes[panelLanguage],
      lineWrapping: true,
      styleActiveLine: true,
      highlightSelectionMatches: true,
      theme: jsbin.settings.theme || 'jsbin'
    };

    $.extend(cmSettings, jsbin.settings.editor || {});

    cmSettings.extraKeys = {};

    cmSettings.extraKeys['Ctrl-Q'] = function (cm) {
      foldFunc[name](cm, cm.getCursor().line);
    };

    // only the js panel for now, I'd like this to work in
    // the HTML panel too, but only when you were in JS scope
    if (name === 'javascript') {
      cmSettings.extraKeys.Tab = 'autocomplete';
    }

    // cmSettings.extraKeys.Tab = 'snippets';

    // Add Zen Coding to html pane
    // if (name === 'html') {
      $.extend(cmSettings, {
        syntax: name,   /* define Zen Coding syntax */
        profile: name   /* define Zen Coding output profile */
      });
    // }

    panel.editor = CodeMirror.fromTextArea(panel.el, cmSettings);

    // Bind events using CM3 syntax
    panel.editor.on('change', function (event) {
      $document.trigger('codeChange', [{ panelId: panel.id, revert: true }]);
      return true;
    });

    panel.editor.on('gutterClick', foldFunc[name]);

    panel.editor.on('focus', function () {
      panel.focus();
    });

    panel._setupEditor(panel.editor, name);
  }

  if (!settings.nosplitter) {
    panel.splitter = panel.$el.splitter(splitterSettings).data('splitter');
    panel.splitter.hide();
  } else {
    // create a fake splitter to let the rest of the code work
    panel.splitter = $();
  }

  if (settings.beforeRender) {
    $document.bind('render', $.proxy(settings.beforeRender, panel));
  }

  if (!settings.editor) {
    panel.ready = true;
  }

  // append panel to controls
  if (jsbin.state.embed) {
    // showPanelButton = window.location.search.indexOf(panel.id) !== -1;
  }

  if (showPanelButton) {
    this.controlButton = $('<a class="button group" href="?' + name + '">' + (settings.label || name) + '</a>');
    this.controlButton.click(function () {
      panel.toggle();
      return false;
    });
    this.controlButton.appendTo('#panels');
  }

  $panel.focus(function () {
    panel.focus();
  });
  $panel.add(this.$el.find('.label')).click(function () {
    panel.focus();
  });
};

Panel.order = 0;

Panel.prototype = {
  virgin: true,
  visible: false,
  show: function (x) {
    $document.trigger('history:close');
    // check to see if there's a panel to the left.
    // if there is, take it's size/2 and make this our
    // width
    var panel = this,
        panelCount = panel.$el.find('.panel').length;

    analytics.showPanel(panel.id);

    // panel.$el.show();
    if (panel.splitter.length) {
      if (panelCount === 0 || panelCount > 1) {
        var $panel = $('.panel.' + panel.id).show();
        // $panel.next().show(); // should be the splitter...
        $panel.closest('.panelwrapper').show();
      } else {
        panel.$el.show();
      }
      panel.splitter.show();
    } else {
      panel.$el.show();
    }

    $body.addClass('panelsVisible');

    if (panel.settings.show) {
      panel.settings.show.call(panel, true);
    }
    panel.controlButton.addClass('active');
    panel.visible = true;

    // update the splitter - but do it on the next tick
    // required to allow the splitter to see it's visible first
    setTimeout(function () {
      if (x !== undefined) {
        panel.splitter.trigger('init', x);
      } else {
        panel.distribute();
      }
      if (panel.editor) {
        // populate the panel for the first time
        if (panel.virgin) {
          var top = panel.$el.find('.label').outerHeight();
          top += 8;
          $(panel.editor.win).find('.CodeMirror-scroll .CodeMirror-lines').css('padding-top', top);

          populateEditor(panel, panel.name);
        }
        if (!panel.virgin || jsbin.panels.ready) {
          panel.editor.focus();
          panel.focus();
        }
        if (panel.virgin) {
          if (panel.settings.init) {
            setTimeout(function () {
              panel.settings.init.call(panel);
            }, 10);
          }
        }
      } else {
        panel.focus();
      }
      // update all splitter positions
      $document.trigger('sizeeditors');

      panel.trigger('show');

      panel.virgin = false;
  }, 0);

    // TODO save which panels are visible in their profile - but check whether it's their code
  },
  hide: function () {
    var panel = this;
    // panel.$el.hide();
    panel.visible = false;
    analytics.hidePanel(panel.id);

    // update all splitter positions
    // LOGIC: when you go to hide, you need to check if there's
    // other panels inside the panel wrapper - if there are
    // hide the nested panel and any previous visible splitter
    // if there's only one - then hide the whole thing.
    // if (panel.splitter.length) {
    var panelCount = panel.$el.find('.panel').length;
    if (panelCount === 0 || panelCount > 1) {
      var $panel = $('.panel.' + panel.id).hide();
      $panel.prev().hide(); // hide the splitter if there is one

      // TODO trigger a distribute horizontally
      if ($panel.closest('.panelwrapper').find('.panel:visible').length === 0) {
        $panel.closest('.panelwrapper').hide();
        // panel.splitter.hide();
        // TODO FIXME
      }
    } else {
      panel.$el.hide();
      panel.splitter.hide();
    }
    // } else {
    //   panel.$el.hide();
    // }
    if (panel.editor) {
      panel.controlButton.toggleClass('hasContent', !!$.trim(this.getCode()).length);
    }

    panel.controlButton.removeClass('active');
    panel.distribute();

    if (panel.settings.hide) {
      panel.settings.hide.call(panel, true);
    }

    // this.controlButton.show();
    // setTimeout(function () {
    var visible = jsbin.panels.getVisible();
    if (visible.length) {
      jsbin.panels.focused = visible[0];
      if (jsbin.panels.focused.editor) {
        jsbin.panels.focused.editor.focus();
      } else {
        jsbin.panels.focused.$el.focus();
      }
      jsbin.panels.focused.focus();
    }

    $document.trigger('sizeeditors');
    panel.trigger('hide');

    // note: the history:open does first check whether there's an open panels
    // and if there are, it won't show the history, it'll just ignore the event
    $document.trigger('history:open');
  },
  toggle: function () {
    (this)[this.visible ? 'hide' : 'show']();
  },
  getCode: function () {
    if (this.editor) {
      badChars.lastIndex = 0;
      return this.editor.getCode().replace(badChars, '');
    }
  },
  setCode: function (content) {
    if (this.editor) {
      if (content === undefined) content = '';
      this.controlButton.toggleClass('hasContent', !!content.trim().length);
      this.codeSet = true;
      this.editor.setCode(content.replace(badChars, ''));
    }
  },
  codeSet: false,
  blur: function () {
    this.$panel.addClass('blur');
  },
  focus: function () {
    this.$panel.removeClass('blur');
    jsbin.panels.focus(this);
  },
  render: function () {
    var panel = this,
        ret = null;
    if (panel.editor) {
      return panel.processor(panel.getCode());
    } else if (this.visible && this.settings.render) {
      if (jsbin.panels.ready) {
        this.settings.render.apply(this, arguments);
      }
    }
  },
  init: function () {
    if (this.settings.init) this.settings.init.call(this);
  },
  _setupEditor: function () {
    var focusedPanel = sessionStorage.getItem('panel'),
        panel = this,
        editor = panel.editor;

    // overhang from CodeMirror1
    editor.setCode = function (str) {
      //Cannot call method 'chunkSize' of undefined
      try {
        editor.setValue(str);
      } catch(err) {
        // console.error(panel.id, err);
      }
    };


    editor.getCode = function () {
      return editor.getValue();
    };

    editor.currentLine = function () {
      var pos = editor.getCursor();
      return pos.line;
    };

    // editor.setOption('onKeyEvent', keycontrol);
    // editor.setOption('onFocus', function () {
      // panel.$el.trigger('focus');
    // });

    // This prevents the browser from jumping
    if (jsbin.mobile || jsbin.tablet || jsbin.embed) {
      editor._focus = editor.focus;
      editor.focus = function () {
        // console.log('ignoring manual call');
      };
    }

    editor.id = panel.name;

    editor.win = editor.getWrapperElement();
    editor.scroller = $(editor.getScrollerElement());

    var $label = panel.$el.find('.label');
    if (document.body.className.indexOf('ie6') === -1 && $label.length) {
      editor.on('scroll', function (event) {
        var scrollInfo = editor.getScrollInfo();
        if (scrollInfo.top > 10) {
          $label.stop().animate({ opacity: 0 }, 20, function () {
            $(this).hide();
          });
        } else {
          $label.show().stop().animate({ opacity: 1 }, 150);
        }
      });
    }

    var $error = null;
    $document.bind('sizeeditors', function () {
      if (panel.visible) {
        var height = panel.editor.scroller.closest('.panel').outerHeight(),
            offset = 0;
            // offset = panel.$el.find('> .label').outerHeight();

        // special case for the javascript panel
        if (panel.name === 'javascript') {
          if ($error === null) { // it wasn't there right away, so we populate
            $error = panel.$el.find('details');
          }
          offset += ($error.filter(':visible').height() || 0);
        }

        if (!jsbin.lameEditor) {
          editor.scroller.height(height - offset);
        }
        try { editor.refresh(); } catch (e) {}
      }
    });

    // required because the populate looks at the height, and at
    // this point in the code, the editor isn't visible, the browser
    // needs one more tick and it'll be there.
    setTimeout(function () {
      // if the panel isn't visible this only has the effect of putting
      // the code in the textarea (though probably costs us a lot more)
      // it has to be re-populated upon show for the first time because
      // it appears that CM2 uses the visible height to work out what
      // should be shown.
      panel.ready = true;
      populateEditor(panel, panel.name);

      if (focusedPanel == panel.name) {
        // another fracking timeout to avoid conflict with other panels firing up
        setTimeout(function () {
          panel.focus();
          if (panel.visible && !jsbin.mobile && !jsbin.tablet) {
            editor.focus();

            var code = editor.getCode().split('\n'),
                blank = null,
                i = 0;

            for (; i < code.length; i++) {
              if (blank === null && code[i].trim() === '') {
                blank = i;
                break;
              }
            }

            editor.setCursor({ line: (sessionStorage.getItem('line') || blank || 0) * 1, ch: (sessionStorage.getItem('character') || 0) * 1 });
          }
        }, 110); // This is totally arbitrary
      }
    }, 0);
  },
  populateEditor: function () {
    populateEditor(this, this.name);
  },

  // events
  on: function (event, fn) {
    (this._eventHandlers[event] = this._eventHandlers[event] || []).push(fn);
    return this;
  },

  trigger: function (event) {
    var args = [].slice.call(arguments, 1);
    args.unshift({ type: event });
    for (var list = this._eventHandlers[event], i = 0; list && list[i];) {
      list[i++].apply(this, args);
    }
    return this;
  }
};

function populateEditor(editor, panel) {
  if (!editor.codeSet) {
    // populate - should eventually use: session, saved data, local storage
    var cached = sessionStorage.getItem('jsbin.content.' + panel), // session code
        saved = localStorage.getItem('saved-' + panel), // user template
        sessionURL = sessionStorage.getItem('url'),
        changed = false;

    // if we clone the bin, there will be a checksum on the state object
    // which means we happily have write access to the bin
    if (sessionURL !== template.url && !jsbin.state.checksum) {
      // nuke the live saving checksum
      sessionStorage.removeItem('checksum');
      saveChecksum = false;
    }

    if (template && cached == template[panel]) { // restored from original saved
      editor.setCode(cached);
    } else if (cached && sessionURL == template.url) { // try to restore the session first - only if it matches this url
      editor.setCode(cached);
      // tell the document that it's currently being edited, but check that it doesn't match the saved template
      // because sessionStorage gets set on a reload
      changed = cached != saved && cached != template[panel];
    } else if (saved !== null && !/edit/.test(window.location) && !window.location.search) { // then their saved preference
      editor.setCode(saved);
    } else { // otherwise fall back on the JS Bin default
      editor.setCode(template[panel]);
    }
  } else {
    // this means it was set via the url
    changed = true;
  }

  if (changed) {
    $document.trigger('codeChange', [ { revert: false, onload: true } ]);
  }
}
;var panels = {};

panels.getVisible = function () {
  var panels = this.panels,
      visible = [];
  for (var panel in panels) {
    if (panels[panel].visible) visible.push(panels[panel]);
  }
  return visible;
};

panels.save = function () {
  // don't save panel state if we're in embed mode
  if (jsbin.embed) {
    return;
  }

  var visible = this.getVisible(),
      state = {},
      panel,
      left = '',
      width = $window.width();

  for (var i = 0; i < visible.length; i++) {
    panel = visible[i];
    left = panel.$el.css('left');
    if (left.indexOf('%') === -1) {
      // convert the pixel to relative - this is because jQuery pulls
      // % for Webkit based, but px for Firefox & Opera. Cover our bases
      left = (parseFloat(left)  / width * 100) + '%';
    }
    state[panel.name] = left;
  }

  sessionStorage.setItem('jsbin.panels', JSON.stringify(state));
}

panels.restore = function () {
  // if there are panel names on the hash (v2 of jsbin) or in the query (v3)
  // then restore those specific panels and evenly distribute them.
  var open = [],
      location = window.location,
      search = location.search.substring(1),
      hash = location.hash.substring(1),
      toopen = [],
      state = jsbin.embed ? null : JSON.parse(sessionStorage.getItem('jsbin.panels') || 'null'),
      hasContent = {
        javascript: editors.javascript.getCode().length,
        css: editors.css.getCode().length,
        html: editors.html.getCode().length
      },
      name = '',
      i = 0,
      panel = null,
      init = [],
      panelURLValue = '',
      openWithSameDimensions = false,
      width = $window.width(),
      deferredCodeInsert = '',
      focused = !!sessionStorage.getItem('panel'),
      validPanels = 'live javascript html css console'.split(' ');

  if (history.replaceState && (location.pathname.indexOf('/edit') !== -1) || ((location.origin + location.pathname) === jsbin.getURL() + '/')) {
    history.replaceState(null, '', jsbin.getURL() + (jsbin.getURL() === jsbin.root ? '' : '/edit'));
  }

  if (search || hash) {
    // RS July 23, 2013 - I'm not mad on this change and
    // would welcome a refactor to all the editor.js code
    // because it's damn hard to navigate and work out
    // what's happening.
    // This change is mostly to create consistency between
    // the panel name of 'output' and the shortcut 'live'.
    // it also strips out prop=value& to avoid bashing the
    // panel name
    toopen = (search || hash).replace(/\b([^&=]*)=([^&=]*)/g, '').replace(/&/g, '').split(',');

    if (toopen.indexOf('output') !== -1) {
      toopen.push('live');
    }
    if (toopen.indexOf('js') !== -1) {
      toopen.push('javascript');
    }
  }

  // strip out anything that wasn't recognised as a valid panel to open
  for (i = 0; i < toopen.length; i++) {
    if (validPanels.indexOf(toopen[i]) === -1) {
      toopen.splice(i, 1);
      i--;
    }
  }

  if (toopen.length === 0) {
    toopen = jsbin.settings.panels || [];
  }

  if (toopen.length === 0 && state === null) {
    if (hasContent.javascript) toopen.push('javascript');
    if (hasContent.html) toopen.push('html');
    if (hasContent.css) toopen.push('css');
    toopen.push('live');
  }

  // otherwise restore the user's regular settings
  // also set a flag indicating whether or not we should save the panel settings
  // this is based on whether they're on jsbin.com or if they're on an existing
  // bin. Also, if they hit save - *always* save their layout.
  if (location.pathname && location.pathname !== '/') {
    panels.saveOnExit = false;
  } else {
    panels.saveOnExit = true;
  }

  // TODO decide whether the above code I'm trying too hard.

  /* Boot code */
  // then allow them to view specific panels based on comma separated hash fragment/query
  i = 0;
  if (toopen.length) {
    for (name in state) {
      if (toopen.indexOf(name) !== -1) {
        i++;
      }
    }

    if (i === toopen.length) openWithSameDimensions = true;

    for (i = 0; i < toopen.length; i++) {
      panelURLValue = '';
      name = toopen[i];

      // if name contains an `=` it means we also need to set that particular panel to that code
      if (name.indexOf('=') !== -1) {
        panelURLValue = name.substring(name.indexOf('=') + 1);
        name = name.substring(0, name.indexOf('='));
      }

      if (panels.panels[name]) {
        panel = panels.panels[name];
        // console.log(name, 'width', state[name], width * parseFloat(state[name]) / 100);
        if (panel.editor && panelURLValue) {
          panel.setCode(decodeURIComponent(panelURLValue));
        }

        if (openWithSameDimensions && toopen.length > 1) {
          panel.show(width * parseFloat(state[name]) / 100);
        } else {
          panel.show();
        }
        init.push(panel);
      } else if (name && panelURLValue) { // TODO support any varible insertion
        (function (name, panelURLValue) {
          var todo = ['html', 'javascript', 'css'];

          var deferredInsert = function (event, data) {
            var code, parts, panel = panels.panels[data.panelId] || {};

            if (data.panelId && panel.editor && panel.ready === true) {
              todo.splice(todo.indexOf(data.panelId), 1);
              try {
                code = panel.getCode();
              } catch (e) {
                // this really shouldn't happen
                // console.error(e);
              }
              if (code.indexOf('%' + name + '%') !== -1) {
                parts = code.split('%' + name + '%');
                code = parts[0] + decodeURIComponent(panelURLValue) + parts[1];
                panel.setCode(code);
                $document.unbind('codeChange', deferredInsert);
              }
            }

            if (todo.length === 0) {
              $document.unbind('codeChange', deferredInsert);
            }
          };

          $document.bind('codeChange', deferredInsert);
        }(name, panelURLValue));
      }
    }

    // support the old jsbin v1 links directly to the preview
    if (toopen.length === 1 && toopen[0] === 'preview') {
      panels.panels.live.show();
    }

    if (!openWithSameDimensions) this.distribute();
  } else {
    for (name in state) {
      panels.panels[name].show(width * parseFloat(state[name]) / 100);
    }
  }

  // now restore any data from sessionStorage
  // TODO add default templates somewhere
  // var template = {};
  // for (name in this.panels) {
  //   panel = this.panels[name];
  //   if (panel.editor) {
  //     // panel.setCode(sessionStorage.getItem('jsbin.content.' + name) || template[name]);
  //   }
  // }

  for (i = 0; i < init.length; i++) {
    init[i].init();
  }

  var visible = panels.getVisible();
  if (visible.length) {
    $body.addClass('panelsVisible');
    if (!focused) {
      visible[0].show();
    }
  }

};

panels.savecontent = function () {
  // loop through each panel saving it's content to sessionStorage
  var name, panel;
  for (name in this.panels) {
    panel = this.panels[name];
    if (panel.editor) sessionStorage.setItem('jsbin.content.' + name, panel.getCode());
  }
};

panels.focus = function (panel) {
  this.focused = panel;
  if (panel) {
    $('.panel').removeClass('focus').filter('.' + panel.id).addClass('focus');
  }
}

// evenly distribute the width of all the visible panels
panels.distribute = function () {
  var visible = $('#source .panelwrapper:visible'),
      width = 100,
      height = 0,
      innerW = $window.width() - (visible.length - 1), // to compensate for border-left
      innerH = $('#source').outerHeight(),
      left = 0,
      right = 0,
      top = 0,
      panel,
      nestedPanels = [];

  if (visible.length) {
    $body.addClass('panelsVisible');

    // visible = visible.sort(function (a, b) {
    //   return a.order < b.order ? -1 : 1;
    // });

    width = 100 / visible.length;
    for (var i = 0; i < visible.length; i++) {
      panel = $.data(visible[i], 'panel');
      right = 100 - (width * (i+1));
      panel.$el.css({ top: 0, bottom: 0, left: left + '%', right: right + '%' });
      panel.splitter.trigger('init', innerW * left/100);
      panel.splitter[i == 0 ? 'hide' : 'show']();
      left += width;

      nestedPanels = $(visible[i]).find('.panel');
      if (nestedPanels.length > 1) {
        top = 0;
        nestedPanels = nestedPanels.filter(':visible');
        height = 100 / nestedPanels.length;
        nestedPanels.each(function (i) {
          bottom = 100 - (height * (i+1));
          var panel = jsbin.panels.panels[$.data(this, 'name')];
          // $(this).css({ top: top + '%', bottom: bottom + '%' });
          $(this).css('top', top + '%');
          $(this).css('bottom', bottom + '%' );
          if (panel.splitter.hasClass('vertical')) {
            panel.splitter.trigger('init', innerH * top/100);
            panel.splitter[i == 0 ? 'hide' : 'show']();
          }
          top += height;
        });
      }
    }
  } else {
    $('#history').show();
    setTimeout(function () {
      $body.removeClass('panelsVisible');
    }, 100); // 100 is on purpose to add to the effect of the reveal
  }
};

panels.show = function (panelId) {
  this.panels[panelId].show();
  if (this.panels[panelId].editor) {
    this.panels[panelId].editor.focus();
  }
  this.panels[panelId].focus();
};

panels.hide = function (panelId) {
  var $history = $('#history'); // TODO shouldn't have to keep hitting this
  var panels = this.panels;
  if (panels[panelId].visible) {
    panels[panelId].hide();
  }

  var visible = jsbin.panels.getVisible();
  if (visible.length) {
    jsbin.panels.focused = visible[0];
    if (jsbin.panels.focused.editor) {
      jsbin.panels.focused.editor.focus();
    } else {
      jsbin.panels.focused.$el.focus();
    }
    jsbin.panels.focused.focus();
  }

  /*
  } else if ($history.length && !$body.hasClass('panelsVisible')) {
    $body.toggleClass('dave', $history.is(':visible'));
    $history.toggle(100);
  } else if ($history.length === 0) {
    // TODO load up the history
  }
  */
};

panels.hideAll = function () {
  var visible = panels.getVisible(),
      i = visible.length;
  while (i--) {
    visible[i].hide();
  }
};

// dirty, but simple
Panel.prototype.distribute = function () {
  panels.distribute();
};

jsbin.panels = panels;

var ignoreDuringLive = /^\s*(while|do|for)[\s*|$]/;


var panelInit = {
  html: function () {
    var init = function () {
      // set cursor position on first blank line
      // 1. read all the inital lines
      var lines = this.editor.getValue().split('\n'),
          blank = -1;
      lines.forEach(function (line, i) {
        if (blank === -1 && line.trim().length === 0) {
          blank = i;
          //exit
        }
      });

      if (blank !== -1) {
        this.editor.setCursor({ line: blank, ch: 2 });
        if (lines[blank].length === 0) {
          this.editor.indentLine(blank, 'add');
        }
      }
    };

    return new Panel('html', { editor: true, label: 'HTML', init: init });
  },
  css: function () {
    return new Panel('css', { editor: true, label: 'CSS' });
  },
  javascript: function () {
    return new Panel('javascript', { editor: true, label: 'JavaScript' });
  },
  console: function () {
    // hide and show callbacks registered in console.js
    return new Panel('console', { label: 'Console' });
  },
  live: function () {
    function show() {
      // var panel = this;
      if (panels.ready) {
        renderLivePreview();
      }
    }

    function hide() {
      // detroy the iframe if we hide the panel
      // note: $live is defined in live.js
      // Commented out so that the live iframe is never destroyed
      if (panels.panels.console.visible === false) {
        // $live.find('iframe').remove();
      }
    }

    return new Panel('live', { label: 'Output', show: show, hide: hide });
  }
};

var editors = panels.panels = {};

// show all panels (change the order to control the panel order)
editors.html = panelInit.html();
editors.css = panelInit.css();
editors.javascript = panelInit.javascript();
editors.console = panelInit.console();
upgradeConsolePanel(editors.console);
editors.live = panelInit.live();

// jsconsole.init(); // sets up render functions etc.
editors.live.settings.render = function (showAlerts) {
  if (panels.ready) {
    renderLivePreview(showAlerts);
  }
};

// IMPORTANT this is nasty, but the sequence is important, because the
// show/hide method is being called as the panels are being called as
// the panel is setup - so we hook these handlers on *afterwards*.
// panels.update = function () {
//   var visiblePanels = panels.getVisible(),
//       visible = [],
//       i = 0;
//   for (i = 0; i < visiblePanels.length; i++) {
//     visible.push(visiblePanels[i].name);
//   }

//   if (history.replaceState) {
//     history.replaceState(null, null, '?' + visible.join(','));
//   } else {
//     // :( this will break jquery mobile - but we're talking IE only at this point, right?
//     location.hash = '#' + visible.join(',');
//   }
// }


// Panel.prototype._show = Panel.prototype.show;
// Panel.prototype.show = function () {
//   this._show.apply(this, arguments);
//   panels.update();
// }

// Panel.prototype._hide = Panel.prototype.hide;
// Panel.prototype.hide = function () {
//   this._hide.apply(this, arguments);
//   panels.update();
// }


panels.allEditors = function (fn) {
  var panelId, panel;
  for (panelId in panels.panels) {
    panel = panels.panels[panelId];
    if (panel.editor) fn(panel);
  }
};

setTimeout(function () {
  panels.restore();
}, 10);
panels.focus(panels.getVisible()[0] || null);

// allow panels to be reordered - TODO re-enable
(function () {
  return; // disabled for now

  var panelsEl = document.getElementById('panels'),
      moving = null;

  panelsEl.ondragstart = function (e) {
    if (e.target.nodeName == 'A') {
      moving = e.target;
    } else {
      return false;
    }
  };

  panelsEl.ondragover = function (e) {
    return false;
  };

  panelsEl.ondragend = function () {
    moving = false;
    return false;
  };

  panelsEl.ondrop = function (e) {
    if (moving) {

    }
    return false;
  };

});


var editorsReady = setInterval(function () {
  var ready = true,
      resizeTimer = null,
      panel,
      panelId;

  for (panelId in panels.panels) {
    panel = panels.panels[panelId];
    if (panel.visible && !panel.ready) ready = false;
  }

  panels.ready = ready;

  if (ready) {
    clearInterval(editorsReady);
    // panels.ready = true;
    // if (typeof editors.onReady == 'function') editors.onReady();
    // panels.distribute();

    // if the console is visible, it'll handle rendering of the output and console
    if (panels.panels.console.visible) {
      editors.console.render();
    } else {
      // otherwise, force a render
      renderLivePreview();
    }


    $(window).resize(function () {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(function () {
        $document.trigger('sizeeditors');
      }, 100);
    });

    $document.trigger('sizeeditors');
    $document.trigger('jsbinReady');
  }
}, 100);
;//= require "../chrome/storage"

var libraries = [
  {
    "url": "http://code.jquery.com/jquery-git2.js",
    "label": "jQuery 2.x WIP (via git)",
    "group": "jQuery"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/jquery/2.0.2/jquery.min.js",
    "label": "jQuery 2.0.2",
    "group": "jQuery"
  },
  {
    "url": "http://code.jquery.com/jquery-latest.js",
    "label": "jQuery 1.latest",
    "group": "jQuery"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js",
    "label": "jQuery 1.10.1",
    "group": "jQuery"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js",
    "label": "jQuery 1.8.3",
    "group": "jQuery"
  },
  {
    "url": [
      "http://code.jquery.com/ui/jquery-ui-git.css",
      "http://code.jquery.com/jquery-git.js",
      "http://code.jquery.com/ui/jquery-ui-git.js"
    ],
    "label": "jQuery UI WIP (via git)",
    "group": "jQuery UI"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/jqueryui/1/themes/smoothness/jquery-ui.min.css",
      "http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js",
      "http://ajax.googleapis.com/ajax/libs/jqueryui/1/jquery-ui.min.js"
    ],
    "label": "jQuery UI latest",
    "group": "jQuery UI"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/themes/smoothness/jquery-ui.min.css",
      "http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js",
      "http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"
    ],
    "label": "jQuery UI 1.10.3",
    "group": "jQuery UI"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/jqueryui/1.9.2/themes/smoothness/jquery-ui.min.css",
      "http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js",
      "http://ajax.googleapis.com/ajax/libs/jqueryui/1.9.2/jquery-ui.min.js"
    ],
    "label": "jQuery UI 1.9.2",
    "group": "jQuery UI"
  },
  {
    "url": [
      "http://code.jquery.com/mobile/latest/jquery.mobile.css",
      "http://code.jquery.com/jquery-1.9.1.min.js",
      "http://code.jquery.com/mobile/latest/jquery.mobile.js"
    ],
    "label": "jQuery Mobile Latest",
    "group": "jQuery Mobile"
  },
  {
    "url": [
      "http://code.jquery.com/mobile/1.3.1/jquery.mobile-1.3.1.min.css",
      "http://code.jquery.com/jquery-1.8.2.min.js",
      "http://code.jquery.com/mobile/1.3.1/jquery.mobile-1.3.1.min.js"
    ],
    "label": "jQuery Mobile 1.3.1",
    "group": "jQuery Mobile"
  },
  {
    "url": [
      "http://code.jquery.com/mobile/1.2.1/jquery.mobile-1.2.1.min.css",
      "http://code.jquery.com/jquery-1.8.3.min.js",
      "http://code.jquery.com/mobile/1.2.1/jquery.mobile-1.2.1.min.js"
    ],
    "label": "jQuery Mobile 1.2.1",
    "group": "jQuery Mobile"
  },
  {
    "url": [
      "http://code.jquery.com/mobile/1.1.2/jquery.mobile-1.1.2.min.css",
      "http://code.jquery.com/jquery-1.6.4.min.js",
      "http://code.jquery.com/mobile/1.1.2/jquery.mobile-1.1.2.min.js"
    ],
    "label": "jQuery Mobile 1.1.2",
    "group": "jQuery Mobile"
  },
  {
  "url": [
      "http://code.jquery.com/jquery.min.js",
      "http://getbootstrap.com/dist/css/bootstrap.css",
      "http://getbootstrap.com/dist/js/bootstrap.js"
    ],
    "label": "Bootstrap Latest",
    "group": "Bootstrap"
  },
  {
  "url": [
      "http://code.jquery.com/jquery.min.js",
      "http://getbootstrap.com/2.3.2/assets/css/bootstrap.css",
      "http://getbootstrap.com/2.3.2/assets/css/bootstrap-responsive.css",
      "http://getbootstrap.com/2.3.2/assets/js/bootstrap.js"
    ],
    "label": "Bootstrap 2.3.3",
    "group": "Bootstrap"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/prototype/1/prototype.js",
    "label": "Prototype latest",
    "group": "Prototype"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/prototype/1.7/prototype.js",
    "label": "Prototype 1.7.1",
    "group": "Prototype"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/prototype/1.6.1.0/prototype.js",
    "label": "Prototype 1.6.1.0",
    "group": "Prototype"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/prototype/1/prototype.js",
      "http://ajax.googleapis.com/ajax/libs/scriptaculous/1/scriptaculous.js"
    ],
    "label": "script.aculo.us latest",
    "group": "Prototype"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/prototype/1/prototype.js",
      "http://ajax.googleapis.com/ajax/libs/scriptaculous/1.8.3/scriptaculous.js"
    ],
    "label": "script.aculo.us 1.8.3",
    "group": "Prototype"
  },
  {
    "url": "http://yui.yahooapis.com/3.10.0/build/yui/yui.js",
    "label": "YUI 3.10.0",
    "group": "YUI"
  },
  {
    "url": "http://yui.yahooapis.com/2.9.0/build/yuiloader/yuiloader-min.js",
    "label": "YUI 2.9.0",
    "group": "YUI"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/mootools/1/mootools-yui-compressed.js",
    "label": "MooTools latest",
    "group": "MooTools"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/mootools/1.4.5/mootools-yui-compressed.js",
    "label": "MooTools 1.4.5",
    "group": "MooTools"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/dojo/1/dojo/dojo.js",
    "label": "Dojo latest",
    "group": "Dojo"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/dojo/1.8/dojo/dojo.js",
    "label": "Dojo 1.8.4",
    "group": "Dojo"
  },
  {
    "url": "http://ajax.googleapis.com/ajax/libs/dojo/1.7/dojo/dojo.js",
    "label": "Dojo 1.7.4",
    "group": "Dojo"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/dojo/1/dijit/themes/claro/claro.css",
      "http://ajax.googleapis.com/ajax/libs/dojo/1/dojo/dojo.js"
    ],
    "label": "Dijit latest (Claro)",
    "group": "Dojo"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/dojo/1.8.4/dijit/themes/claro/claro.css",
      "http://ajax.googleapis.com/ajax/libs/dojo/1.8.4/dojo/dojo.js"
    ],
    "label": "Dijit 1.8.4 (Claro)",
    "group": "Dojo"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/dojo/1.7.4/dijit/themes/claro/claro.css",
      "http://ajax.googleapis.com/ajax/libs/dojo/1.7.4/dojo/dojo.xd.js"
    ],
    "label": "Dijit 1.7.4 (Claro)",
    "group": "Dojo"
  },
  {
    "url": [
      "http://cdn.kendostatic.com/2013.2.716/styles/kendo.common.min.css",
      "http://cdn.kendostatic.com/2013.2.716/styles/kendo.rtl.min.css",
      "http://cdn.kendostatic.com/2013.2.716/styles/kendo.default.min.css",
      "http://cdn.kendostatic.com/2013.2.716/styles/kendo.dataviz.min.css",
      "http://cdn.kendostatic.com/2013.2.716/styles/kendo.dataviz.default.min.css",
      "http://cdn.kendostatic.com/2013.2.716/styles/kendo.mobile.all.min.css",
      "http://code.jquery.com/jquery-1.9.1.min.js",
      "http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js"
    ],
    "label": "Kendo UI Q2 2013",
    "group": "Kendo UI"
  },
  {
    "url": [
      "http://cdn.kendostatic.com/2013.1.319/styles/kendo.common.min.css",
      "http://cdn.kendostatic.com/2013.1.319/styles/kendo.rtl.min.css",
      "http://cdn.kendostatic.com/2013.1.319/styles/kendo.default.min.css",
      "http://cdn.kendostatic.com/2013.1.319/styles/kendo.dataviz.min.css",
      "http://cdn.kendostatic.com/2013.1.319/styles/kendo.dataviz.default.min.css",
      "http://cdn.kendostatic.com/2013.1.319/styles/kendo.mobile.all.min.css",
      "http://code.jquery.com/jquery-1.9.1.min.js",
      "http://cdn.kendostatic.com/2013.1.319/js/kendo.all.min.js"
    ],
    "label": "Kendo UI Q1 2013",
    "group": "Kendo UI"
  },
  {
    "url" : [
      "http://code.jquery.com/qunit/qunit-git.css",
      "http://code.jquery.com/qunit/qunit-git.js"
    ],
    "label": "QUnit",
    "group": "Testing"
  },
  {
    "url": "http://zeptojs.com/zepto.min.js",
    "label": "Zepto latest",
    "group": "Zepto"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0/zepto.min.js",
    "label": "Zepto 1.0",
    "group": "Zepto"
  },
  {
    "url":"https://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js",
    "label": "Angular 1.1.5 Unstable",
    "group": "Angular"
  },
  {
    "url":"https://ajax.googleapis.com/ajax/libs/angularjs/1.0.7/angular.min.js",
    "label": "Angular 1.0.7 Stable",
    "group": "Angular"
  },
  {
    "url": [
      "http://nightly.enyojs.com/latest/enyo-nightly/enyo.css",
      "http://nightly.enyojs.com/latest/enyo-nightly/enyo.js",
      "http://nightly.enyojs.com/latest/lib/layout/package.js",
      "http://nightly.enyojs.com/latest/lib/onyx/package.js",
      "http://nightly.enyojs.com/latest/lib/g11n/package.js",
      "http://nightly.enyojs.com/latest/lib/canvas/package.js"
    ],
    "label": "Enyo latest",
    "group": "Enyo"
  },
  {
    "url": [
      "http://enyojs.com/enyo-2.2.0/enyo.css",
      "http://enyojs.com/enyo-2.2.0/enyo.js",
      "http://enyojs.com/enyo-2.2.0/lib/layout/package.js",
      "http://enyojs.com/enyo-2.2.0/lib/onyx/package.js",
      "http://enyojs.com/enyo-2.2.0/lib/g11n/package.js",
      "http://enyojs.com/enyo-2.2.0/lib/canvas/package.js"
    ],
    "label": "Enyo 2.2.0",
    "group": "Enyo"
  },
  {
    "url": [
      "http://documentcloud.github.io/underscore/underscore-min.js",
      "http://documentcloud.github.io/backbone/backbone-min.js"
    ],
    "label": "Backbone latest"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/bonsai/0.4/bonsai.min.js",
    "label": "Bonsai 0.4.latest"
  },
  {
    "url": "http://jashkenas.github.io/coffee-script/extras/coffee-script.js",
    "label": "CoffeeScript"
  },
  {
    "url": [
      "http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js",
      "http://cdnjs.cloudflare.com/ajax/libs/handlebars.js/1.0.0/handlebars.js",
      "http://builds.emberjs.com.s3.amazonaws.com/tags/v1.0.0/ember.js"
    ],
    "label": "Ember.js 1.0.0"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/es5-shim/2.0.8/es5-shim.min.js",
    "label": "ES5 shim 2.0.8"
  },
  {
    "url": [
      "http://extjs.cachefly.net/ext-3.1.0/resources/css/ext-all.css",
      "http://cdnjs.cloudflare.com/ajax/libs/ext-core/3.1.0/ext-core.min.js"
    ],
    "label": "ext-core 3.1.0"
  },
  {
    "url": [
      "http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/css/normalize.min.css",
      "http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/css/foundation.min.css",
      "http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/js/vendor/custom.modernizr.min.js",
      "http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/js/vendor/jquery.min.js",
      "http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/js/foundation.min.js"
    ],
    "label": "Foundation 4.1.6"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/handlebars.js/1.0.0/handlebars.js",
    "label": "Handlebars.js 1.0.0"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/knockout/2.2.1/knockout-min.js",
    "label": "Knockout 2.2.1"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/less.js/1.3.3/less.min.js",
    "label": "Less 1.3.3"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/lodash.js/1.2.1/lodash.min.js",
    "label": "lodash 1.2.1"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js",
    "label": "Modernizr 2.6.2"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/prefixfree/1.0.7/prefixfree.min.js",
    "label": "Prefixfree 1.0.7"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/processing.js/1.4.1/processing-api.min.js",
    "label": "Processing 1.4.1"
  },
  {
    "url": "http://d3js.org/d3.v3.min.js",
    "label": "D3 3.x"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js",
    "label": "Rapha&euml;l 2.1.0"
  },
  {
    "url": "http://cdnjs.cloudflare.com/ajax/libs/sammy.js/0.7.4/sammy.min.js",
    "label": "Sammy 0.7.4"
  },
  {
    "url": [
      "http://cdn.sencha.io/touch/1.1.0/resources/css/sencha-touch.css",
      "http://cdn.sencha.io/touch/1.1.0/sencha-touch.js"
    ],
    "label": "Sencha Touch"
  },
  {
    "url": [
      jsbin.static + "/js/vendor/traceur.js"
    ],
    "label": "Traceur"
  },
  {
    "url": "http://remy.github.io/twitterlib/twitterlib.min.js",
    "label": "TwitterLib"
  },
  {
    "url": "http://documentcloud.github.io/underscore/underscore-min.js",
    "label": "underscore"
  },
  {
    "url":[
      "http://code.jquery.com/jquery-1.9.1.min.js",
      "//canjs.com/release/1.1.6/can.jquery.js"
    ],
    "label": "CanJS for jQuery"
  },
  {
    "url":[
      "http://cdnjs.cloudflare.com/ajax/libs/three.js/r58/three.min.js"
    ],
    "label": "Three.js r58"
  },
  {
    "url":[
      "http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"
    ],
    "label": "HTML5 shiv"
  },
  {
    "url": [
      "http://lungo.tapquo.com/demo/components/lungo/lungo.css",
      "http://lungo.tapquo.com/demo/components/lungo/lungo.theme.css",
      "http://lungo.tapquo.com/demo/components/lungo/lungo.icon.css",
      "http://lungo.tapquo.com/demo/components/quojs/quo.js",
      "http://lungo.tapquo.com/demo/components/lungo/lungo.js"
    ],
    "label": "Lungo"
  },
  {
    "url": "//cdnjs.cloudflare.com/ajax/libs/polymer/0.0.20131010/polymer.min.js",
    "label": "Polymer"
  }
];

window.libraries = libraries; // expose a command line API

libraries.userSpecified = JSON.parse(localStorage.getItem('libraries') || "[]");
for (var i = 0; i < libraries.userSpecified.length; i++) {
  libraries.push(libraries.userSpecified[i]);
}

libraries.add = function (lib) {
  // Extract each script from a list (as documented) or use the default way
  if (lib.scripts) {
    lib.scripts.forEach(function (script) {
      script.group = lib.text;
      script.label = script.text;
      libraries.userSpecified.push(script);
      libraries.push(script);
    });
  } else {
    // Adding a lib according to the above schema
    lib.group = 'Custom';
    libraries.userSpecified.push(lib);
    libraries.push(lib);
  }
  try {
    localStorage.setItem('libraries', JSON.stringify(this.userSpecified));
  } catch (e) {} // just in case of DOM_22 error, makes me so sad to use this :(
  $('#library').trigger('init');
};

libraries.clear = function () {
  libraries.userSpecified = [];
  localStorage.removeItem('libraries');
  var length = libraries.length;
  for (var i = 0; i < length; i++) {
    if (libraries[i].group === 'Custom') {
      libraries.splice(i, 1);
      length--;
    }
  }
  // force a refresh?
  $('#library').trigger('init');
};
;//= require "libraries"

var $library = $('#library'),
    groups = {};

$library.bind('init', function () {
  var i = 0,
    j = 0,
    k = 0,
    library = {},
    groupOrder = [],
    group = {},
    groupLabel = '',
    lcGroup = '';

  // reset
  groups = {};
  $library.empty();

  for (i = 0; i < libraries.length, library = libraries[i]; i++) {
    groupLabel = library.group || 'Other';
    lcGroup = groupLabel.toLowerCase().replace(/[^a-z0-9]/ig, '');
    if (groupOrder.indexOf(lcGroup) === -1) {
      group = { label: groupLabel, libraries: [], key: lcGroup };
      groups[lcGroup] = group;
      groupOrder.push(lcGroup);
    } else {
      group = groups[lcGroup];
    }

    group.libraries.push(library);
  }

  var html = ['<option value="none">None</option>'];

  for (i = 0; i < groupOrder.length; i++) {
    group = groups[groupOrder[i]];
    html.push('<option value="" data-group="' + group.label + '" class="heading">-------------</option>');

    for (j = 0; j < group.libraries.length, library = group.libraries[j]; j++) {
      html.push('<option value="' + group.key + ':' + j + '">' + library.label + '</option>');
    }
  }

  $library.html( html.join('') );
}).trigger('init');


$library.bind('change', function () {
  if (!this.value) return;

  var selected = this.value.split(':'),
      group = groups[selected[0]],
      library = group.libraries[selected[1]];

  analytics.library('select', group.libraries[selected[1]].label);
  insertResources(library.url);
}).on('click', function () {
  analytics.library('open');
});

function insertResources(urls) {
  if (!$.isArray(urls)) {
    urls = [urls];
  }

  var i = 0,
      length = urls.length,
      url = '',
      code = editors.html.getCode(),
      state = {
        line: editors.html.editor.currentLine(),
        character: editors.html.editor.getCursor().ch,
        add: 0
      },
      html = [],
      file = '';

  for (i = 0; i < length; i++) {
    url = urls[i];

    file = url.split('/').pop();

    if (file && code.indexOf(file + '"')) {
      // attempt to lift out similar scripts
      if (isCssFile(file)) {
        code = code.replace(new RegExp('<link.*href=".*?/' + file + '".*?/>\n?'), '');
      } else {
        code = code.replace(new RegExp('<script.*src=".*?/' + file + '".*?><' + '/script>\n?'), '');
      }
      state.add--;
    }

    if (isCssFile(url)) {
      html.push('<' + 'link href="' + url + '" rel="stylesheet" type="text/css" />');
    } else {
      html.push('<' + 'script src="' + url + '"><' + '/script>');
    }

    state.add++;
  }

  if (code.indexOf('<head') !== -1) {
    code = code.replace(/<head>/i, '<head>\n' + html.join('\n'));
  } else { // add to the start of the doc
    code = html.join('\n') + code;
  }

  editors.html.setCode(code);
  editors.html.editor.setCursor({ line: state.line + state.add, ch: state.character });

}

function isCssFile(url) {
  return (url.length - (url.lastIndexOf('.css') + 4) === 0);
};;(function () {
  var $body = $('body'),
      loaded = false,
      $history; // set in hookUserHistory()

  $document.on('history:open', function () {
    if ($history && jsbin.panels.getVisible().length === 0) {
      $history.appendTo('body');
    }
  }).on('history:close', function () {
    if ($history === null) {
      $history = $('#history').detach();
    }
  });

  var loadList = function () {
    if (loaded) return;

    if ($('html').hasClass('public-listing')) {
      hookUserHistory();
    } else {
      $.ajax({
        dataType: 'html',
        url: jsbin.root + '/list',
        error: function () {
          $('#history').remove();
          setTimeout(loadList, 500);
        },
        success: function (html) {
          $('#history').remove();
          $body.append(html);
          hookUserHistory();
          loaded = true;
        }
      });
    }
  };

  var updatePreview = function(url, $iframe) {
    $iframe.attr('src', url + '/quiet');
    $iframe.removeAttr('hidden');
  };

  var updateViewing = function (url, $viewing) {
    $viewing.text(url);
  };

  var updateLayout = function ($tbodys, archiveMode) {
    var $parent = $tbodys.parent();
    $tbodys
      .detach()
      .each(function () {
        var $tbody = $(this),
            filter = archiveMode ? '.archived' : ':not(.archived)',
            $trs = $('tr' + filter, $tbody).filter(':not(.spacer)');
        if ($trs.length > 0) {
          $trs.filter('.first').removeClass('first');
          $tbody.removeClass('hidden');
          $trs.first().addClass('first');
        } else {
          $tbody.addClass('hidden');
        }
      })
      .appendTo($parent);
  };

  var hookUserHistory = function () {
    // Loading the HTML from the server may have failed
    $history = $('#history').detach();
    if (!$history.length) return $history;

    // Cache some useful elements
    var $iframe = $('iframe', $history),
        $viewing = $('#viewing', $history),
        $bins = $history,
        $tbodys = $('tbody', $history),
        $trs = $('tr', $history),
        $created = $('td.created a', $history),
        $toggle = $('.toggle_archive', $history),
        current = null,
        hoverTimer = null,
        layoutTimer = null;

    // Load bin from data-edit-url attribute when user clicks on a row
    $bins.delegate('tr:not(.spacer)', 'click', function () {
      if (event.shiftKey || event.metaKey) return;
      window.location = this.getAttribute('data-edit-url');
    });

    // Archive & un-archive click handlers
    $bins.delegate('.archive, .unarchive', 'click', function (e) {
      var $this = $(this),
          $row = $this.parents('tr');
      // Instantly update this row and the page layout
      $row.toggleClass('archived');

      analytics[this.pathname.indexOf('unarchive') === -1 ? 'archive' : 'unarchive'](jsbin.root + $row.data('url'));

      updateLayout($tbodys, $history.hasClass('archive_mode'));
      // Then send the update to the server
      $.ajax({
        type: 'POST',
        url: $this.attr('href'),
        error: function () {
          // Undo if something went wrong
          alert("Something went wrong, please try again");
          $row.toggleClass('archived');
          updateLayout($tbodys, $history.hasClass('archive_mode'));
        },
        success: function () {}
      });
      return false;
    });

    // Handle toggling of archive view
    $toggle.change(function () {
      $history.toggleClass('archive_mode');
      var archive = $history.hasClass('archive_mode');
      analytics.archiveView(archive);
      updateLayout($tbodys, archive);
    });


    // Load a preview on tr mouseover (delayed by 400ms)
    $bins.delegate('tr', 'mouseover', function (event) {
      var $this = $(this),
          url = $this.attr('data-url');
      clearTimeout(hoverTimer);
      if (!$this.hasClass('spacer') && current !== url) {
        hoverTimer = setTimeout(function () {
          $trs.removeClass('selected');
          $this.addClass('selected');
          current = url;
          updatePreview(url, $iframe);
          updateViewing(url, $viewing);
        }, 400);
      }
      return false;
    });

    // Update the time every 30 secs
    // Need to replace Z in ISO8601 timestamp with +0000 so prettyDate() doesn't
    // completely remove it (and parse the date using the local timezone).
    $('a[pubdate]', $history).attr('pubdate', function (i, val) {
      return val.replace('Z', '+0000');
    }).prettyDate();
    setInterval(function(){
      $created.prettyDate();
    }, 30 * 1000);

    // Update the layout straign away
    setTimeout(function () {
      updateLayout($tbodys, false);
    }, 0);

    $document.trigger('history:open');

    return $history;
  };

  // inside a ready call because history DOM is rendered *after* our JS to improve load times.
  $(function ()  {
    if (jsbin.embed) return;

    var $panelButtons = $('#panels a'),
        $homebtn = $('.homebtn'),
        panelsVisible = $body.hasClass('panelsVisible');

    var panelCloseIntent = function() {
      var activeCount = $panelButtons.filter('.active').length;
      if (activeCount === 1 && $(this).hasClass('active')) {
        loadList();
      }
    };

    // this code attempts to only call the list ajax request only if
    // the user should want to see the list page - most users will
    // jump in and jump out of jsbin, and never see this page,
    // so let's not send this ajax request.
    //
    // The list should be loaded when:
    //   - user hovers the home button
    //   - they close all the panels
    //   - they arrive at the page with no panels open

    $homebtn.on('click', loadList);
    $panelButtons.on('mousedown', panelCloseIntent);

    if (!panelsVisible) {
      loadList();
    }

  });

}());
;var loginVisible = false,
    dropdownOpen = false,
    keyboardHelpVisible = false,
    urlHelpVisible = false;

$document.keydown(function (event) {
  if (event.which == 27) {//} || (keyboardHelpVisible && event.which == 191 && event.shiftKey && event.metaKey)) {
    hideOpen();
  }
});

function hideOpen() {
  if (urlHelpVisible) {
    $body.removeClass('urlHelp');
    urlHelpVisible = false;
    analytics.closeMenu('help');
  } else if (keyboardHelpVisible) {
    $body.removeClass('keyboardHelp');
    keyboardHelpVisible = false;
    analytics.closeMenu('keyboardHelp');
  } else if (dropdownOpen) {
    var open = $('.menu.open').removeClass('open');
    analytics.closeMenu(open.find('.button')[0].hash.substring(1));
    dropdownOpen = false;
  } else if (loginVisible) {
    $('#login').hide();
    analytics.closeMenu('login');
    loginVisible = false;
  }
}

$document.delegate('.modal', 'click', function (event) {
  if ($(event.target).is('.modal')) {
    hideOpen();
  }
});;(function () {

  var $newissue = $('#newissue'),
      url = 'http://github.com/remy/jsbin/issues/new',
      body = 'Please provide any additional information, record a screencast '
             + 'with http://quickcast.io or http://screenr.com and attach a screenshot '
             + 'if possible.\n\n**JS Bin info**\n\n* [%url%](%url%)\n* '
             + window.navigator.userAgent + '\n'
             + (jsbin.user && jsbin.user.name ? '* ' + jsbin.user.name : '')
             + '\n';

  $('#help').parent().on('open', function () {
    console.log('open');
    $newissue.attr('href', url + '?body=' + encodeURIComponent(body.replace(/%url%/g, jsbin.getURL())));
  });

})();;$('#download').click(function (event) {
  event.preventDefault();
  window.location = jsbin.getURL() + '/download';
  analytics.download();
});
;var $username = $('#username'),
    $password = $('#password'),
    $email = $('#email');

var $loginForm = $('form.login').submit(function (event) {
  event.preventDefault();

  var form = $(this),
      name = form.find('input[name=username]').val(),
      key = form.find('input[name=password]').val(),
      email = form.find('input[name=email]').val(),
      $loginFeedback = form.find('.loginFeedback');


  // jsbin.settings.home = name; // will save later
  $loginFeedback.show().text('Checking...');

  $.ajax({
    url: jsbin.root + '/sethome',
    data: { name: name, key: key, email: email },
    type: 'post',
    dataType: 'json',
    complete: function (jqXHR) {
      var data = $.parseJSON(jqXHR.responseText) || {};
      // cookie is required to share with the server so we can do a redirect on new bin
      if (data.ok) {
        if (data.avatar) {
          $('#avatar').find('img').remove().end().prepend('<img class="avatar" src="' + data.avatar + '">');
        }
        if (data.message) {
          $loginFeedback.text(data.message);
        } else {
          window.location = window.location.pathname + window.location.search;
        }
      } else {
        analytics.login(false);
        $loginFeedback.text(data.message || ('"' + name + '" has already been taken. Please either double check the password, or choose another username.'));
      }
    }
  });
});

// if ($('#homebtn').length) {
//   jsbin.settings.home = document.cookie.split('home=')[1].split(';')[0];
//   document.title = jsbin.settings.home + '@' + document.title;
// }
;(function () {

  var $html = $(document.documentElement),
      $tip = $('#tip'),
      $tipContent = $('p', $tip),
      tipTimeout;

  var removeTip = function (cb) {
    $html.removeClass('showtip');
    $tip.removeClass();
    $tipContent.html('');
    $(window).resize();
    cb && setTimeout(cb, 0);
  };

  var setTip = function (data) {
    clearTimeout(tipTimeout);
    $tipContent.html(data.content);
    $tip.removeClass().addClass(data.type || 'info');
    $html.addClass('showtip');
    if (!data.autohide) return;
    tipTimeout = setTimeout(function () {
      removeTip();
    }, parseInt(data.autohide, 10) || 5 * 1000);
  };

  /**
   * Trigger a tip to be shown.
   *
   *   $document.trigger('tip', 'You have an infinite loop in your HTML.');
   *
   *    $document.trigger('tip', {
   *      type: 'error',
   *      content: 'Do you even Javascript?',
   *      autohide: 8000
   *    });
   */
  $document.on('tip', function (event, data) {
    var tipData = data;
    if (typeof data === 'string') {
      tipData = {};
      tipData.content = data;
      tipData.type = 'info';
    }
    // If the content and the type haven't changed, just set it again.
    if ($tipContent.html() === tipData.content &&
        $tip.hasClass(tipData.type)) return setTip(data);
    removeTip(function () {
      setTip(tipData);
    });
  });

  $('#tip').on('click', 'a.dismiss', function () {
    removeTip();
    return false;
  });

  // Escape
  $document.keydown(function (event) {
    if (event.which == 27) {
      removeTip();
    }
  });

}());;var saving = {
  todo: {
    html: false,
    css: false,
    javascript: false
  },
  _inprogress: false,
  inprogress: function (inprogress) {
    if (typeof inprogress === 'undefined') {
      return saving._inprogress;
    }

    saving._inprogress = inprogress;
    if (inprogress === false) {
      var panels = ['html','css','javascript'],
          todo;

      var save = function () {
        var todo = panels.pop();
        if (todo && saving.todo[todo]) {
          saving._inprogress = true;
          updateCode(todo, save);
          saving.todo[todo] = false;
        } else if (todo) {
          save();
        }
      };

      save();
    }
  }
};

// to allow for download button to be introduced via beta feature
$('a.save').click(function (event) {
  event.preventDefault();

  analytics.milestone();
  // if save is disabled, hitting save will trigger a reload
  saveCode('save', jsbin.saveDisabled === true ? false : true);

  return false;
});

var $shareLinks = $('#share .link');

$panelCheckboxes = $('#sharemenu #sharepanels input');

function updateSavedState() {
  var mapping = {
    live: 'output',
    javascript: 'js',
    css: 'css',
    html: 'html',
    console: 'console'
  };
  var query = $panelCheckboxes.filter(':checked').map(function () {
    return mapping[this.getAttribute('data-panel')];
  }).get().join(',');
  $shareLinks.each(function () {
    var url = jsbin.getURL() + this.getAttribute('data-path') + (query && this.id !== 'livepreview' ? '?' + query : ''),
        nodeName = this.nodeName;
    if (nodeName === 'A') {
      this.href = url;
    } else if (nodeName === 'INPUT') {
      this.value = url;
    } else if (nodeName === 'TEXTAREA') {
      this.value = ('<a class="jsbin-embed" href="' + url + '">' + documentTitle + '</a><' + 'script src="' + jsbin.static + '/js/embed.js"><' + '/script>').replace(/<>"&/g, function (m) {
          return {
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '&': '&amp;'
          }[m];
        });
    }
  });
}

$('#sharemenu').bind('open', function () {
  updateSavedState();
});

$document.on('saved', function () {
  updateSavedState();
  $shareLinks.closest('.menu').removeClass('hidden');

  $('#jsbinurl').attr('href', jsbin.getURL()).removeClass('hidden');
  $('#clone').removeClass('hidden');
});

var saveChecksum = jsbin.state.checksum || sessionStorage.getItem('checksum') || false;

if (saveChecksum) {
  // remove the disabled class, but also remove the cancelling event handlers
  $('#share div.disabled').removeClass('disabled').unbind('click mousedown mouseup');
} else {
  $('#share div.disabled').one('click', function (event) {
    event.preventDefault();
    $('a.save').click();
  });
}

$document.one('saved', function () {
  $('#share div.disabled').removeClass('disabled').unbind('click mousedown mouseup');
});

// TODO decide whether to expose this code, it disables live saving for IE users
// until they refresh - via a great big yellow button. For now this is hidden
// in favour of the nasty hash hack.
if (false) { // !saveChecksum && !history.pushState) {
  jsbin.saveDisabled = true;

  $document.bind('jsbinReady', function () {
    $document.one('codeChange', function () {
      $('#start-saving').css('display', 'inline-block');
    });
  });
}

function onSaveError(jqXHR, panelId) {
  if (jqXHR.status === 413) {
    // Hijack the tip label to show an error message.
    $('#tip p').html('Sorry this bin is too large for us to save');
    $(document.documentElement).addClass('showtip');
  } else {
    if (panelId) savingLabels[panelId].text('Saving...').animate({ opacity: 1 }, 100);
    window._console.error({message: 'Warning: Something went wrong while saving. Your most recent work is not saved.'});
    // $document.trigger('tip', {
    //   type: 'error',
    //   content: 'Something went wrong while saving. Your most recent work is not saved.'
    // });
  }
}



// only start live saving it they're allowed to (whereas save is disabled if they're following)
if (!jsbin.saveDisabled) {
  $('.code.panel .label .name').append('<span>Saved</span>');

  var savingLabels = {
    html: $('.panel.html .name span'),
    javascript: $('.panel.javascript .name span'),
    css: $('.panel.css .name span')
  };

  $document.bind('jsbinReady', function () {
    jsbin.panels.allEditors(function (panel) {
      panel.on('processor', function () {
        // if the url doesn't match the root - i.e. they've actually saved something then save on processor change
        if (jsbin.root !== jsbin.getURL()) {
          $document.trigger('codeChange', [{ panelId: panel.id }]);
        }
      });
    });

    $document.bind('codeChange', function (event, data) {
      // savingLabels[data.panelId].text('Saving');
      if (savingLabels[data.panelId]) {
        savingLabels[data.panelId].css({ 'opacity': 0 }).stop(true, true);
      }
    });

    $document.bind('saveComplete', throttle(function (event, data) {
      // show saved, then revert out animation
      savingLabels[data.panelId]
        .text('Saved')
        .stop(true, true)
        .animate({ opacity: 1 }, 100)
        .delay(1200)
        .animate({ opacity: 0 }, 500);
    }, 500));

    $document.bind('codeChange', throttle(function (event, data) {
      if (!data.panelId) return;

      var panelId = data.panelId;

      if (saving.inprogress()) {
        // queue up the request and wait
        saving.todo[panelId] = true;
        return;
      }

      saving.inprogress(true);

      if (!saveChecksum) {
        // create the bin and when the response comes back update the url
        saveCode('save', true);
      } else {
        updateCode(panelId);
      }
    }, 250));
  });
}

function updateCode(panelId, callback) {
  var panelSettings = {};

  if (jsbin.state.processors) {
    panelSettings.processors = jsbin.state.processors;
  }

  $.ajax({
    url: jsbin.getURL() + '/save',
    data: {
      code: jsbin.state.code,
      revision: jsbin.state.revision,
      method: 'update',
      panel: panelId,
      content: editors[panelId].getCode(),
      checksum: saveChecksum,
      settings: JSON.stringify(panelSettings)
    },
    type: 'post',
    dataType: 'json',
    headers: {'Accept': 'application/json'},
    success: function (data) {
      $document.trigger('saveComplete', { panelId: panelId });
      if (data.error) {
        saveCode('save', true, function (data) {
          // savedAlready = data.checksum;
        });
      }
    },
    error: function (jqXHR) {
      onSaveError(jqXHR, panelId);
    },
    complete: function () {
      saving.inprogress(false);
      callback && callback();
    }
  });
}

$('a.clone').click(function (event) {
  event.preventDefault();

  // save our panel layout - assumes our user is happy with this layout
  jsbin.panels.save();
  analytics.clone();

  var $form = setupform('save,new');
  $form.submit();

  return false;
});

function setupform(method) {
var $form = $('form#saveform').empty()
    .append('<input type="hidden" name="javascript" />')
    .append('<input type="hidden" name="html" />')
    .append('<input type="hidden" name="css" />')
    .append('<input type="hidden" name="method" />')
    .append('<input type="hidden" name="_csrf" value="' + jsbin.state.token + '" />')
    .append('<input type="hidden" name="settings" />');

  var settings = {};

  if (jsbin.state.processors) {
    settings.processors = jsbin.state.processors;
  }

  // this prevents new revisions forking off the welcome bin
  // because it's looking silly!
  if (jsbin.state.code === 'welcome') {
    $form.attr('action', '/save');
  }

  $form.find('input[name=settings]').val(JSON.stringify(settings));
  $form.find('input[name=javascript]').val(editors.javascript.getCode());
  $form.find('input[name=css]').val(editors.css.getCode());
  $form.find('input[name=html]').val(editors.html.getCode());
  $form.find('input[name=method]').val(method);

  return $form;
}

function pad(n){
  return n<10 ? '0'+n : n
}

function ISODateString(d){
  return d.getFullYear()+'-'
    + pad(d.getMonth()+1)+'-'
    + pad(d.getDate())+'T'
    + pad(d.getHours())+':'
    + pad(d.getMinutes())+':'
    + pad(d.getSeconds())+'Z'
}

function saveCode(method, ajax, ajaxCallback) {
  // create form and post to it
  var $form = setupform(method);
  // save our panel layout - assumes our user is happy with this layout
  jsbin.panels.save();
  jsbin.panels.saveOnExit = true;

  if (ajax) {
    $.ajax({
      url: $form.attr('action'),
      data: $form.serialize(),
      dataType: 'json',
      type: 'post',
      headers: {'Accept': 'application/json'},
      success: function (data) {
        var $binGroup,
            edit;

        $form.attr('action', data.url + '/save');
        ajaxCallback && ajaxCallback(data);

        sessionStorage.setItem('checksum', data.checksum);
        saveChecksum = data.checksum;

        jsbin.state.code = data.code;
        jsbin.state.revision = data.revision;

        // getURL(true) gets the jsbin without the root attached
        $binGroup = $('#history tr[data-url="' + jsbin.getURL(true) + '"]');
        edit = data.edit.replace(location.protocol + '//' + window.location.host, '') + window.location.search;
        $binGroup.find('td.url a span.first').removeClass('first');
        $binGroup.before('<tr data-url="' + data.url + '/" data-edit-url="' + edit + '"><td class="url"><a href="' + edit + '?live"><span class="first">' + data.code + '/</span>' + data.revision + '/</a></td><td class="created"><a href="' + edit + '" pubdate="' + data.created + '">Just now</a></td><td class="title"><a href="' + edit + '">' + data.title + '</a></td></tr>');

        $document.trigger('saved');

        if (window.history && window.history.pushState) {
          // updateURL(edit);
          window.history.pushState(null, '', jsbin.getURL() + '/edit');
          sessionStorage.setItem('url', jsbin.getURL());
        } else {
          window.location.hash = data.edit;
        }
      },
      error: function (jqXHR) {
        onSaveError(jqXHR);
      },
      complete: function () {
        saving.inprogress(false);
      }
    });
  } else {
    $form.submit();
  }
}

/**
 * Returns the similar part of two strings
 * @param  {String} a first string
 * @param  {String} b second string
 * @return {String}   common substring
 */
function sameStart(a, b) {
  if (a == b) return a;

  var tmp = b.slice(0, 1);
  while (a.indexOf(b.slice(0, tmp.length + 1)) === 0) {
    tmp = b.slice(0, tmp.length + 1);
  }

  return tmp;
}

/*

// refresh the window when we popstate, because for now we don't do an xhr to
// inject the panel content...yet.
window.onpopstate = function onpopstate(event) {
  // ignore the first popstate event, because that comes from the browser...
  if (!onpopstate.first) window.location.reload();
  else onpopstate.first = false;
};

onpopstate.first = true;

function updateURL(path) {
  var old = location.pathname,
      back = true,
      same = sameStart(old, path);
      sameAt = same.length;

  if (updateURL.timer) window.cancelAnimationFrame(updateURL.timer);

  var run = function () {
    if (location.pathname !== path) {
      updateURL.timer = window.requestAnimationFrame(run);
    }

    if (location.pathname !== same) {
      if (back) {
        history.replaceState({ path: path }, '', location.pathname.slice(0, -1));
      } else {
        history.replaceState({ path: path }, '', path.slice(0, location.pathname.length + 1));
      }
    } else {
      back = false;
      history.replaceState({ path: path }, '', path.slice(0, sameAt + 2));
    }
  };

  history.pushState({ path: path }, '', location.pathname.slice(0, -1));

  run();
}

*/;var $startingpoint = $('#startingpoint').click(function (event) {
  event.preventDefault();
  if (localStorage) {
    analytics.saveTemplate();
    localStorage.setItem('saved-javascript', editors.javascript.getCode());
    localStorage.setItem('saved-html', editors.html.getCode());

    $document.trigger('tip', {
      type: 'notification',
      content: 'Starting template updated and saved',
      autohide: 3000
    });
  } else {
    $document.trigger('tip', {
      type: 'error',
      content: 'Saving templates isn\'t supported in this browser I\'m afraid. Sorry'
    });
  }
  return false;
});

// if (localStorage && localStorage['saved-html']) {
  // $startingpoint.append('')
// }

$('a.disabled').on('click mousedown mouseup', function (event) {
  event.stopImmediatePropagation();
  return false;
});

$('#loginbtn').click(function () {
  analytics.login();
  // $('#login').show();
  // loginVisible = true;
  $username.focus();
  // return false;
});

$('.logout').click(function (event) {
  event.preventDefault();

  // We submit a form here because I can't work out how to style the button
  // element in the form to look the same as the anchor. Ideally we would
  // remove that and just let the form submit itself...
  $(this.hash).submit();
});

$('.homebtn').click(function (event, data) {
  if (this.id === 'avatar') {
    analytics.openFromAvatar();
  } else if (this.id === 'profile') {
    analytics.openFromAvatar();
    $(this).closest('.open').removeClass('open');
  } else {
    analytics.open(data);
  }

  jsbin.panels.hideAll();
  return false;
});

var $lockrevision = $('.lockrevision').on('click', function (event) {
  event.preventDefault();
  if (!$lockrevision.data('lock')) {
    analytics.lock();
    $lockrevision.removeClass('icon-unlocked').addClass('icon-lock');
    $lockrevision.html('<span>This bin is now locked from further changes</span>');
    $lockrevision.data('locked', true);
    saveChecksum = false;
    $document.trigger('locked');
  }
  return false;
}).on('mouseup', function () {
  return false;
});

$document.on('saved', function () {
  $lockrevision.removeClass('icon-lock').addClass('icon-unlocked').data('locked', false);
  $lockrevision.html('<span>Click to lock and prevent further changes</span>');
});

$('#share input[type=text], #share textarea').on('beforecopy', function (event) {
  analytics.share('copy', this.getAttribute('data-path').substring(1) || 'output');
});

var $panelCheckboxes = $('#sharepanels input').on('change click', updateSavedState);
$('#sharemenu').bind('open', function () {
  // analytics.openShare();
  // $lockrevision.removeClass('icon-unlock').addClass('icon-lock');

  $panelCheckboxes.attr('checked', false);
  jsbin.panels.getVisible().forEach(function (panel) {
    $panelCheckboxes.filter('[data-panel="' + panel.id + '"]').attr('checked', true).change();
  });

});

var dropdownOpen = false,
    onhover = false,
    menuDown = false;

function opendropdown(el) {
  var menu;
  if (!dropdownOpen) {
    menu = $(el).closest('.menu').addClass('open').trigger('open');
    // $body.addClass('menuinfo');
    analytics.openMenu(el.hash.substring(1));
    var input = menu.find(':text:visible:first').focus()[0];
    if (input) setTimeout(function () {
      input.select();
    }, 0);
    dropdownOpen = el;
  }
}

function closedropdown() {
  menuDown = false;
  if (dropdownOpen) {
    dropdownButtons.closest('.menu').removeClass('open').trigger('close');
    // $body.removeClass('menuinfo');
    dropdownOpen = false;
    onhover = false;
  }
}

var dropdownButtons = $('.button-dropdown, .button-open').mousedown(function (e) {
  $dropdownLinks.removeClass('hover');
  if (dropdownOpen && dropdownOpen !== this) {
    closedropdown();
  }
  if (!dropdownOpen) {
    menuDown = true;
    opendropdown(this);
  }
  e.preventDefault();
  return false;
}).mouseup(function () {
  if (menuDown) return false;
}).click(function () {
  if (!menuDown) {
    analytics.closeMenu(this.hash.substring(1));
    closedropdown();
  }
  menuDown = false;
  return false;
});

$('#actionmenu').click(function () {
  dropdownOpen = true;
});

var ignoreUp = false;
$body.bind('mousedown', function (event) {
  if (dropdownOpen) {
    if ($(event.target).closest('.menu').length) {
      ignoreUp = true;
    }
  }
}).bind('click mouseup', function (event) {
  if (dropdownOpen && !ignoreUp) {
    if (!$(event.target).closest('.menu').length) {
      closedropdown();
      return false;
    }
  }
  ignoreUp = false;
});

var fromClick = false;
var $dropdownLinks = $('.dropdownmenu a, .dropdownmenu .button').mouseup(function () {
  setTimeout(closedropdown, 0);
  analytics.selectMenu(this.getAttribute('data-label') || this.hash.substring(1) || this.href);
  if (!fromClick) {
    if (this.hostname === window.location.hostname) {
      if ($(this).triggerHandler('click') !== false) {
        window.location = this.href;
      }
    } else {
      if (this.getAttribute('target')) {
        window.open(this.href);
      } else {
        window.location = this.href;
      }
    }
  }
  fromClick = false;
}).mouseover(function () {
  $dropdownLinks.removeClass('hover');
  $(this).addClass('hover');
}).mousedown(function () {
  fromClick = true;
});

$('#jsbinurl').click(function (e) {
  setTimeout(function () {
    jsbin.panels.panels.live.hide();
  }, 0);
});

$('#runwithalerts').click(function (event, data) {
  analytics.run(data);
  if (editors.console.visible) {
    editors.console.render(true);
  } else {
    renderLivePreview(true);
  }
  return false;
});

$('#runconsole').click(function () {
  analytics.runconsole();
  editors.console.render(true);
  return false;
});

$('#showhelp').click(function () {
  $body.toggleClass('keyboardHelp');
  keyboardHelpVisible = $body.is('.keyboardHelp');
  if (keyboardHelpVisible) {
    // analytics.help('keyboard');
  }
  return false;
});

$('#showurls').click(function () {
  $body.toggleClass('urlHelp');
  urlHelpVisible = $body.is('.urlHelp');
  if (urlHelpVisible) {
    // analytics.urls();
  }
  return false;
});

$('.code.panel > .label > span.name').dblclick(function () {
  jsbin.panels.allEditors(function (panel) {
    var lineNumbers = !panel.editor.getOption('lineNumbers');
    panel.editor.setOption('lineNumbers', lineNumbers);
    jsbin.settings.editor.lineNumbers = lineNumbers;
  });
});

$('#createnew').click(function () {
  var i, key;
  analytics.createNew();
  // FIXME this is out and out [cr]lazy....
  jsbin.panels.savecontent = function(){};
  for (i = 0; i < sessionStorage.length; i++) {
    key = sessionStorage.key(i);
    if (key.indexOf('jsbin.content.') === 0) {
      sessionStorage.removeItem(key);
    }
  }

  jsbin.panels.saveOnExit = true;

  // first try to restore their default panels
  jsbin.panels.restore();

  // if nothing was shown, show html & live
  setTimeout(function () {
    if (jsbin.panels.getVisible().length === 0) {
      jsbin.panels.panels.html.show();
      jsbin.panels.panels.live.show();
    }
  }, 0);
});

$('form.login').closest('.menu').bind('close', function () {
  $(this).find('.loginFeedback').empty().hide();
  $('#login').removeClass('forgot');
});

$('#lostpass').click(function (e) {
  $('#login').addClass('forgot').find('input[name=email]').focus();
  return false;
});

jsbin.settings.includejs = jsbin.settings.includejs === undefined ? true : jsbin.settings.includejs;

$('#enablejs').change(function () {
  jsbin.settings.includejs = this.checked;
  analytics.enableLiveJS(jsbin.settings.includejs);
  editors.live.render();
}).attr('checked', jsbin.settings.includejs);

if (jsbin.settings.hideheader) {
  $body.addClass('hideheader');
}

var cancelUp = false;
$('form input, form textarea').focus(function () {
  this.select();
  cancelUp = true;
}).mouseup(function () {
  if (cancelUp) {
    cancelUp = false;
    return false;
  }
});

if (window.location.hash) {
  $('a[href$="' + window.location.hash + '"]').mousedown();
}

var ismac = navigator.userAgent.indexOf(' Mac ') !== -1,
    mackeys = {
      'ctrl': 'âŒ˜',
      'shift': 'â‡§'
    };

$('#control').find('a[data-shortcut]').each(function () {
  var $this = $(this),
      data = $this.data();

  var key = data.shortcut;
  if (ismac) {
    key = key.replace(/ctrl/i, mackeys.ctrl).replace(/shift/, mackeys.shift).replace(/\+/g, '').toUpperCase();
  }

  $this.append('<span class="keyshortcut">' + key + '</span>');
});

(function () {

var re = {
  head: /<head(.*)\n/i,
  meta: /<meta name="description".*?>/i,
  metaContent: /content=".*?"/i
};

var metatag = '<meta name="description" content="[add your bin description]" />\n';

$('#addmeta').click(function () {
  // if not - insert
  // <meta name="description" content="" />
  // if meta description is in the HTML, highlight it
  var editor = jsbin.panels.panels.html,
      cm = editor.editor,
      html = editor.getCode();

  if (!re.meta.test(html)) {
    if (re.head.test(html)) {
      html = html.replace(re.head, '<head$1\n' + metatag);
    } else {
      // slap in the top
      html = metatag + html;
    }
  }

  editor.setCode(html);

  // now select the text
  // editor.editor is the CM object...yeah, sorry about that...
  var cursor = cm.getSearchCursor(re.meta);
  cursor.findNext();

  var contentCursor = cm.getSearchCursor(re.metaContent);
  contentCursor.findNext();

  var from = { line: cursor.pos.from.line, ch: cursor.pos.from.ch + '<meta name="description" content="'.length },
      to = { line: contentCursor.pos.to.line, ch: contentCursor.pos.to.ch - 1 };

  cm.setCursor(from);
  cm.setSelection(from, to);
  cm.on('cursoractivity', function () {
    cm.on('cursoractivity', null);
    mark.clear();
  });

  var mark = cm.markText(from, to, { className: 'highlight' });

  cm.focus();

  return false;
});

// add navigation to insert meta data


}());
;function allowDrop(holder) {
  holder.ondragover = function () {
    return false;
  };

  holder.ondragend = function () {
    return false;
  };

  var jstypes = {
    'javascript': 1,
    'coffeescript': 1,
    'coffee': 1,
    'js' :1
  },
  csstypes = {
    'css': 1,
    'less': 1,
    'sass': 1
  };

  holder.ondrop = function (e) {
    e.preventDefault();

    var file = e.dataTransfer.files[0],
        reader = new FileReader();
    reader.onload = function (event) {
      // put JS in the JavaScript panel
      var type = file.type ? file.type.toLowerCase().replace(/^text\//, '') : file.name.toLowerCase().replace(/.*\./g, ''),
          panelId = 'html',
          panel = editors[panelId],
          syncCode = event.target.result,
          scroller = null;

      if (jstypes[type]) {
        panelId = 'javascript';
      } else if (csstypes[type]) {
        panelId = 'css';
      }

      panel = editors[panelId];
      scroller = panel.editor.scroller;

      panel.setCode(event.target.result);
      panel.show();

      try {
        // now kick off - basically just doing a copy and paste job from @wookiehangover - thanks man! :)
        var worker = new Worker(jsbin.root + '/js/editors/sync-worker.js');

        // pass the worker the file object
        worker.postMessage(file);

        panel.$el.find('> .label').append('<small> (live: edit & save in your fav editor)</small>');

        // bind onmessage handler
        worker.onmessage = function (event) {
          var top = scroller.scrollTop;
          panel.setCode(event.data.body);
          scroller.scrollTop = top;
          syncCode = event.data.body;
        };

        /* FIXME for now, there's a bug in CodeMirror 2 whereby binding the
          onKeyEvent causes all cursor keys to be ate :( */
        // panel.editor.setOption('onKeyEvent', function (event) {
        //   if (syncCode !== panel.editor.getCode()) {
        //     worker.terminate();
        //     console.log('terminate');
        //     panel.$el.find('> .label small').remove();
        //     panel.editor.setOption('onKeyEvent', function () { return true });
        //   }
        //   return event;
        // });
      } catch (e) {
        // fail on the awesomeness...oh well
      }
    };

    reader.readAsText(file);

    return false;
  };
}

// test for dnd and file api first
if (!!(window.File && window.FileList && window.FileReader)) allowDrop(document.body);
;var Gist = (function () {

  // Only allow gist import/export if CORS is supported
  var CORS = !!('withCredentials' in new XMLHttpRequest() ||
                typeof XDomainRequest !== "undefined");
  if (!CORS) return $(function () {
    $('#export-as-gist').remove();
  });

  var Gist = function (id) {
    var gist = this,
        token = '';
    gist.code = {};
    if (jsbin.user && jsbin.user.github_token) {
      token = '?access_token=' + jsbin.user.github_token;
    }
    $.get('https://api.github.com/gists/' + id + token, function (data) {
      if (!data) return;
      $.each(data.files, function (fileName, fileData) {
        console.log.apply(console, [].slice.call(arguments));
        var ext = fileName.split('.').slice(-1).join('');
        console.log(ext);
        gist.code[ext] = fileData.content;
      });
      gist.setCode();
    });
    return this;
  };

  Gist.prototype.setCode = function () {
    var gist = this;
    $.each(gist.code, function (ext, data) {
      var processorInit = jsbin.processors.findByExtension(ext),
          target = processorInit.target || processorInit.id,
          panel = jsbin.panels.panels[target];
      if (!panel) return;
      processors.set(target, processorInit.id);
      panel.setCode(data);
    });
  };

  /**
   * Export as gist
   */

  $('#export-as-gist').click(function (e) {
    var gist = {
      'public': true,
      files: {}
    };
    var panels = [
      { panel: 'html' },
      { panel: 'css' },
      { panel: 'javascript', extension: 'js' }
    ];

    // Add files to gist for each panel
    panels.forEach(function (data, index) {
      var code;
      try {
        code = jsbin.panels.panels[data.panel].getCode();
      } catch(e) {}
      if (!code || !code.length) return;
      // Figure out what the file extension should be according to the processor
      var ext = data.extension || data.panel,
          processor = jsbin.panels.panels[data.panel].processor;
      if (processor && processor.extensions) {
        ext = processor.extensions[0] || processor.name;
      }
      // Build a file name
      var file = ['jsbin', jsbin.state.code, ext].join('.');
      gist.files[file] = {
        content: code
      };
    });

    var token = '';
    if (jsbin.user && jsbin.user.github_token) {
      token = '?access_token=' + jsbin.user.github_token;
    }

    $.ajax({
      type: "POST",
      url: 'https://api.github.com/gists' + token,
      data: JSON.stringify(gist),
      dataType: 'json',
      crossDomain: true,
      success: function (data) {
        $document.trigger('tip', {
          type: 'notification',
          content: 'Gist created! <a href="'+data.html_url+'" target="_blank">Open in new tab.</a>'
        });
      },
      error: function (xhr, status) {
        $document.trigger('tip', {
          type: 'error',
          content: 'Error: ' + status
        });
      }
    });
    // return false becuase there's weird even stuff going on. ask @rem.
    return false;
  });

  return Gist;

}());;// if a gist has been requested, lazy load the gist library and plug it in
if (/gist(\/.*)?\/\d+/.test(window.location.pathname) && (!sessionStorage.getItem('javascript') && !sessionStorage.getItem('html'))) {
  window.editors = editors; // needs to be global when the callback triggers to set the content
  loadGist = function () {
    $.getScript('/js/chrome/gist.js', function () {
      window.gist = new Gist(window.location.pathname.replace(/.*?(\d+).*/, "$1"));
    });
  };

  if (editors.ready) {
    loadGist();
  } else {
    $document.on('jsbinReady', loadGist);
  }
}

// prevent the app from accidently getting scrolled out of view
if (!jsbin.mobile) document.body.onscroll = window.onscroll = function () {
  if (document.body.scrollTop !== 0) {
    window.scrollTo(0,0);
  }
  return false;
};

window.CodeMirror = CodeMirror; // fix to allow code mirror to break naturally

// These are keys that CodeMirror (and Emmet) should never take over
// ref: https://gist.github.com/rodneyrehm/5213304
delete CodeMirror.keyMap['default']['Cmd-L'];
delete CodeMirror.keyMap['default']['Cmd-T'];
delete CodeMirror.keyMap['default']['Cmd-W'];
delete CodeMirror.keyMap['default']['Cmd-J'];
delete CodeMirror.keyMap['default']['Cmd-R'];


var link = document.createElement('link');
link.rel = 'stylesheet';
link.href = jsbin['static'] + '/css/font.css?' + jsbin.version;
link.type = 'text/css';
document.getElementsByTagName('head')[0].appendChild(link);

if (jsbin.embed) {
  analytics.embed();
}
;})(this, document);